CCS PCD C Compiler, Version 5.008, 5967               01-Dec-22 20:23

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4428 bytes (10%)
                           Largest free fragment is 39604
               RAM used:   3537 (22%) at main() level
                           3579 (22%) worst case
               Stack used: 76 locations (60 in main + 16 for interrupts)
               Stack size: 30

*
0000:  GOTO    F52
*
001A:  DATA    9A,02,00
001C:  DATA    00,02,00
*
0030:  DATA    2E,02,00
*
0050:  DATA    70,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
0368:  MOV     W5,[W15++]
036A:  MOV     #C,W5
036C:  REPEAT  #3
036E:  MOV     [W5++],[W15++]
0370:  MUL.UU  W0,W2,W4
0372:  BTSS    W3.F
0374:  BRA     37A
0376:  MUL.SS  W0,W3,W6
0378:  BRA     37C
037A:  MUL.UU  W0,W3,W6
037C:  BCLR.B  42.0
037E:  ADD     W6,W5,W5
0380:  ADDC    W7,#0,W8
0382:  BTSS    W1.F
0384:  BRA     38A
0386:  MUL.SS  W1,W2,W6
0388:  BRA     38C
038A:  MUL.UU  W1,W2,W6
038C:  ADDC    W6,W5,W5
038E:  ADDC    W7,W8,W8
0390:  ADDC    #0,W9
0392:  MUL.SS  W1,W3,W6
0394:  ADDC    W6,W8,W8
0396:  ADDC    W9,W7,W7
0398:  MOV     W7,W3
039A:  MOV     W8,W2
039C:  MOV     W5,W1
039E:  MOV     W4,W0
03A0:  MOV     #12,W5
03A2:  REPEAT  #3
03A4:  MOV     [--W15],[W5--]
03A6:  MOV     [--W15],W5
03A8:  RETURN  
03AA:  MOV     W5,[W15++]
03AC:  MOV     #C,W5
03AE:  REPEAT  #3
03B0:  MOV     [W5++],[W15++]
03B2:  MOV     W0,W4
03B4:  MOV     W1,W5
03B6:  MOV     W2,W6
03B8:  MOV     W3,W7
03BA:  CLR     W0
03BC:  CLR     W1
03BE:  CLR     W2
03C0:  CLR     W3
03C2:  BCLR    W8.0
03C4:  BTSS    W7.F
03C6:  BRA     3D2
03C8:  BSET    W6.0
03CA:  NEG     W4,W4
03CC:  COM     W5,W5
03CE:  COM     W6,W6
03D0:  COM     W7,W7
03D2:  XOR     W4,W5,W9
03D4:  BRA     NZ,3DA
03D6:  XOR     W6,W7,W9
03D8:  BRA     Z,402
03DA:  MOV     #D6,W1
03DC:  BTSC    W2.7
03DE:  BRA     3F2
03E0:  BCLR.B  42.0
03E2:  RLC     W4,W4
03E4:  RLC     W5,W5
03E6:  RLC     W6,W6
03E8:  RLC     W7,W7
03EA:  RLC     W0,W0
03EC:  RLC     W2,W2
03EE:  DEC     W1,W1
03F0:  BRA     NZ,3DC
03F2:  SWAP    W1
03F4:  BCLR.B  42.0
03F6:  RRC     W1,W1
03F8:  BCLR    W1.F
03FA:  BCLR    W2.7
03FC:  XOR.B   W2L,W1L,W1L
03FE:  BTSC    W6.0
0400:  BSET    W1.F
0402:  MOV     #12,W5
0404:  REPEAT  #3
0406:  MOV     [--W15],[W5--]
0408:  MOV     [--W15],W5
040A:  RETURN  
040C:  MOV     W5,[W15++]
040E:  MOV     #C,W5
0410:  REPEAT  #4
0412:  MOV     [W5++],[W15++]
0414:  MOV     W0,W4
0416:  MOV     W1,W5
0418:  MOV     W3,W7
041A:  MOV     W2,W6
041C:  BCLR.B  42.0
041E:  BCLR.B  42.1
0420:  RLC     W1,W1
0422:  SWAP    W1
0424:  AND     #FF,W1
0426:  CP0     W1
0428:  BRA     Z,4C0
042A:  BCLR.B  42.0
042C:  BCLR.B  42.1
042E:  RLC     W3,W3
0430:  SWAP    W3
0432:  AND     #FF,W3
0434:  CP0     W3
0436:  BRA     Z,4C0
0438:  ZE      W0,W0
043A:  ADD.B   W3L,W1L,W0L
043C:  BRA     C,446
043E:  SUB     #7F,W0
0440:  BRA     Z,4C0
0442:  BRA     NC,4C0
0444:  BRA     44A
0446:  ADD.B   #81,W0L
0448:  BRA     C,4C0
044A:  XOR     W5,W7,W10
044C:  BCLR.B  42.0
044E:  BCLR.B  42.1
0450:  AND     #FF,W5
0452:  BSET    W5.7
0454:  BCLR.B  42.0
0456:  AND     #FF,W7
0458:  BSET    W7.7
045A:  MUL.UU  W4,W6,W2
045C:  MUL.UU  W5,W6,W8
045E:  ADDC    W8,W3,W3
0460:  MOV     W9,W1
0462:  BTSC.B  42.0
0464:  INC     W1,W1
0466:  BCLR.B  42.0
0468:  MUL.UU  W7,W4,W8
046A:  ADDC    W8,W3,W3
046C:  ADDC    W9,W1,W1
046E:  MUL.UU  W5,W7,W8
0470:  ADDC    W8,W1,W1
0472:  INC     W0,W0
0474:  CP0     W1
0476:  BTSC.B  42.1
0478:  BRA     47C
047A:  BRA     482
047C:  CP0     W3
047E:  BTSC.B  42.1
0480:  BRA     48C
0482:  BTSC    W1.F
0484:  BRA     48C
0486:  RLC     W3,W3
0488:  RLC     W1,W1
048A:  DEC     W0,W0
048C:  MOV     W1,W2
048E:  BCLR.B  42.0
0490:  BTSS    W3.7
0492:  BRA     4A6
0494:  MOV     #FF00,W7
0496:  AND     W3,W7,W3
0498:  ADD     #100,W3
049A:  ADDC    W2,#0,W2
049C:  CP0     W2
049E:  BRA     NZ,4A6
04A0:  CP0     W3
04A2:  BRA     NZ,4A6
04A4:  INC     W0,W0
04A6:  SWAP    W0
04A8:  BCLR.B  42.0
04AA:  BCLR.B  42.1
04AC:  RRC     W0,W1
04AE:  BTSC    W10.F
04B0:  BSET    W1.F
04B2:  BCLR    W2.F
04B4:  SWAP    W2
04B6:  XOR.B   W2L,W1L,W1L
04B8:  SWAP    W3
04BA:  MOV.B   W3L,W2L
04BC:  MOV     W2,W0
04BE:  BRA     4C6
04C0:  MOV     #0,W0
04C2:  MOV     #0,W1
04C4:  BRA     4C6
04C6:  MOV     #14,W5
04C8:  REPEAT  #4
04CA:  MOV     [--W15],[W5--]
04CC:  MOV     [--W15],W5
04CE:  RETURN  
04D0:  MOV     W5,[W15++]
04D2:  MOV     #C,W5
04D4:  REPEAT  #3
04D6:  MOV     [W5++],[W15++]
04D8:  CLR     W9
04DA:  MOV     #8000,W8
04DC:  BTSC.B  43.0
04DE:  XOR     W8,W3,W3
04E0:  CP0     W0
04E2:  BRA     NZ,4EA
04E4:  MOV     #7FFF,W10
04E6:  AND     W1,W10,W10
04E8:  BTSS.B  42.1
04EA:  MOV     W1,W10
04EC:  XOR     W3,W10,W11
04EE:  MOV     W1,W6
04F0:  MOV     W3,W7
04F2:  MOV     W3,W12
04F4:  BCLR.B  42.1
04F6:  BCLR.B  42.0
04F8:  RLC     W6,W6
04FA:  SWAP    W6
04FC:  AND     #FF,W6
04FE:  CP0     W6
0500:  BRA     Z,644
0502:  BCLR.B  42.1
0504:  BCLR.B  42.0
0506:  RLC     W7,W7
0508:  SWAP    W7
050A:  AND     #FF,W7
050C:  CP0     W7
050E:  BRA     Z,64E
0510:  BCLR.B  42.1
0512:  BCLR.B  42.0
0514:  CP      W7,W6
0516:  BRA     Z,650
0518:  BRA     N,660
051A:  BCLR    W9.0
051C:  BSET    W9.1
051E:  SUB     W7,W6,W8
0520:  MOV     W7,W6
0522:  AND     #FF,W1
0524:  BSET    W1.7
0526:  AND     #FF,W3
0528:  BSET    W3.7
052A:  MOV     #28,W7
052C:  CP      W7,W8
052E:  BRA     N,552
0530:  BCLR.B  42.1
0532:  BCLR.B  42.0
0534:  RRC     W1,W1
0536:  RRC     W0,W0
0538:  DEC     W8,W8
053A:  BRA     NZ,530
053C:  BRA     558
053E:  MOV     #28,W7
0540:  CP      W7,W8
0542:  BRA     N,556
0544:  BCLR.B  42.1
0546:  BCLR.B  42.0
0548:  RRC     W3,W3
054A:  RRC     W2,W2
054C:  DEC     W8,W8
054E:  BRA     NZ,544
0550:  BRA     570
0552:  MOV     W2,W0
0554:  MOV     W3,W1
0556:  BRA     5DE
0558:  BTSS    W11.F
055A:  BRA     57E
055C:  BTSC    W9.4
055E:  MOV     W12,W11
0560:  NEG     W0,W0
0562:  BRA     Z,568
0564:  COM.B   W1L,W1L
0566:  BRA     56A
0568:  NEG     W1,W1
056A:  BTSC    W9.4
056C:  BRA     5C4
056E:  BRA     57E
0570:  BTSS    W11.F
0572:  BRA     57E
0574:  NEG     W2,W2
0576:  BRA     Z,57C
0578:  COM.B   W3L,W3L
057A:  BRA     57E
057C:  NEG     W3,W3
057E:  AND     #FF,W5
0580:  BCLR.B  42.1
0582:  BCLR.B  42.0
0584:  ADD     W0,W2,W0
0586:  ADDC.B  W1L,W3L,W1L
0588:  BTSC.B  42.0
058A:  BSET    W9.3
058C:  BTSC    W9.0
058E:  BRA     5A2
0590:  BTSC    W9.1
0592:  BRA     596
0594:  BRA     5AC
0596:  BTSC    W11.F
0598:  BRA     5C4
059A:  BTSC    W9.3
059C:  BRA     5F0
059E:  BSET    W9.6
05A0:  BRA     5DE
05A2:  BTSC    W11.F
05A4:  BRA     5C4
05A6:  BTSC    W9.3
05A8:  BRA     5F0
05AA:  BRA     5DE
05AC:  BCLR    W9.2
05AE:  BTSC    W11.F
05B0:  BRA     5BA
05B2:  MOV     W10,W11
05B4:  BTSC    W9.3
05B6:  BRA     5F0
05B8:  BRA     626
05BA:  BSET    W9.4
05BC:  XOR.B   #80,W1L
05BE:  BTSC    W1.7
05C0:  BRA     55C
05C2:  MOV     W10,W11
05C4:  AND     #FF,W1
05C6:  IOR      W0,  W1,W7
05C8:  BRA     Z,5DE
05CA:  BTSC    W1.7
05CC:  BRA     5DE
05CE:  BCLR.B  42.1
05D0:  BCLR.B  42.0
05D2:  RLC     W0,W0
05D4:  RLC     W1,W1
05D6:  DEC     W6,W6
05D8:  BTSC.B  42.1
05DA:  BRA     63E
05DC:  BRA     5CA
05DE:  BTSC    W9.0
05E0:  MOV     W10,W11
05E2:  BTSC    W9.1
05E4:  MOV     W12,W11
05E6:  BTSS    W9.5
05E8:  BRA     61E
05EA:  BTSC    W10.F
05EC:  BSET    W0.8
05EE:  BRA     626
05F0:  BSET.B  42.0
05F2:  RRC.B   W1L,W1L
05F4:  RRC     W0,W0
05F6:  BTSC.B  42.0
05F8:  BSET    W9.5
05FA:  INC     W6,W6
05FC:  BRA     Z,63E
05FE:  BTSS    W9.5
0600:  BRA     612
0602:  INC     W0,W0
0604:  BRA     NZ,612
0606:  INC.B   W1L,W1L
0608:  BRA     NZ,612
060A:  RRC.B   W1L,W1L
060C:  RRC     W0,W0
060E:  INC     W6,W6
0610:  BRA     Z,63E
0612:  BTSC    W9.0
0614:  MOV     W10,W11
0616:  BTSC    W9.1
0618:  MOV     W12,W11
061A:  BTSC.B  42.1
061C:  BRA     63E
061E:  BTSC    W9.6
0620:  MOV     W10,W11
0622:  BTSC    W9.7
0624:  MOV     W12,W11
0626:  IOR      W0,  W1,W2
0628:  BRA     Z,670
062A:  BCLR    W1.7
062C:  SWAP    W6
062E:  BCLR.B  42.1
0630:  BCLR.B  42.0
0632:  RRC     W6,W6
0634:  XOR     W6,W1,W1
0636:  BSET    W1.F
0638:  BTSS    W11.F
063A:  BCLR    W1.F
063C:  BRA     670
063E:  MOV     #0,W0
0640:  MOV     #0,W1
0642:  BRA     670
0644:  BTSC    W10.F
0646:  XOR     W8,W3,W3
0648:  MOV     W2,W0
064A:  MOV     W3,W1
064C:  BRA     670
064E:  BRA     670
0650:  AND     #FF,W3
0652:  BSET    W3.7
0654:  AND     #FF,W1
0656:  BSET    W1.7
0658:  BTSC    W11.F
065A:  BCLR    W3.7
065C:  BSET    W9.2
065E:  BRA     570
0660:  SUB     W6,W7,W8
0662:  AND     #FF,W1
0664:  BSET    W1.7
0666:  AND     #FF,W3
0668:  BSET    W3.7
066A:  BCLR    W9.1
066C:  BSET    W9.0
066E:  BRA     53E
0670:  MOV     #12,W5
0672:  REPEAT  #3
0674:  MOV     [--W15],[W5--]
0676:  MOV     [--W15],W5
0678:  RETURN  
067A:  MOV     W0,W2
067C:  MOV     W1,W3
067E:  MOV.B   W1L,W0L
0680:  SWAP    W0
0682:  BSET    W0.F
0684:  RLC     W1,W1
0686:  SWAP    W1
0688:  ZE      W1,W1
068A:  MOV     #8E,W4
068C:  SUB.B   W4L,W1L,W1L
068E:  BRA     Z,69C
0690:  CP0     W0
0692:  BRA     Z,69C
0694:  BCLR.B  42.0
0696:  RRC     W0,W0
0698:  DEC     W1,W1
069A:  BRA     NZ,690
069C:  BTSS    W3.F
069E:  BRA     6A4
06A0:  NEG     W0,W0
06A2:  BRA     6A4
06A4:  RETURN  
*
0856:  MOV     W5,[W15++]
0858:  MOV     W6,[W15++]
085A:  MOV     W0,W4
085C:  MOV     W1,W5
085E:  CLR     W0
0860:  CLR     W1
0862:  BCLR    W6.0
0864:  BTSS    W5.F
0866:  BRA     874
0868:  BSET    W6.0
086A:  NEG     W4,W4
086C:  BRA     Z,872
086E:  COM     W5,W5
0870:  BRA     874
0872:  NEG     W5,W5
0874:  IOR      W4,  W5,W3
0876:  BRA     Z,89E
0878:  CLR     W2
087A:  MOV     #B6,W1
087C:  BTSC    W2.7
087E:  BRA     88E
0880:  BCLR.B  42.0
0882:  RLC     W4,W4
0884:  RLC     W5,W5
0886:  RLC     W0,W0
0888:  RLC     W2,W2
088A:  DEC     W1,W1
088C:  BRA     NZ,87C
088E:  SWAP    W1
0890:  BCLR.B  42.0
0892:  RRC     W1,W1
0894:  BCLR    W1.F
0896:  BCLR    W2.7
0898:  XOR.B   W2L,W1L,W1L
089A:  BTSC    W6.0
089C:  BSET    W1.F
089E:  MOV     [--W15],W6
08A0:  MOV     [--W15],W5
08A2:  RETURN  
08A4:  MOV     W5,[W15++]
08A6:  MOV     #C,W5
08A8:  REPEAT  #4
08AA:  MOV     [W5++],[W15++]
08AC:  CLR     W9
08AE:  XOR     W1,W3,W9
08B0:  MOV     W1,W6
08B2:  MOV     W0,W5
08B4:  MOV     W3,W8
08B6:  MOV     W2,W7
08B8:  RLC     W1,W1
08BA:  SWAP    W1
08BC:  ZE      W1,W1
08BE:  CP0     W1
08C0:  BRA     Z,95E
08C2:  RLC     W3,W3
08C4:  SWAP    W3
08C6:  ZE      W3,W3
08C8:  CP0     W3
08CA:  BRA     Z,95E
08CC:  CLR     W0
08CE:  SUB.B   W1L,W3L,W0L
08D0:  BRA     NC,8D8
08D2:  ADD.B   #7F,W0L
08D4:  BRA     C,95E
08D6:  BRA     8DE
08D8:  SUB.B   #81,W0L
08DA:  BRA     NC,95E
08DC:  BRA     Z,95E
08DE:  MOV     W5,W1
08E0:  MOV     W6,W2
08E2:  BSET    W2.7
08E4:  AND     #FF,W2
08E6:  AND     #FF,W8
08E8:  BSET    W8.7
08EA:  MOV     #19,W10
08EC:  CLR     W3
08EE:  CLR     W4
08F0:  SUB     W1,W7,W1
08F2:  SUBB    W2,W8,W2
08F4:  BRA     N,8FA
08F6:  BRA     C,900
08F8:  BRA     NZ,902
08FA:  ADD     W1,W7,W1
08FC:  ADDC    W2,W8,W2
08FE:  BRA     902
0900:  BSET    W4.0
0902:  DEC     W10,W10
0904:  BRA     Z,914
0906:  BCLR.B  42.0
0908:  RLC     W1,W1
090A:  RLC     W2,W2
090C:  BCLR.B  42.0
090E:  RLC     W4,W4
0910:  RLC     W3,W3
0912:  BRA     8F0
0914:  CLR     W10
0916:  BTSC    W3.8
0918:  BRA     91C
091A:  BRA     928
091C:  BCLR.B  42.0
091E:  RRC     W3,W3
0920:  BCLR    W3.7
0922:  RRC     W4,W4
0924:  RLC     W10,W10
0926:  BRA     92C
0928:  DEC     W0,W0
092A:  BRA     Z,95E
092C:  BTSC    W10.F
092E:  BRA     NC,93A
0930:  RLC     W1,W1
0932:  RLC     W2,W2
0934:  SUB     W1,W7,W1
0936:  SUBB    W2,W8,W2
0938:  BRA     NC,94C
093A:  INC     W4,W4
093C:  BRA     NZ,94C
093E:  INC     W3,W3
0940:  BRA     NZ,94C
0942:  INC     W0,W0
0944:  BRA     Z,95E
0946:  BRA     94C
0948:  DEC     W0,W0
094A:  BRA     Z,95E
094C:  SWAP    W0
094E:  RRC     W0,W1
0950:  BSET    W1.F
0952:  BTSS    W9.F
0954:  BCLR    W1.F
0956:  BCLR    W3.7
0958:  XOR.B   W3L,W1L,W1L
095A:  MOV     W4,W0
095C:  BRA     964
095E:  MOV     #0,W0
0960:  MOV     #0,W1
0962:  BRA     964
0964:  MOV     #14,W5
0966:  REPEAT  #4
0968:  MOV     [--W15],[W5--]
096A:  MOV     [--W15],W5
096C:  RETURN  
096E:  MOV     W8,[W15++]
0970:  MOV     #12,W8
0972:  REPEAT  #4
0974:  MOV     [W8++],[W15++]
0976:  MOV     #0,W9
0978:  BTSC.B  43.0
097A:  MOV     #1,W9
097C:  MOV     W9,[W15++]
097E:  CLR     W8
0980:  CLR     W9
0982:  CLR     W10
0984:  CLR     W11
0986:  CLR     W12
0988:  CLR     W13
098A:  MOV     #E,W8
098C:  MOV     #0,W9
098E:  LNK     #10
0990:  MOV     W12,[W14+W8]
0992:  DEC2    W8,W8
0994:  BRA     NN,990
0996:  XOR     W4,W5,W8
0998:  BRA     NZ,99E
099A:  XOR     W6,W7,W8
099C:  BRA     Z,A2E
099E:  CLR     W8
09A0:  CLR     W13
09A2:  MOV     W13,[W15++]
09A4:  BTSS    W3.F
09A6:  BRA     9BC
09A8:  MOV     [--W15],W13
09AA:  BSET    W13.F
09AC:  MOV     W13,[W15++]
09AE:  COM     W3,W3
09B0:  COM     W2,W2
09B2:  COM     W1,W1
09B4:  NEG     W0,W0
09B6:  ADDC    W1,#0,W1
09B8:  ADDC    W2,#0,W2
09BA:  ADDC    W3,#0,W3
09BC:  BTSS    W7.F
09BE:  BRA     9D4
09C0:  MOV     [--W15],W13
09C2:  BTG     W13.F
09C4:  MOV     W13,[W15++]
09C6:  COM     W7,W7
09C8:  COM     W6,W6
09CA:  COM     W5,W5
09CC:  NEG     W4,W4
09CE:  ADDC    W5,#0,W5
09D0:  ADDC    W6,#0,W6
09D2:  ADDC    W7,#0,W7
09D4:  MOV     #40,W13
09D6:  BCLR.B  42.0
09D8:  RLC     W0,W0
09DA:  RLC     W1,W1
09DC:  RLC     W2,W2
09DE:  RLC     W3,W3
09E0:  RLC     W8,W8
09E2:  RLC     W9,W9
09E4:  RLC     W10,W10
09E6:  RLC     W11,W11
09E8:  CP      W11,W7
09EA:  BRA     NZ,9F6
09EC:  CPB     W10,W6
09EE:  BRA     NZ,9F6
09F0:  CPB     W9,W5
09F2:  BRA     NZ,9F6
09F4:  CPB     W8,W4
09F6:  BRA     NC,A02
09F8:  SUB     W8,W4,W8
09FA:  SUBB    W9,W5,W9
09FC:  SUBB    W10,W6,W10
09FE:  SUBB    W11,W7,W11
0A00:  BSET.B  42.0
0A02:  MOV     W8,[W14]
0A04:  MOV     W9,[W14+#2]
0A06:  MOV     W10,[W14+#4]
0A08:  MOV     W11,[W14+#6]
0A0A:  MOV     [W14+#8],W8
0A0C:  MOV     [W14+#A],W9
0A0E:  MOV     [W14+#C],W10
0A10:  MOV     [W14+#E],W11
0A12:  RLC     W8,W8
0A14:  RLC     W9,W9
0A16:  RLC     W10,W10
0A18:  RLC     W11,W11
0A1A:  MOV     W8,[W14+#8]
0A1C:  MOV     W9,[W14+#A]
0A1E:  MOV     W10,[W14+#C]
0A20:  MOV     W11,[W14+#E]
0A22:  MOV     [W14],W8
0A24:  MOV     [W14+#2],W9
0A26:  MOV     [W14+#4],W10
0A28:  MOV     [W14+#6],W11
0A2A:  DEC     W13,W13
0A2C:  BRA     NZ,9D6
0A2E:  MOV     [W14+#8],W0
0A30:  MOV     [W14+#A],W1
0A32:  MOV     [W14+#C],W2
0A34:  MOV     [W14+#E],W3
0A36:  MOV     [--W15],W13
0A38:  BTSS    W13.F
0A3A:  BRA     A4A
0A3C:  COM     W3,W3
0A3E:  COM     W2,W2
0A40:  COM     W1,W1
0A42:  NEG     W0,W0
0A44:  ADDC    W1,#0,W1
0A46:  ADDC    W2,#0,W2
0A48:  ADDC    W3,#0,W3
0A4A:  ULNK    
0A4C:  BRA     A4E
0A4E:  MOV     [--W15],W9
0A50:  CP0     W9
0A52:  BRA     Z,A5C
0A54:  MOV     W8,W0
0A56:  MOV     W9,W1
0A58:  MOV     W10,W2
0A5A:  MOV     W11,W3
0A5C:  MOV     #1A,W8
0A5E:  REPEAT  #4
0A60:  MOV     [--W15],[W8--]
0A62:  MOV     [--W15],W8
0A64:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
024E:  MOV     W5,[W15++]
0250:  MOV     #4B00,W5
0252:  REPEAT  #19E
0254:  NOP     
0256:  DEC     W5,W5
0258:  BRA     NZ,260
025A:  CLR     85A
025C:  MOV     #0,W0
025E:  BRA     26C
0260:  BTSS.B  232.0
0262:  BRA     252
0264:  PUSH    232
0266:  POP     85A
0268:  MOV     236,W0
026A:  BCLR.B  232.1
026C:  MOV     [--W15],W5
026E:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14   
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 PercentError; 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... unsigned int16 TempInputSamples[2]; 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
.................... FlagType TriggerValueFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... void DisableInterrupts(void); 
.................... void EnableInterrupts(void); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH]; // =  
.................... //!{ 
.................... //!     -129,     19,     39,    -74,    -39,    301,    604,    354,   -397, 
.................... //!     -894,   -580,     91,    196,   -272,   -154,   1241,   2589,   1599, 
.................... //!    -1984,  -5096,  -4105,    977,   5788,   5788,    977,  -4105,  -5096, 
.................... //!    -1984,   1599,   2589,   1241,   -154,   -272,    196,     91,   -580, 
.................... //!     -894,   -397,    354,    604,    301,    -39,    -74,     39,     19, 
.................... //!     -129,   -192,    -81,     71,    115,     55,     -6,    -15,     16, 
.................... //!       -9 
.................... //!}; 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    if ((TriggerFlag == 2) || (TriggerValueFlag == 0)) 
020E:  MOV     1226,W4
0210:  CP.B    W4L,#2
0212:  BRA     Z,218
0214:  CP0.B   1228
0216:  BRA     NZ,21C
....................    { 
....................       DMADoneFlag = 1; 
0218:  MOV.B   #1,W0L
021A:  MOV.B   W0L,1222
....................    } 
.................... } 
....................  
021C:  BCLR.B  84.4
021E:  MOV     #1A,W0
0220:  REPEAT  #C
0222:  MOV     [--W15],[W0--]
0224:  MOV     [--W15],W0
0226:  POP     32
0228:  POP     36
022A:  POP     42
022C:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
022E:  PUSH    42
0230:  PUSH    36
0232:  PUSH    32
0234:  MOV     W0,[W15++]
0236:  MOV     #2,W0
0238:  REPEAT  #C
023A:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
023C:  BCLR.B  85.6
023E:  MOV     #1A,W0
0240:  REPEAT  #C
0242:  MOV     [--W15],[W0--]
0244:  MOV     [--W15],W0
0246:  POP     32
0248:  POP     36
024A:  POP     42
024C:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0270:  PUSH    42
0272:  PUSH    36
0274:  PUSH    32
0276:  MOV     W0,[W15++]
0278:  MOV     #2,W0
027A:  REPEAT  #C
027C:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
027E:  CALL    24E
0282:  MOV.B   W0L,961
....................    UARTRXFlag = 1; 
0284:  MOV.B   #1,W0L
0286:  MOV.B   W0L,1224
.................... } 
....................  
0288:  BCLR.B  87.6
028A:  MOV     #1A,W0
028C:  REPEAT  #C
028E:  MOV     [--W15],[W0--]
0290:  MOV     [--W15],W0
0292:  POP     32
0294:  POP     36
0296:  POP     42
0298:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
029A:  PUSH    42
029C:  PUSH    36
029E:  PUSH    32
02A0:  MOV     W0,[W15++]
02A2:  MOV     #2,W0
02A4:  REPEAT  #C
02A6:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); 
02A8:  BCLR.B  2C9.6
02AA:  BTG.B   2CD.6
....................    //read_adc(); 
....................    if((NormalizeFlag == 1) || (TriggerValueFlag == 0)) 
02AC:  MOV     1222,W4
02AE:  LSR     W4,#8,W4
02B0:  CP.B    W4L,#1
02B2:  BRA     Z,2B8
02B4:  CP0.B   1228
02B6:  BRA     NZ,2C8
....................    { 
....................       read_adc(); 
02B8:  BCLR.B  320.0
02BA:  BSET.B  320.1
02BC:  BTSS.B  320.0
02BE:  BRA     2BC
....................       NormalizeDataCounter++; 
02C0:  INC     121E
02C2:  BTSC.B  42.1
02C4:  INC     1220
....................    } 
02C6:  BRA     34A
....................    else 
....................    { 
....................       unsigned int16 ADCValue = 0; 
02C8:  CLR     12D8
....................        
....................       if (DMAFlag == 0) 
02CA:  CP0.B   1227
02CC:  BRA     NZ,2DC
....................       { 
....................          //disable_interrupts(INT_DMA0); 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
02CE:  MOV     #4000,W1
02D0:  MOV     #0,W2
02D2:  REPEAT  #1FD
02D4:  CLR.B   [W1++]
....................          TriggerFlag = 0; 
02D6:  CLR.B   1226
....................          DMAFlag = 1; 
02D8:  MOV.B   #1,W0L
02DA:  MOV.B   W0L,1227
....................       } 
....................        
....................       if (TriggerFlag != 2) 
02DC:  MOV     1226,W4
02DE:  CP.B    W4L,#2
02E0:  BRA     Z,308
....................       { 
....................             
....................            if(DMAFlag != 2) 
02E2:  MOV     1226,W4
02E4:  LSR     W4,#8,W4
02E6:  CP.B    W4L,#2
02E8:  BRA     Z,2FA
....................            { 
....................               dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
02EA:  BCLR.B  381.7
02EC:  CLR.B   380
02EE:  MOV     #4000,W4
02F0:  MOV     W4,384
02F2:  MOV     #FF,W4
02F4:  MOV     W4,38A
02F6:  BSET.B  381.7
....................               enable_interrupts(INT_DMA0); 
02F8:  BSET.B  94.4
....................            } 
....................            //ADCValue = QuickDigitize(read_adc()); // Trigger on Output Wave 
....................            ADCValue = read_adc() >> 4; 
02FA:  BCLR.B  320.0
02FC:  BSET.B  320.1
02FE:  BTSS.B  320.0
0300:  BRA     2FE
0302:  MOV     300,W5
0304:  LSR     W5,#4,W0
0306:  MOV     W0,12D8
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
0308:  MOV     12D8,W0
030A:  CP      966
030C:  BRA     NZ,320
030E:  CP0.B   1226
0310:  BRA     NZ,320
....................       { 
....................          TempInputSamples[0] = ADCValue; 
0312:  PUSH    12D8
0314:  POP     11F6
....................          DMAFlag = 2; 
0316:  MOV.B   #2,W0L
0318:  MOV.B   W0L,1227
....................          TriggerFlag = 1; 
031A:  MOV.B   #1,W0L
031C:  MOV.B   W0L,1226
....................       } 
031E:  BRA     34A
....................       else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) 
0320:  MOV     11F6,W0
0322:  MOV     12D8,W4
0324:  CP      W4,W0
0326:  BRA     LEU,338
0328:  MOV     1226,W4
032A:  CP.B    W4L,#1
032C:  BRA     NZ,338
....................       { 
....................          TempInputSamples[1] = ADCValue; 
032E:  PUSH    12D8
0330:  POP     11F8
....................          TriggerFlag = 2; 
0332:  MOV.B   #2,W0L
0334:  MOV.B   W0L,1226
....................       } 
0336:  BRA     34A
....................       else if(TriggerFlag == 2) 
0338:  MOV     1226,W4
033A:  CP.B    W4L,#2
033C:  BRA     NZ,348
....................       {     
....................          read_adc(); 
033E:  BCLR.B  320.0
0340:  BSET.B  320.1
0342:  BTSS.B  320.0
0344:  BRA     342
....................       }   
0346:  BRA     34A
....................       else 
....................       { 
....................          DMAFlag = 0;           
0348:  CLR.B   1227
....................       } 
....................    } 
034A:  BCLR.B  84.3
034C:  MOV     #1A,W0
034E:  REPEAT  #C
0350:  MOV     [--W15],[W0--]
0352:  MOV     [--W15],W0
0354:  POP     32
0356:  POP     36
0358:  POP     42
035A:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0F52:  MOV     #4444,W0
0F54:  MOV     W0,A4
0F56:  BSET.B  81.7
0F58:  MOV     #46,W0
0F5A:  MOV.B   W0L,742
0F5C:  MOV     #57,W0
0F5E:  MOV.B   W0L,742
0F60:  BCLR.B  742.6
0F62:  MOV     #3F07,W0
0F64:  MOV     W0,6A6
0F66:  MOV     #5,W0
0F68:  MOV     W0,6C6
0F6A:  MOV     #46,W0
0F6C:  MOV.B   W0L,742
0F6E:  MOV     #57,W0
0F70:  MOV.B   W0L,742
0F72:  BSET.B  742.6
0F74:  MOV     #41,W4
0F76:  MOV     W4,744
0F78:  MOV     #32,W4
0F7A:  MOV     W4,746
0F7C:  CLR     85A
0F7E:  MOV     #8000,W4
0F80:  MOV     W4,230
0F82:  MOV     #400,W4
0F84:  MOV     W4,232
0F86:  BSET.B  230.3
0F88:  MOV     #22,W4
0F8A:  MOV     W4,238
0F8C:  CLR     85E
0F8E:  CLR     964
0F90:  CLR     966
0F92:  CLR     968
0F94:  CLR     96A
0F96:  CLR     96C
0F98:  CLR     1166
0F9A:  CLR     1168
0F9C:  CLR     116A
0F9E:  CLR     116C
0FA0:  CLR     116E
0FA2:  CLR     1170
0FA4:  CLR     1172
0FA6:  CLR     1174
0FA8:  CLR     11FE
0FAA:  CLR     1200
0FAC:  CLR     1202
0FAE:  CLR     1204
0FB0:  CLR.B   961
0FB2:  CLR     1206
0FB4:  CLR     1208
0FB6:  CLR     120A
0FB8:  CLR     120C
0FBA:  CLR     120E
0FBC:  CLR     1210
0FBE:  CLR     1212
0FC0:  CLR     1214
0FC2:  CLR     1216
0FC4:  CLR     1218
0FC6:  CLR     121A
0FC8:  CLR     121C
0FCA:  CLR     121E
0FCC:  CLR     1220
0FCE:  CLR.B   1222
0FD0:  CLR.B   1223
0FD2:  CLR.B   1224
0FD4:  CLR.B   1225
0FD6:  CLR.B   1226
0FD8:  CLR.B   1227
0FDA:  CLR.B   1228
0FDC:  MOV     #41,W4
0FDE:  MOV     W4,744
0FE0:  MOV     #32,W4
0FE2:  MOV     W4,746
0FE4:  DISI    #E
0FE6:  MOV     #101,W0
0FE8:  MOV     #743,W1
0FEA:  MOV     #78,W2
0FEC:  MOV     #9A,W3
0FEE:  MOV.B   W2L,[W1]
0FF0:  MOV.B   W3L,[W1]
0FF2:  MOV.B   W0L,743
0FF4:  LSR     W0,#8,W0
0FF6:  MOV     #742,W1
0FF8:  MOV     #46,W2
0FFA:  MOV     #57,W3
0FFC:  MOV.B   W2L,[W1]
0FFE:  MOV.B   W3L,[W1]
1000:  MOV.B   W0L,[W1]
1002:  SETM    32C
1004:  MOV     #3F80,W15
1006:  MOV     #3FFF,W0
1008:  MOV     W0,20
100A:  NOP     
100C:  CLR     85C
100E:  MOV     #3F80,W15
1010:  MOV     #3FFF,W0
1012:  MOV     W0,20
1014:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
1016:  MOV     #4000,W1
1018:  MOV     #0,W2
101A:  REPEAT  #FE
101C:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
101E:  MOV     #41FE,W1
1020:  MOV     #61,W2
1022:  MOV.B   #61,W2L
1024:  REPEAT  #FE
1026:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
1028:  CLR.B   381
102A:  MOV.B   #D,W0L
102C:  MOV.B   W0L,382
102E:  MOV     #300,W4
1030:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
1032:  BCLR.B  381.7
1034:  CLR.B   380
1036:  MOV     #4000,W4
1038:  MOV     W4,384
103A:  MOV     #FF,W4
103C:  MOV     W4,38A
103E:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
1040:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
1042:  MOV     #9F00,W4
1044:  MOV     W4,324
1046:  MOV     #84E0,W4
1048:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
104A:  MOV     #FFFE,W4
104C:  MOV     W4,32C
104E:  CLR     322
....................     
....................    read_adc(); 
1050:  BCLR.B  320.0
1052:  BSET.B  320.1
1054:  BTSS.B  320.0
1056:  BRA     1054
....................       
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
1058:  CLR     104
105A:  PUSH    85E
105C:  POP     102
105E:  MOV     #8000,W4
1060:  MOV     W4,104
....................    EnableInterrupts(); 
1062:  CALL    35C
....................     
....................    NormalizeFlag = 1; 
1066:  MOV.B   #1,W0L
1068:  MOV.B   W0L,1223
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
106A:  CP0.B   1222
106C:  BRA     NZ,1078
106E:  MOV     121E,W4
1070:  XOR     #FF,W4
1072:  BRA     NZ,113C
1074:  CP0     1220
1076:  BRA     NZ,113C
....................       { 
....................          disable_interrupts(INT_DMA0); 
1078:  BCLR.B  94.4
....................  
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
107A:  CLR     12AA
107C:  CLR     12AC
107E:  MOV     12AC,W4
1080:  CP      W4,#0
1082:  BRA     GTU,10A2
1084:  BRA     NC,108E
1086:  MOV     12AA,W4
1088:  MOV     #FF,W3
108A:  CP      W3,W4
108C:  BRA     LEU,10A2
....................          { 
....................             AccumulateAnalogData(Index); 
108E:  PUSH    12AA
1090:  POP     12B4
1092:  PUSH    12AC
1094:  POP     12B6
1096:  CALL    6A6
109A:  INC     12AA
109C:  BTSC.B  42.1
109E:  INC     12AC
10A0:  BRA     107E
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
10A2:  MOV     1222,W4
10A4:  LSR     W4,#8,W4
10A6:  CP.B    W4L,#1
10A8:  BRA     NZ,10AE
....................          { 
....................             NormalizeData(); 
10AA:  CALL    A66
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
10AE:  MOV     1224,W4
10B0:  LSR     W4,#8,W4
10B2:  CP.B    W4L,#1
10B4:  BRA     NZ,1128
....................          {           
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
10B6:  CLR     12AE
10B8:  CLR     12B0
10BA:  MOV     12B0,W4
10BC:  CP      W4,#0
10BE:  BRA     GTU,10E4
10C0:  BRA     NC,10CA
10C2:  MOV     12AE,W4
10C4:  MOV     #FF,W3
10C6:  CP      W3,W4
10C8:  BRA     LEU,10E4
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
10CA:  MOV     #862,W4
10CC:  MOV     12AE,W3
10CE:  ADD     W3,W4,W0
10D0:  MOV.B   [W0],W5L
10D2:  BTSC.B  233.1
10D4:  BRA     10D2
10D6:  PUSH    234
10D8:  MOV.B   W5L,[W15-#2]
10DA:  POP     234
10DC:  INC     12AE
10DE:  BTSC.B  42.1
10E0:  INC     12B0
10E2:  BRA     10BA
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
10E4:  CLR     12AE
10E6:  CLR     12B0
10E8:  MOV     12B0,W4
10EA:  CP      W4,#0
10EC:  BRA     GTU,1128
10EE:  BRA     NC,10F8
10F0:  MOV     12AE,W4
10F2:  MOV     #FF,W3
10F4:  CP      W3,W4
10F6:  BRA     LEU,1128
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
10F8:  MOV     #2,W4
10FA:  CLR.B   9
10FC:  MOV     12AE,W0
10FE:  MOV     12B0,W1
1100:  INC     W4,W4
1102:  DEC     W4,W4
1104:  BRA     Z,110C
1106:  SL      W0,W0
1108:  RLC     W1,W1
110A:  BRA     1102
110C:  MOV     #96E,W4
110E:  ADD     W0,W4,W0
1110:  MOV     #A,W4
1112:  MOV     [W0++],[W4++]
1114:  MOV     [W0++],[W4++]
1116:  BTSC.B  233.1
1118:  BRA     1116
111A:  PUSH    234
111C:  MOV.B   W5L,[W15-#2]
111E:  POP     234
1120:  INC     12AE
1122:  BTSC.B  42.1
1124:  INC     12B0
1126:  BRA     10E8
....................             } 
....................          } 
....................           
....................          NormalizeFlag = 0; 
1128:  CLR.B   1223
....................          NormalizeDataCounter = 0; 
112A:  CLR     121E
112C:  CLR     1220
....................          HandShakeFlag = 0;    
112E:  CLR.B   1225
....................          CurrentIndex = 0; 
1130:  CLR     1212
1132:  CLR     1214
....................          enable_interrupts(INT_DMA0); 
1134:  BSET.B  94.4
....................          DMADoneFlag = 0; 
1136:  CLR.B   1222
....................          TriggerFlag = 0; 
1138:  CLR.B   1226
....................          DMAFlag = 0; 
113A:  CLR.B   1227
....................       }   
....................        
....................       if (UARTRXFlag) 
113C:  CP0.B   1224
113E:  BRA     Z,1148
....................       { 
....................          CommHandler(UARTRX); 
1140:  MOV.B   961,W0L
1142:  MOV.B   W0L,12B4
1144:  CALL    C98
....................       }   
1148:  BRA     106A
....................    } 
.................... } 
....................  
114A:  BRA     114A
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
06A6:  MOV     W5,[W15++]
06A8:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
06AA:  MOV     #1,W4
06AC:  CLR.B   9
06AE:  MOV     1212,W0
06B0:  MOV     1214,W1
06B2:  INC     W4,W4
06B4:  DEC     W4,W4
06B6:  BRA     Z,6BE
06B8:  SL      W0,W0
06BA:  RLC     W1,W1
06BC:  BRA     6B4
06BE:  MOV     #1176,W4
06C0:  ADD     W0,W4,W5
06C2:  MOV     #1,W4
06C4:  CLR.B   9
06C6:  MOV     12B4,W0
06C8:  MOV     12B6,W1
06CA:  INC     W4,W4
06CC:  DEC     W4,W4
06CE:  BRA     Z,6D6
06D0:  SL      W0,W0
06D2:  RLC     W1,W1
06D4:  BRA     6CC
06D6:  MOV     #4000,W4
06D8:  ADD     W0,W4,W0
06DA:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
06DC:  PUSH    1212
06DE:  POP     120E
06E0:  PUSH    1214
06E2:  POP     1210
....................    Accumulator = 0; 
06E4:  CLR     96A
06E6:  CLR     96C
....................    CoefficentIndex = 0; 
06E8:  CLR     120A
06EA:  CLR     120C
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
06EC:  MOV     120C,W4
06EE:  CP      W4,#0
06F0:  BRA     GTU,774
06F2:  BRA     NC,6FC
06F4:  MOV     120A,W4
06F6:  MOV     #3F,W3
06F8:  CP      W3,W4
06FA:  BRA     LEU,774
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
06FC:  MOV     #1,W4
06FE:  CLR.B   9
0700:  MOV     120E,W0
0702:  MOV     1210,W1
0704:  INC     W4,W4
0706:  DEC     W4,W4
0708:  BRA     Z,710
070A:  SL      W0,W0
070C:  RLC     W1,W1
070E:  BRA     706
0710:  MOV     #1176,W4
0712:  ADD     W0,W4,W0
0714:  MOV     W0,W4
0716:  MOV     [W4],W0
0718:  MOV     W0,W5
071A:  CLR     W6
071C:  BTSC    W5.F
071E:  SETM    W6
0720:  MOV     #1,W4
0722:  CLR.B   9
0724:  MOV     120A,W0
0726:  MOV     120C,W1
0728:  INC     W4,W4
072A:  DEC     W4,W4
072C:  BRA     Z,734
072E:  SL      W0,W0
0730:  RLC     W1,W1
0732:  BRA     72A
0734:  MOV     #122A,W4
0736:  ADD     W0,W4,W0
0738:  MOV     W0,W4
073A:  MOV     [W4],W0
073C:  CLR     W1
073E:  BTSC    W0.F
0740:  SETM    W1
0742:  MOV     W0,W2
0744:  MOV     W1,W3
0746:  MOV     W5,W0
0748:  MOV     W6,W1
074A:  CALL    368
074E:  ADD     96A
0750:  MOV     W1,W0
0752:  ADDC    96C,W0
0754:  MOV     W0,96C
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
0756:  MOV     120E,W4
0758:  XOR     #3F,W4
075A:  BRA     NZ,766
075C:  CP0     1210
075E:  BRA     NZ,766
....................       { 
....................          InputIndex = 0; 
0760:  CLR     120E
0762:  CLR     1210
....................       } 
0764:  BRA     76C
....................       else 
....................       { 
....................          InputIndex++; 
0766:  INC     120E
0768:  BTSC.B  42.1
076A:  INC     1210
....................       } 
....................        
....................       CoefficentIndex++; 
076C:  INC     120A
076E:  BTSC.B  42.1
0770:  INC     120C
0772:  BRA     6EC
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
0774:  MOV     #862,W4
0776:  MOV     12B4,W3
0778:  ADD     W3,W4,W5
077A:  MOV     #1,W4
077C:  CLR.B   9
077E:  MOV     1212,W0
0780:  MOV     1214,W1
0782:  INC     W4,W4
0784:  DEC     W4,W4
0786:  BRA     Z,78E
0788:  SL      W0,W0
078A:  RLC     W1,W1
078C:  BRA     784
078E:  MOV     #1176,W4
0790:  ADD     W0,W4,W0
0792:  MOV     [W0],W6
0794:  LSR     W6,#4,W0
0796:  MOV.B   W0L,[W5]
0798:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
079A:  MOV     1222,W4
079C:  LSR     W4,#8,W4
079E:  CP.B    W4L,#1
07A0:  BRA     NZ,7C2
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
07A2:  MOV     #2,W4
07A4:  CLR.B   9
07A6:  MOV     12B4,W0
07A8:  MOV     12B6,W1
07AA:  INC     W4,W4
07AC:  DEC     W4,W4
07AE:  BRA     Z,7B6
07B0:  SL      W0,W0
07B2:  RLC     W1,W1
07B4:  BRA     7AC
07B6:  MOV     #96E,W4
07B8:  ADD     W0,W4,W5
07BA:  MOV     #96A,W4
07BC:  MOV     [W4++],[W5++]
07BE:  MOV     [W4++],[W5++]
....................    } 
07C0:  BRA     83A
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
07C2:  MOV     96A,W0
07C4:  MOV     96C,W1
07C6:  CLR     W3
07C8:  BTSC    W1.F
07CA:  SETM    W3
07CC:  MOV     W3,W2
07CE:  MOV     116E,W4
07D0:  SUB     W0,W4,W0
07D2:  MOV     1170,W4
07D4:  SUBB    W1,W4,W1
07D6:  MOV     1172,W4
07D8:  SUBB    W2,W4,W2
07DA:  MOV     1174,W4
07DC:  SUBB    W3,W4,W3
07DE:  CALL    3AA
07E2:  MOV     W0,12B8
07E4:  MOV     W1,12BA
07E6:  MOV     12B8,W0
07E8:  MOV     12BA,W1
07EA:  MOV     1202,W2
07EC:  MOV     1204,W3
07EE:  CALL    40C
07F2:  MOV     W0,12BC
07F4:  MOV     W1,12BE
07F6:  BCLR.B  43.0
07F8:  MOV     12BC,W0
07FA:  MOV     12BE,W1
07FC:  MOV     #0,W2
07FE:  MOV     #42FE,W3
0800:  CALL    4D0
0804:  MOV     W0,12C0
0806:  MOV     W1,12C2
....................       ConversionValue = (unsigned int8)StepThree; 
0808:  MOV     12C0,W0
080A:  MOV     12C2,W1
080C:  CALL    67A
0810:  MOV.B   W0L,860
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
0812:  MOV     #2,W4
0814:  CLR.B   9
0816:  MOV     12B4,W0
0818:  MOV     12B6,W1
081A:  INC     W4,W4
081C:  DEC     W4,W4
081E:  BRA     Z,826
0820:  SL      W0,W0
0822:  RLC     W1,W1
0824:  BRA     81C
0826:  MOV     #96E,W4
0828:  ADD     W0,W4,W5
082A:  MOV     860,W0
082C:  MOV.B   W0L,[W5+#0]
082E:  MOV.B   #0,W0L
0830:  MOV.B   W0L,[W5+#1]
0832:  MOV.B   #0,W0L
0834:  MOV.B   W0L,[W5+#2]
0836:  MOV.B   #0,W0L
0838:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................    if (CurrentIndex == 0) 
083A:  CP0     1212
083C:  BRA     NZ,84A
083E:  CP0     1214
0840:  BRA     NZ,84A
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
0842:  MOV     #3F,W4
0844:  MOV     W4,1212
0846:  CLR     1214
....................    } 
0848:  BRA     850
....................    else 
....................    { 
....................      CurrentIndex--; 
084A:  DEC     1212
084C:  BTSS.B  42.0
084E:  DEC     1214
....................    }  
0850:  MOV     [--W15],W6
0852:  MOV     [--W15],W5
0854:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
0A66:  MOV     W5,[W15++]
0A68:  MOV     W6,[W15++]
0A6A:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0A6C:  MOV     121C,W4
0A6E:  CP      W4,#0
0A70:  BRA     GTU,C10
0A72:  BRA     NC,A7C
0A74:  MOV     121A,W4
0A76:  MOV     #BB8,W3
0A78:  CP      W3,W4
0A7A:  BRA     LEU,C10
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A7C:  PUSH    A6E
0A7E:  POP     1166
0A80:  PUSH    A70
0A82:  POP     1168
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A84:  PUSH    A6E
0A86:  POP     116A
0A88:  PUSH    A70
0A8A:  POP     116C
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0A8C:  PUSH    4080
0A8E:  POP     964
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A90:  MOV     #41,W4
0A92:  MOV     W4,12B4
0A94:  CLR     12B6
0A96:  MOV     12B6,W4
0A98:  CP      W4,#0
0A9A:  BRA     GTU,BC0
0A9C:  BRA     NC,AA6
0A9E:  MOV     12B4,W4
0AA0:  MOV     #FF,W3
0AA2:  CP      W3,W4
0AA4:  BRA     LEU,BC0
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0AA6:  MOV     #2,W4
0AA8:  CLR.B   9
0AAA:  MOV     12B4,W0
0AAC:  MOV     12B6,W1
0AAE:  INC     W4,W4
0AB0:  DEC     W4,W4
0AB2:  BRA     Z,ABA
0AB4:  SL      W0,W0
0AB6:  RLC     W1,W1
0AB8:  BRA     AB0
0ABA:  MOV     #96E,W4
0ABC:  ADD     W0,W4,W0
0ABE:  MOV     W0,W4
0AC0:  MOV     #0,W3
0AC2:  MOV     [W4++],[W3++]
0AC4:  MOV     [W4++],[W3++]
0AC6:  MOV     116C,W4
0AC8:  CP      W4,W1
0ACA:  BRA     LT,AF2
0ACC:  BRA     GT,AD4
0ACE:  MOV     116A,W4
0AD0:  CP      W4,W0
0AD2:  BRA     LEU,AF2
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0AD4:  MOV     #2,W4
0AD6:  CLR.B   9
0AD8:  MOV     12B4,W0
0ADA:  MOV     12B6,W1
0ADC:  INC     W4,W4
0ADE:  DEC     W4,W4
0AE0:  BRA     Z,AE8
0AE2:  SL      W0,W0
0AE4:  RLC     W1,W1
0AE6:  BRA     ADE
0AE8:  MOV     #96E,W4
0AEA:  ADD     W0,W4,W0
0AEC:  MOV     #116A,W4
0AEE:  MOV     [W0++],[W4++]
0AF0:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0AF2:  MOV     #2,W4
0AF4:  CLR.B   9
0AF6:  MOV     12B4,W0
0AF8:  MOV     12B6,W1
0AFA:  INC     W4,W4
0AFC:  DEC     W4,W4
0AFE:  BRA     Z,B06
0B00:  SL      W0,W0
0B02:  RLC     W1,W1
0B04:  BRA     AFC
0B06:  MOV     #96E,W4
0B08:  ADD     W0,W4,W0
0B0A:  MOV     W0,W4
0B0C:  MOV     #0,W3
0B0E:  MOV     [W4++],[W3++]
0B10:  MOV     [W4++],[W3++]
0B12:  MOV     1168,W4
0B14:  CP      W4,W1
0B16:  BRA     GT,B3E
0B18:  BRA     LT,B20
0B1A:  MOV     1166,W4
0B1C:  CP      W4,W0
0B1E:  BRA     C,B3E
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0B20:  MOV     #2,W4
0B22:  CLR.B   9
0B24:  MOV     12B4,W0
0B26:  MOV     12B6,W1
0B28:  INC     W4,W4
0B2A:  DEC     W4,W4
0B2C:  BRA     Z,B34
0B2E:  SL      W0,W0
0B30:  RLC     W1,W1
0B32:  BRA     B2A
0B34:  MOV     #96E,W4
0B36:  ADD     W0,W4,W0
0B38:  MOV     #1166,W4
0B3A:  MOV     [W0++],[W4++]
0B3C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0B3E:  MOV     #1,W4
0B40:  CLR.B   9
0B42:  MOV     12B4,W0
0B44:  MOV     12B6,W1
0B46:  INC     W4,W4
0B48:  DEC     W4,W4
0B4A:  BRA     Z,B52
0B4C:  SL      W0,W0
0B4E:  RLC     W1,W1
0B50:  BRA     B48
0B52:  MOV     #4000,W4
0B54:  ADD     W0,W4,W0
0B56:  MOV     W0,W4
0B58:  MOV     [W4],W0
0B5A:  MOV     964,W4
0B5C:  CP      W4,W0
0B5E:  BRA     LEU,B7C
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0B60:  MOV     #1,W4
0B62:  CLR.B   9
0B64:  MOV     12B4,W0
0B66:  MOV     12B6,W1
0B68:  INC     W4,W4
0B6A:  DEC     W4,W4
0B6C:  BRA     Z,B74
0B6E:  SL      W0,W0
0B70:  RLC     W1,W1
0B72:  BRA     B6A
0B74:  MOV     #4000,W4
0B76:  ADD     W0,W4,W0
0B78:  MOV     [W0],[W15++]
0B7A:  POP     964
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0B7C:  MOV     #2,W4
0B7E:  CLR.B   9
0B80:  MOV     12B4,W0
0B82:  MOV     12B6,W1
0B84:  INC     W4,W4
0B86:  DEC     W4,W4
0B88:  BRA     Z,B90
0B8A:  SL      W0,W0
0B8C:  RLC     W1,W1
0B8E:  BRA     B86
0B90:  MOV     #96E,W4
0B92:  ADD     W0,W4,W0
0B94:  MOV     W0,W4
0B96:  MOV     #0,W3
0B98:  MOV     [W4++],[W3++]
0B9A:  MOV     [W4++],[W3++]
0B9C:  CLR     W3
0B9E:  BTSC    W1.F
0BA0:  SETM    W3
0BA2:  MOV     W3,W2
0BA4:  ADD     116E
0BA6:  MOV     W1,W0
0BA8:  ADDC    1170,W0
0BAA:  MOV     W0,1170
0BAC:  MOV     1172,W4
0BAE:  ADDC    W2,W4,W0
0BB0:  MOV     W0,1172
0BB2:  MOV     1174,W4
0BB4:  ADDC    W3,W4,W0
0BB6:  MOV     W0,1174
0BB8:  INC     12B4
0BBA:  BTSC.B  42.1
0BBC:  INC     12B6
0BBE:  BRA     A96
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0BC0:  MOV     1166,W4
0BC2:  MOV     116A,W3
0BC4:  SUB     W4,W3,W0
0BC6:  MOV     1168,W4
0BC8:  MOV     116C,W3
0BCA:  SUBB    W4,W3,W1
0BCC:  CALL    856
0BD0:  MOV     W0,11FE
0BD2:  MOV     W1,1200
....................       AverageMultiplier = (255.0/ AverageDivider); 
0BD4:  MOV     #0,W0
0BD6:  MOV     #437F,W1
0BD8:  MOV     11FE,W2
0BDA:  MOV     1200,W3
0BDC:  CALL    8A4
0BE0:  MOV     W0,1202
0BE2:  MOV     W1,1204
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0BE4:  BCLR.B  43.0
0BE6:  MOV     116E,W0
0BE8:  MOV     1170,W1
0BEA:  MOV     1172,W2
0BEC:  MOV     1174,W3
0BEE:  MOV     #BF,W4
0BF0:  MOV     #0,W5
0BF2:  MOV     #0,W6
0BF4:  MOV     #0,W7
0BF6:  CALL    96E
0BFA:  MOV     W0,116E
0BFC:  MOV     W1,1170
0BFE:  MOV     W2,1172
0C00:  MOV     W3,1174
....................        
....................       TriggerValue = InitialTriggerValue; 
0C02:  PUSH    964
0C04:  POP     966
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0C06:  MOV     #96E,W1
0C08:  MOV     #0,W2
0C0A:  REPEAT  #1FD
0C0C:  CLR.B   [W1++]
....................    }   
0C0E:  BRA     C78
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0C10:  PUSH    4080
0C12:  POP     964
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0C14:  MOV     #41,W4
0C16:  MOV     W4,12B8
0C18:  CLR     12BA
0C1A:  MOV     12BA,W4
0C1C:  CP      W4,#0
0C1E:  BRA     GTU,C70
0C20:  BRA     NC,C2A
0C22:  MOV     12B8,W4
0C24:  MOV     #FF,W3
0C26:  CP      W3,W4
0C28:  BRA     LEU,C70
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0C2A:  MOV     #1,W4
0C2C:  CLR.B   9
0C2E:  MOV     12B8,W0
0C30:  MOV     12BA,W1
0C32:  INC     W4,W4
0C34:  DEC     W4,W4
0C36:  BRA     Z,C3E
0C38:  SL      W0,W0
0C3A:  RLC     W1,W1
0C3C:  BRA     C34
0C3E:  MOV     #4000,W4
0C40:  ADD     W0,W4,W0
0C42:  MOV     W0,W4
0C44:  MOV     [W4],W0
0C46:  MOV     964,W4
0C48:  CP      W4,W0
0C4A:  BRA     LEU,C68
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0C4C:  MOV     #1,W4
0C4E:  CLR.B   9
0C50:  MOV     12B8,W0
0C52:  MOV     12BA,W1
0C54:  INC     W4,W4
0C56:  DEC     W4,W4
0C58:  BRA     Z,C60
0C5A:  SL      W0,W0
0C5C:  RLC     W1,W1
0C5E:  BRA     C56
0C60:  MOV     #4000,W4
0C62:  ADD     W0,W4,W0
0C64:  MOV     [W0],[W15++]
0C66:  POP     964
....................         }              
0C68:  INC     12B8
0C6A:  BTSC.B  42.1
0C6C:  INC     12BA
0C6E:  BRA     C1A
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0C70:  PUSH    964
0C72:  POP     966
....................       ErrorCounter = 0;  
0C74:  CLR     121A
0C76:  CLR     121C
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0C78:  CLR     121E
0C7A:  CLR     1220
....................    NormalizeFlag = 0; 
0C7C:  CLR.B   1223
....................    CurrentIndex = 0; 
0C7E:  CLR     1212
0C80:  CLR     1214
0C82:  MOV     [--W15],W7
0C84:  MOV     [--W15],W6
0C86:  MOV     [--W15],W5
0C88:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
.................... { 
....................     InputSamples[CurrentIndex] = ADCValue; 
....................     InputIndex = CurrentIndex; 
....................     CoefficentIndex = 0; 
....................     Accumulator = 0; 
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
....................          { 
....................             InputIndex = 0; 
....................          } 
....................          else 
....................          { 
....................             InputIndex++; 
....................          } 
....................          CoefficentIndex++; 
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
....................      
....................     if (CurrentIndex == 0) 
....................     { 
....................       CurrentIndex = COEF_LENGTH - 1; 
....................     } 
....................     else 
....................     { 
....................       CurrentIndex--; 
....................     }  
....................        
....................     return ConversionValue;   
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0C98:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0C9A:  MOV.B   12B4,W0L
0C9C:  CLR.B   1
0C9E:  XOR     #2B,W0
0CA0:  BRA     Z,CC0
0CA2:  XOR     #1,W0
0CA4:  BRA     Z,CC6
0CA6:  XOR     #6E,W0
0CA8:  BRA     Z,CCA
0CAA:  XOR     #8,W0
0CAC:  BRA     Z,CDC
0CAE:  XOR     #68,W0
0CB0:  BRA     Z,DA6
0CB2:  XOR     #1,W0
0CB4:  BRA     Z,E06
0CB6:  XOR     #6,W0
0CB8:  BRA     Z,E62
0CBA:  XOR     #63,W0
0CBC:  BRA     Z,E86
0CBE:  BRA     F4A
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0CC0:  MOV.B   #1,W0L
0CC2:  MOV.B   W0L,1225
....................          break; 
0CC4:  BRA     F4A
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0CC6:  BCLR.B  94.3
....................          break; 
0CC8:  BRA     F4A
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0CCA:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0CCC:  CLR     104
0CCE:  PUSH    85E
0CD0:  POP     102
0CD2:  MOV     #8000,W4
0CD4:  MOV     W4,104
....................          HandshakeFlag = 1;   
0CD6:  MOV.B   #1,W0L
0CD8:  MOV.B   W0L,1225
....................          break;  
0CDA:  BRA     F4A
....................                       
....................       case 'L': 
....................          DisableInterrupts(); 
0CDC:  CALL    C8A
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0CE0:  MOV     #122A,W1
0CE2:  MOV     #0,W2
0CE4:  REPEAT  #7F
0CE6:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0CE8:  MOV     1206,W4
0CEA:  XOR     #40,W4
0CEC:  BRA     NZ,CF2
0CEE:  CP0     1208
0CF0:  BRA     Z,D6E
....................          { 
....................             if (kbhit(SHARP)) 
0CF2:  BTSS.B  232.0
0CF4:  BRA     D6C
0CF6:  PUSH    42
0CF8:  BCLR.B  81.7
0CFA:  SETM.B  42
0CFC:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0CFE:  CALL    24E
0D02:  BCLR.B  81.7
0D04:  POP     42
0D06:  BSET.B  81.7
0D08:  MOV.B   W0L,12B5
....................                 
....................                if ((CoefficentByte == 'L') && (CSharpCoefficentRecieved == 0)) 
0D0A:  MOV     12B4,W4
0D0C:  LSR     W4,#8,W4
0D0E:  XOR.B   #4C,W4L
0D10:  BRA     NZ,D1C
0D12:  CP0     1206
0D14:  BRA     NZ,D1C
0D16:  CP0     1208
0D18:  BRA     NZ,D1C
....................                { 
....................                   ; // Do nothing 
....................                }               
0D1A:  BRA     D6C
....................                else if (NumberCSharpByteRecieved == 0) 
0D1C:  CP0     1216
0D1E:  BRA     NZ,D30
0D20:  CP0     1218
0D22:  BRA     NZ,D30
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0D24:  MOV.B   12B5,W0L
0D26:  MOV.B   W0L,962
....................                   NumberCSharpByteRecieved = 1; 
0D28:  MOV     #1,W4
0D2A:  MOV     W4,1216
0D2C:  CLR     1218
....................                }            
0D2E:  BRA     D6C
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0D30:  MOV.B   12B5,W0L
0D32:  MOV.B   W0L,963
....................                   NumberCSharpByteRecieved = 0; 
0D34:  CLR     1216
0D36:  CLR     1218
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0D38:  MOV.B   963,W0L
0D3A:  MOV.B   W0L,W5L
0D3C:  CLR.B   B
0D3E:  MOV.B   W5L,W0L
0D40:  MOV.B   W0L,B
0D42:  CLR.B   W5
0D44:  MOV     W5,W0
0D46:  IOR     962,W0
0D48:  MOV     W0,968
....................                   fir_coef[CSharpCoefficentRecieved] = ByteConversionResult; 
0D4A:  MOV     #1,W4
0D4C:  CLR.B   9
0D4E:  MOV     1206,W0
0D50:  MOV     1208,W1
0D52:  INC     W4,W4
0D54:  DEC     W4,W4
0D56:  BRA     Z,D5E
0D58:  SL      W0,W0
0D5A:  RLC     W1,W1
0D5C:  BRA     D54
0D5E:  MOV     #122A,W4
0D60:  ADD     W0,W4,W5
0D62:  MOV     968,W4
0D64:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0D66:  INC     1206
0D68:  BTSC.B  42.1
0D6A:  INC     1208
....................                } 
....................             } 
0D6C:  BRA     CE8
....................          } 
....................           
....................          switch (fir_coef[0]) 
0D6E:  MOV     122A,W0
0D70:  XOR     #D2,W0
0D72:  BRA     Z,D7E
0D74:  XOR     #FA,W0
0D76:  BRA     Z,D84
0D78:  XOR     #149,W0
0D7A:  BRA     Z,D8A
0D7C:  BRA     D90
....................          { 
....................          case 210: //Todo:: Fall Through  
....................             TimerTicks = 53334; 
0D7E:  MOV     #D056,W4
0D80:  MOV     W4,85E
....................             break; 
0D82:  BRA     D94
....................          case 40: 
....................             TimerTicks = 53334; 
0D84:  MOV     #D056,W4
0D86:  MOV     W4,85E
....................             break; 
0D88:  BRA     D94
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0D8A:  MOV     #1F40,W4
0D8C:  MOV     W4,85E
....................             break; 
0D8E:  BRA     D94
....................          default:  
....................             TimerTicks = 8000; 
0D90:  MOV     #1F40,W4
0D92:  MOV     W4,85E
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0D94:  CLR     1206
0D96:  CLR     1208
....................          NormalizeFlag = 1; 
0D98:  MOV.B   #1,W0L
0D9A:  MOV.B   W0L,1223
....................          HandshakeFlag = 1; 
0D9C:  MOV.B   #1,W0L
0D9E:  MOV.B   W0L,1225
....................          EnableInterrupts(); 
0DA0:  CALL    35C
....................          break; 
0DA4:  BRA     F4A
....................          
....................       case '$': 
....................          DisableInterrupts(); 
0DA6:  CALL    C8A
....................          TriggerValue = 0; // reset trigger value 
0DAA:  CLR     966
....................           
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0DAC:  BTSS.B  232.0
0DAE:  BRA     DF0
0DB0:  PUSH    42
0DB2:  BCLR.B  81.7
0DB4:  SETM.B  42
0DB6:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0DB8:  CALL    24E
0DBC:  BCLR.B  81.7
0DBE:  POP     42
0DC0:  BSET.B  81.7
0DC2:  MOV.B   W0L,12B6
....................                 
....................                if (isdigit(DigitByte)) 
0DC4:  MOV     12B6,W4
0DC6:  MOV     #30,W3
0DC8:  CP.B    W3L,W4L
0DCA:  BRA     GTU,DE6
0DCC:  MOV     12B6,W4
0DCE:  MOV     #39,W3
0DD0:  CP.B    W3L,W4L
0DD2:  BRA     NC,DE6
....................                { 
....................                   TriggerValue = TriggerValue * 10 + CharToInt(DigitByte); 
0DD4:  MOV     966,W4
0DD6:  MUL.UU  W4,#A,W0
0DD8:  MOV     W0,W5
0DDA:  MOV.B   12B6,W0L
0DDC:  SE      W0,W0
0DDE:  SUB     #30,W0
0DE0:  ADD     W0,W5,W0
0DE2:  MOV     W0,966
....................                } 
0DE4:  BRA     DF0
....................                else if (DigitByte == ')') 
0DE6:  MOV     12B6,W4
0DE8:  XOR.B   #29,W4L
0DEA:  BRA     NZ,DF0
....................                { 
....................                   break; 
0DEC:  BRA     DF2
....................                } 
0DEE:  BRA     DF0
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0DF0:  BRA     DAC
....................          } 
....................           
....................          TriggerValueFlag = 1; 
0DF2:  MOV.B   #1,W0L
0DF4:  MOV.B   W0L,1228
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0DF6:  CLR     104
0DF8:  PUSH    85E
0DFA:  POP     102
0DFC:  MOV     #8000,W4
0DFE:  MOV     W4,104
....................          EnableInterrupts(); 
0E00:  CALL    35C
....................          break;  
0E04:  BRA     F4A
....................           
....................       case '%': 
....................          DisableInterrupts();   
0E06:  CALL    C8A
....................          TimerTicks = 0; // reset trigger value 
0E0A:  CLR     85E
....................              
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0E0C:  BTSS.B  232.0
0E0E:  BRA     E56
0E10:  PUSH    42
0E12:  BCLR.B  81.7
0E14:  SETM.B  42
0E16:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0E18:  CALL    24E
0E1C:  BCLR.B  81.7
0E1E:  POP     42
0E20:  BSET.B  81.7
0E22:  MOV.B   W0L,12B7
....................                 
....................                if (isdigit(DigitByte)) 
0E24:  MOV     12B6,W4
0E26:  LSR     W4,#8,W4
0E28:  MOV     #30,W3
0E2A:  CP.B    W3L,W4L
0E2C:  BRA     GTU,E4A
0E2E:  MOV     12B6,W4
0E30:  LSR     W4,#8,W4
0E32:  MOV     #39,W3
0E34:  CP.B    W3L,W4L
0E36:  BRA     NC,E4A
....................                { 
....................                   TimerTicks = TimerTicks * 10 + CharToInt(DigitByte); 
0E38:  MOV     85E,W4
0E3A:  MUL.UU  W4,#A,W0
0E3C:  MOV     W0,W5
0E3E:  MOV.B   12B7,W0L
0E40:  SE      W0,W0
0E42:  SUB     #30,W0
0E44:  ADD     W0,W5,W0
0E46:  MOV     W0,85E
....................                } 
0E48:  BRA     E56
....................                else if (DigitByte == ')') 
0E4A:  MOV     12B6,W4
0E4C:  LSR     W4,#8,W4
0E4E:  XOR.B   #29,W4L
0E50:  BRA     NZ,E56
....................                { 
....................                   break; 
0E52:  BRA     E58
....................                } 
0E54:  BRA     E56
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0E56:  BRA     E0C
....................          } 
....................           
....................          HandshakeFlag = 1; 
0E58:  MOV.B   #1,W0L
0E5A:  MOV.B   W0L,1225
....................          EnableInterrupts(); 
0E5C:  CALL    35C
....................          break; 
0E60:  BRA     F4A
....................             
....................       case '#': 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0E62:  MOV     #4000,W1
0E64:  MOV     #0,W2
0E66:  REPEAT  #1FD
0E68:  CLR.B   [W1++]
....................          dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E6A:  BCLR.B  381.7
0E6C:  CLR.B   380
0E6E:  MOV     #4000,W4
0E70:  MOV     W4,384
0E72:  MOV     #FF,W4
0E74:  MOV     W4,38A
0E76:  BSET.B  381.7
....................          enable_interrupts(INT_DMA0); 
0E78:  BSET.B  94.4
....................          DMAFlag = 0; 
0E7A:  CLR.B   1227
....................          TriggerFlag = 0; 
0E7C:  CLR.B   1226
....................          TriggerValueFlag = 0; 
0E7E:  CLR.B   1228
....................          HandshakeFlag = 1; 
0E80:  MOV.B   #1,W0L
0E82:  MOV.B   W0L,1225
....................          break; 
0E84:  BRA     F4A
....................           
....................       case '@': 
....................          DisableInterrupts(); 
0E86:  CALL    C8A
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0E8A:  MOV     #4000,W1
0E8C:  MOV     #0,W2
0E8E:  REPEAT  #1FD
0E90:  CLR.B   [W1++]
....................          dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E92:  BCLR.B  381.7
0E94:  CLR.B   380
0E96:  MOV     #4000,W4
0E98:  MOV     W4,384
0E9A:  MOV     #FF,W4
0E9C:  MOV     W4,38A
0E9E:  BSET.B  381.7
....................          enable_interrupts(INT_DMA0); 
0EA0:  BSET.B  94.4
....................          enable_interrupts(GLOBAL); 
0EA2:  BCLR.B  81.7
0EA4:  CLR     42
0EA6:  BSET.B  81.7
....................          HandshakeFlag = 1; 
0EA8:  MOV.B   #1,W0L
0EAA:  MOV.B   W0L,1225
....................          unsigned int8 TXData; 
....................          while(TRUE) 
....................          { 
....................             output_toggle(LED_PIN); 
0EAC:  BCLR.B  2C9.6
0EAE:  BTG.B   2CD.6
....................             read_adc(); 
0EB0:  BCLR.B  320.0
0EB2:  BSET.B  320.1
0EB4:  BTSS.B  320.0
0EB6:  BRA     EB4
....................              
....................             if((DMADoneFlag == 1) && (HandshakeFlag == 1)) 
0EB8:  MOV     1222,W4
0EBA:  CP.B    W4L,#1
0EBC:  BRA     NZ,F0E
0EBE:  MOV     1224,W4
0EC0:  LSR     W4,#8,W4
0EC2:  CP.B    W4L,#1
0EC4:  BRA     NZ,F0E
....................             { 
....................                for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0EC6:  CLR     12BA
0EC8:  CLR     12BC
0ECA:  MOV     12BC,W4
0ECC:  CP      W4,#0
0ECE:  BRA     GTU,F0A
0ED0:  BRA     NC,EDA
0ED2:  MOV     12BA,W4
0ED4:  MOV     #FF,W3
0ED6:  CP      W3,W4
0ED8:  BRA     LEU,F0A
....................                { 
....................                    TXData = DMA_ADC_BUFFER[i] >> 4; 
0EDA:  MOV     #1,W4
0EDC:  CLR.B   9
0EDE:  MOV     12BA,W0
0EE0:  MOV     12BC,W1
0EE2:  INC     W4,W4
0EE4:  DEC     W4,W4
0EE6:  BRA     Z,EEE
0EE8:  SL      W0,W0
0EEA:  RLC     W1,W1
0EEC:  BRA     EE4
0EEE:  MOV     #4000,W4
0EF0:  ADD     W0,W4,W0
0EF2:  MOV     [W0],W5
0EF4:  LSR     W5,#4,W0
0EF6:  MOV.B   W0L,12B8
0EF8:  MOV.B   W0L,12B8
....................                    printf("%c", TXData); // send every emelent of the array as a byte 
0EFA:  BTSC.B  233.1
0EFC:  BRA     EFA
0EFE:  MOV.B   12B8,W0L
0F00:  MOV.B   W0L,234
0F02:  INC     12BA
0F04:  BTSC.B  42.1
0F06:  INC     12BC
0F08:  BRA     ECA
....................                } 
....................                DMADoneFlag = 0; 
0F0A:  CLR.B   1222
....................                HandshakeFlag = 0; 
0F0C:  CLR.B   1225
....................             } 
....................              
....................             if (kbhit(SHARP)) 
0F0E:  BTSS.B  232.0
0F10:  BRA     F46
0F12:  PUSH    42
0F14:  BCLR.B  81.7
0F16:  SETM.B  42
0F18:  BSET.B  81.7
....................             { 
....................                char RXData = fgetc(SHARP); 
0F1A:  CALL    24E
0F1E:  BCLR.B  81.7
0F20:  POP     42
0F22:  BSET.B  81.7
0F24:  MOV.B   W0L,12B9
....................                 
....................                if (RXData == '+') 
0F26:  MOV     12B8,W4
0F28:  LSR     W4,#8,W4
0F2A:  XOR.B   #2B,W4L
0F2C:  BRA     NZ,F34
....................                { 
....................                   HandshakeFlag = 1; 
0F2E:  MOV.B   #1,W0L
0F30:  MOV.B   W0L,1225
....................                } 
0F32:  BRA     F42
....................                else if (RXData = '*') 
0F34:  MOV.B   #2A,W0L
0F36:  MOV.B   W0L,12B9
0F38:  CP0.B   12B9
0F3A:  BRA     Z,F42
....................                { 
....................                   EnableInterrupts(); 
0F3C:  CALL    35C
....................                   break; 
0F40:  BRA     F48
....................                } 
....................                 
....................                RXData = '\n';  
0F42:  MOV.B   #A,W0L
0F44:  MOV.B   W0L,12B9
....................             } 
0F46:  BRA     EAC
....................          } 
....................          break; 
0F48:  BRA     F4A
....................    
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0F4A:  CLR.B   12B4
....................    UARTRXFlag = 0; 
0F4C:  CLR.B   1224
0F4E:  MOV     [--W15],W5
0F50:  RETURN  
.................... } 
....................  
.................... void DisableInterrupts(void) 
.................... { 
....................    disable_interrupts(INT_TIMER1); // disable timer 
*
0C8A:  BCLR.B  94.3
....................    disable_interrupts(INT_RDA2); 
0C8C:  BCLR.B  97.6
....................    disable_interrupts(GLOBAL);  
0C8E:  BCLR.B  81.7
0C90:  MOV     #E0,W4
0C92:  MOV     W4,42
0C94:  BSET.B  81.7
0C96:  RETURN  
.................... } 
....................  
.................... void EnableInterrupts(void) 
.................... { 
....................    enable_interrupts(INT_RDA2); 
*
035C:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
035E:  BSET.B  94.3
....................    enable_interrupts(GLOBAL); 
0360:  BCLR.B  81.7
0362:  CLR     42
0364:  BSET.B  81.7
0366:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
