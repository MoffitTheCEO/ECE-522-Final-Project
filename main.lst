CCS PCD C Compiler, Version 5.008, 5967               15-Nov-22 20:35

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4032 bytes (9%)
                           Largest free fragment is 40000
               RAM used:   3542 (22%) at main() level
                           3580 (22%) worst case
               Stack used: 68 locations (52 in main + 16 for interrupts)
               Stack size: 30

*
0000:  GOTO    DCA
*
001A:  DATA    90,02,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    66,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
02C8:  MOV     W5,[W15++]
02CA:  MOV     #C,W5
02CC:  REPEAT  #3
02CE:  MOV     [W5++],[W15++]
02D0:  MUL.UU  W0,W2,W4
02D2:  BTSS    W3.F
02D4:  BRA     2DA
02D6:  MUL.SS  W0,W3,W6
02D8:  BRA     2DC
02DA:  MUL.UU  W0,W3,W6
02DC:  BCLR.B  42.0
02DE:  ADD     W6,W5,W5
02E0:  ADDC    W7,#0,W8
02E2:  BTSS    W1.F
02E4:  BRA     2EA
02E6:  MUL.SS  W1,W2,W6
02E8:  BRA     2EC
02EA:  MUL.UU  W1,W2,W6
02EC:  ADDC    W6,W5,W5
02EE:  ADDC    W7,W8,W8
02F0:  ADDC    #0,W9
02F2:  MUL.SS  W1,W3,W6
02F4:  ADDC    W6,W8,W8
02F6:  ADDC    W9,W7,W7
02F8:  MOV     W7,W3
02FA:  MOV     W8,W2
02FC:  MOV     W5,W1
02FE:  MOV     W4,W0
0300:  MOV     #12,W5
0302:  REPEAT  #3
0304:  MOV     [--W15],[W5--]
0306:  MOV     [--W15],W5
0308:  RETURN  
030A:  MOV     W5,[W15++]
030C:  MOV     #C,W5
030E:  REPEAT  #3
0310:  MOV     [W5++],[W15++]
0312:  MOV     W0,W4
0314:  MOV     W1,W5
0316:  MOV     W2,W6
0318:  MOV     W3,W7
031A:  CLR     W0
031C:  CLR     W1
031E:  CLR     W2
0320:  CLR     W3
0322:  BCLR    W8.0
0324:  BTSS    W7.F
0326:  BRA     332
0328:  BSET    W6.0
032A:  NEG     W4,W4
032C:  COM     W5,W5
032E:  COM     W6,W6
0330:  COM     W7,W7
0332:  XOR     W4,W5,W9
0334:  BRA     NZ,33A
0336:  XOR     W6,W7,W9
0338:  BRA     Z,362
033A:  MOV     #D6,W1
033C:  BTSC    W2.7
033E:  BRA     352
0340:  BCLR.B  42.0
0342:  RLC     W4,W4
0344:  RLC     W5,W5
0346:  RLC     W6,W6
0348:  RLC     W7,W7
034A:  RLC     W0,W0
034C:  RLC     W2,W2
034E:  DEC     W1,W1
0350:  BRA     NZ,33C
0352:  SWAP    W1
0354:  BCLR.B  42.0
0356:  RRC     W1,W1
0358:  BCLR    W1.F
035A:  BCLR    W2.7
035C:  XOR.B   W2L,W1L,W1L
035E:  BTSC    W6.0
0360:  BSET    W1.F
0362:  MOV     #12,W5
0364:  REPEAT  #3
0366:  MOV     [--W15],[W5--]
0368:  MOV     [--W15],W5
036A:  RETURN  
036C:  MOV     W5,[W15++]
036E:  MOV     #C,W5
0370:  REPEAT  #4
0372:  MOV     [W5++],[W15++]
0374:  MOV     W0,W4
0376:  MOV     W1,W5
0378:  MOV     W3,W7
037A:  MOV     W2,W6
037C:  BCLR.B  42.0
037E:  BCLR.B  42.1
0380:  RLC     W1,W1
0382:  SWAP    W1
0384:  AND     #FF,W1
0386:  CP0     W1
0388:  BRA     Z,420
038A:  BCLR.B  42.0
038C:  BCLR.B  42.1
038E:  RLC     W3,W3
0390:  SWAP    W3
0392:  AND     #FF,W3
0394:  CP0     W3
0396:  BRA     Z,420
0398:  ZE      W0,W0
039A:  ADD.B   W3L,W1L,W0L
039C:  BRA     C,3A6
039E:  SUB     #7F,W0
03A0:  BRA     Z,420
03A2:  BRA     NC,420
03A4:  BRA     3AA
03A6:  ADD.B   #81,W0L
03A8:  BRA     C,420
03AA:  XOR     W5,W7,W10
03AC:  BCLR.B  42.0
03AE:  BCLR.B  42.1
03B0:  AND     #FF,W5
03B2:  BSET    W5.7
03B4:  BCLR.B  42.0
03B6:  AND     #FF,W7
03B8:  BSET    W7.7
03BA:  MUL.UU  W4,W6,W2
03BC:  MUL.UU  W5,W6,W8
03BE:  ADDC    W8,W3,W3
03C0:  MOV     W9,W1
03C2:  BTSC.B  42.0
03C4:  INC     W1,W1
03C6:  BCLR.B  42.0
03C8:  MUL.UU  W7,W4,W8
03CA:  ADDC    W8,W3,W3
03CC:  ADDC    W9,W1,W1
03CE:  MUL.UU  W5,W7,W8
03D0:  ADDC    W8,W1,W1
03D2:  INC     W0,W0
03D4:  CP0     W1
03D6:  BTSC.B  42.1
03D8:  BRA     3DC
03DA:  BRA     3E2
03DC:  CP0     W3
03DE:  BTSC.B  42.1
03E0:  BRA     3EC
03E2:  BTSC    W1.F
03E4:  BRA     3EC
03E6:  RLC     W3,W3
03E8:  RLC     W1,W1
03EA:  DEC     W0,W0
03EC:  MOV     W1,W2
03EE:  BCLR.B  42.0
03F0:  BTSS    W3.7
03F2:  BRA     406
03F4:  MOV     #FF00,W7
03F6:  AND     W3,W7,W3
03F8:  ADD     #100,W3
03FA:  ADDC    W2,#0,W2
03FC:  CP0     W2
03FE:  BRA     NZ,406
0400:  CP0     W3
0402:  BRA     NZ,406
0404:  INC     W0,W0
0406:  SWAP    W0
0408:  BCLR.B  42.0
040A:  BCLR.B  42.1
040C:  RRC     W0,W1
040E:  BTSC    W10.F
0410:  BSET    W1.F
0412:  BCLR    W2.F
0414:  SWAP    W2
0416:  XOR.B   W2L,W1L,W1L
0418:  SWAP    W3
041A:  MOV.B   W3L,W2L
041C:  MOV     W2,W0
041E:  BRA     426
0420:  MOV     #0,W0
0422:  MOV     #0,W1
0424:  BRA     426
0426:  MOV     #14,W5
0428:  REPEAT  #4
042A:  MOV     [--W15],[W5--]
042C:  MOV     [--W15],W5
042E:  RETURN  
0430:  MOV     W5,[W15++]
0432:  MOV     #C,W5
0434:  REPEAT  #3
0436:  MOV     [W5++],[W15++]
0438:  CLR     W9
043A:  MOV     #8000,W8
043C:  BTSC.B  43.0
043E:  XOR     W8,W3,W3
0440:  CP0     W0
0442:  BRA     NZ,44A
0444:  MOV     #7FFF,W10
0446:  AND     W1,W10,W10
0448:  BTSS.B  42.1
044A:  MOV     W1,W10
044C:  XOR     W3,W10,W11
044E:  MOV     W1,W6
0450:  MOV     W3,W7
0452:  MOV     W3,W12
0454:  BCLR.B  42.1
0456:  BCLR.B  42.0
0458:  RLC     W6,W6
045A:  SWAP    W6
045C:  AND     #FF,W6
045E:  CP0     W6
0460:  BRA     Z,5A4
0462:  BCLR.B  42.1
0464:  BCLR.B  42.0
0466:  RLC     W7,W7
0468:  SWAP    W7
046A:  AND     #FF,W7
046C:  CP0     W7
046E:  BRA     Z,5AE
0470:  BCLR.B  42.1
0472:  BCLR.B  42.0
0474:  CP      W7,W6
0476:  BRA     Z,5B0
0478:  BRA     N,5C0
047A:  BCLR    W9.0
047C:  BSET    W9.1
047E:  SUB     W7,W6,W8
0480:  MOV     W7,W6
0482:  AND     #FF,W1
0484:  BSET    W1.7
0486:  AND     #FF,W3
0488:  BSET    W3.7
048A:  MOV     #28,W7
048C:  CP      W7,W8
048E:  BRA     N,4B2
0490:  BCLR.B  42.1
0492:  BCLR.B  42.0
0494:  RRC     W1,W1
0496:  RRC     W0,W0
0498:  DEC     W8,W8
049A:  BRA     NZ,490
049C:  BRA     4B8
049E:  MOV     #28,W7
04A0:  CP      W7,W8
04A2:  BRA     N,4B6
04A4:  BCLR.B  42.1
04A6:  BCLR.B  42.0
04A8:  RRC     W3,W3
04AA:  RRC     W2,W2
04AC:  DEC     W8,W8
04AE:  BRA     NZ,4A4
04B0:  BRA     4D0
04B2:  MOV     W2,W0
04B4:  MOV     W3,W1
04B6:  BRA     53E
04B8:  BTSS    W11.F
04BA:  BRA     4DE
04BC:  BTSC    W9.4
04BE:  MOV     W12,W11
04C0:  NEG     W0,W0
04C2:  BRA     Z,4C8
04C4:  COM.B   W1L,W1L
04C6:  BRA     4CA
04C8:  NEG     W1,W1
04CA:  BTSC    W9.4
04CC:  BRA     524
04CE:  BRA     4DE
04D0:  BTSS    W11.F
04D2:  BRA     4DE
04D4:  NEG     W2,W2
04D6:  BRA     Z,4DC
04D8:  COM.B   W3L,W3L
04DA:  BRA     4DE
04DC:  NEG     W3,W3
04DE:  AND     #FF,W5
04E0:  BCLR.B  42.1
04E2:  BCLR.B  42.0
04E4:  ADD     W0,W2,W0
04E6:  ADDC.B  W1L,W3L,W1L
04E8:  BTSC.B  42.0
04EA:  BSET    W9.3
04EC:  BTSC    W9.0
04EE:  BRA     502
04F0:  BTSC    W9.1
04F2:  BRA     4F6
04F4:  BRA     50C
04F6:  BTSC    W11.F
04F8:  BRA     524
04FA:  BTSC    W9.3
04FC:  BRA     550
04FE:  BSET    W9.6
0500:  BRA     53E
0502:  BTSC    W11.F
0504:  BRA     524
0506:  BTSC    W9.3
0508:  BRA     550
050A:  BRA     53E
050C:  BCLR    W9.2
050E:  BTSC    W11.F
0510:  BRA     51A
0512:  MOV     W10,W11
0514:  BTSC    W9.3
0516:  BRA     550
0518:  BRA     586
051A:  BSET    W9.4
051C:  XOR.B   #80,W1L
051E:  BTSC    W1.7
0520:  BRA     4BC
0522:  MOV     W10,W11
0524:  AND     #FF,W1
0526:  IOR      W0,  W1,W7
0528:  BRA     Z,53E
052A:  BTSC    W1.7
052C:  BRA     53E
052E:  BCLR.B  42.1
0530:  BCLR.B  42.0
0532:  RLC     W0,W0
0534:  RLC     W1,W1
0536:  DEC     W6,W6
0538:  BTSC.B  42.1
053A:  BRA     59E
053C:  BRA     52A
053E:  BTSC    W9.0
0540:  MOV     W10,W11
0542:  BTSC    W9.1
0544:  MOV     W12,W11
0546:  BTSS    W9.5
0548:  BRA     57E
054A:  BTSC    W10.F
054C:  BSET    W0.8
054E:  BRA     586
0550:  BSET.B  42.0
0552:  RRC.B   W1L,W1L
0554:  RRC     W0,W0
0556:  BTSC.B  42.0
0558:  BSET    W9.5
055A:  INC     W6,W6
055C:  BRA     Z,59E
055E:  BTSS    W9.5
0560:  BRA     572
0562:  INC     W0,W0
0564:  BRA     NZ,572
0566:  INC.B   W1L,W1L
0568:  BRA     NZ,572
056A:  RRC.B   W1L,W1L
056C:  RRC     W0,W0
056E:  INC     W6,W6
0570:  BRA     Z,59E
0572:  BTSC    W9.0
0574:  MOV     W10,W11
0576:  BTSC    W9.1
0578:  MOV     W12,W11
057A:  BTSC.B  42.1
057C:  BRA     59E
057E:  BTSC    W9.6
0580:  MOV     W10,W11
0582:  BTSC    W9.7
0584:  MOV     W12,W11
0586:  IOR      W0,  W1,W2
0588:  BRA     Z,5D0
058A:  BCLR    W1.7
058C:  SWAP    W6
058E:  BCLR.B  42.1
0590:  BCLR.B  42.0
0592:  RRC     W6,W6
0594:  XOR     W6,W1,W1
0596:  BSET    W1.F
0598:  BTSS    W11.F
059A:  BCLR    W1.F
059C:  BRA     5D0
059E:  MOV     #0,W0
05A0:  MOV     #0,W1
05A2:  BRA     5D0
05A4:  BTSC    W10.F
05A6:  XOR     W8,W3,W3
05A8:  MOV     W2,W0
05AA:  MOV     W3,W1
05AC:  BRA     5D0
05AE:  BRA     5D0
05B0:  AND     #FF,W3
05B2:  BSET    W3.7
05B4:  AND     #FF,W1
05B6:  BSET    W1.7
05B8:  BTSC    W11.F
05BA:  BCLR    W3.7
05BC:  BSET    W9.2
05BE:  BRA     4D0
05C0:  SUB     W6,W7,W8
05C2:  AND     #FF,W1
05C4:  BSET    W1.7
05C6:  AND     #FF,W3
05C8:  BSET    W3.7
05CA:  BCLR    W9.1
05CC:  BSET    W9.0
05CE:  BRA     49E
05D0:  MOV     #12,W5
05D2:  REPEAT  #3
05D4:  MOV     [--W15],[W5--]
05D6:  MOV     [--W15],W5
05D8:  RETURN  
05DA:  MOV     W0,W2
05DC:  MOV     W1,W3
05DE:  MOV.B   W1L,W0L
05E0:  SWAP    W0
05E2:  BSET    W0.F
05E4:  RLC     W1,W1
05E6:  SWAP    W1
05E8:  ZE      W1,W1
05EA:  MOV     #8E,W4
05EC:  SUB.B   W4L,W1L,W1L
05EE:  BRA     Z,5FC
05F0:  CP0     W0
05F2:  BRA     Z,5FC
05F4:  BCLR.B  42.0
05F6:  RRC     W0,W0
05F8:  DEC     W1,W1
05FA:  BRA     NZ,5F0
05FC:  BTSS    W3.F
05FE:  BRA     604
0600:  NEG     W0,W0
0602:  BRA     604
0604:  RETURN  
*
07D2:  MOV     W5,[W15++]
07D4:  MOV     W6,[W15++]
07D6:  MOV     W0,W4
07D8:  MOV     W1,W5
07DA:  CLR     W0
07DC:  CLR     W1
07DE:  BCLR    W6.0
07E0:  BTSS    W5.F
07E2:  BRA     7F0
07E4:  BSET    W6.0
07E6:  NEG     W4,W4
07E8:  BRA     Z,7EE
07EA:  COM     W5,W5
07EC:  BRA     7F0
07EE:  NEG     W5,W5
07F0:  IOR      W4,  W5,W3
07F2:  BRA     Z,81A
07F4:  CLR     W2
07F6:  MOV     #B6,W1
07F8:  BTSC    W2.7
07FA:  BRA     80A
07FC:  BCLR.B  42.0
07FE:  RLC     W4,W4
0800:  RLC     W5,W5
0802:  RLC     W0,W0
0804:  RLC     W2,W2
0806:  DEC     W1,W1
0808:  BRA     NZ,7F8
080A:  SWAP    W1
080C:  BCLR.B  42.0
080E:  RRC     W1,W1
0810:  BCLR    W1.F
0812:  BCLR    W2.7
0814:  XOR.B   W2L,W1L,W1L
0816:  BTSC    W6.0
0818:  BSET    W1.F
081A:  MOV     [--W15],W6
081C:  MOV     [--W15],W5
081E:  RETURN  
0820:  MOV     W5,[W15++]
0822:  MOV     #C,W5
0824:  REPEAT  #4
0826:  MOV     [W5++],[W15++]
0828:  CLR     W9
082A:  XOR     W1,W3,W9
082C:  MOV     W1,W6
082E:  MOV     W0,W5
0830:  MOV     W3,W8
0832:  MOV     W2,W7
0834:  RLC     W1,W1
0836:  SWAP    W1
0838:  ZE      W1,W1
083A:  CP0     W1
083C:  BRA     Z,8DA
083E:  RLC     W3,W3
0840:  SWAP    W3
0842:  ZE      W3,W3
0844:  CP0     W3
0846:  BRA     Z,8DA
0848:  CLR     W0
084A:  SUB.B   W1L,W3L,W0L
084C:  BRA     NC,854
084E:  ADD.B   #7F,W0L
0850:  BRA     C,8DA
0852:  BRA     85A
0854:  SUB.B   #81,W0L
0856:  BRA     NC,8DA
0858:  BRA     Z,8DA
085A:  MOV     W5,W1
085C:  MOV     W6,W2
085E:  BSET    W2.7
0860:  AND     #FF,W2
0862:  AND     #FF,W8
0864:  BSET    W8.7
0866:  MOV     #19,W10
0868:  CLR     W3
086A:  CLR     W4
086C:  SUB     W1,W7,W1
086E:  SUBB    W2,W8,W2
0870:  BRA     N,876
0872:  BRA     C,87C
0874:  BRA     NZ,87E
0876:  ADD     W1,W7,W1
0878:  ADDC    W2,W8,W2
087A:  BRA     87E
087C:  BSET    W4.0
087E:  DEC     W10,W10
0880:  BRA     Z,890
0882:  BCLR.B  42.0
0884:  RLC     W1,W1
0886:  RLC     W2,W2
0888:  BCLR.B  42.0
088A:  RLC     W4,W4
088C:  RLC     W3,W3
088E:  BRA     86C
0890:  CLR     W10
0892:  BTSC    W3.8
0894:  BRA     898
0896:  BRA     8A4
0898:  BCLR.B  42.0
089A:  RRC     W3,W3
089C:  BCLR    W3.7
089E:  RRC     W4,W4
08A0:  RLC     W10,W10
08A2:  BRA     8A8
08A4:  DEC     W0,W0
08A6:  BRA     Z,8DA
08A8:  BTSC    W10.F
08AA:  BRA     NC,8B6
08AC:  RLC     W1,W1
08AE:  RLC     W2,W2
08B0:  SUB     W1,W7,W1
08B2:  SUBB    W2,W8,W2
08B4:  BRA     NC,8C8
08B6:  INC     W4,W4
08B8:  BRA     NZ,8C8
08BA:  INC     W3,W3
08BC:  BRA     NZ,8C8
08BE:  INC     W0,W0
08C0:  BRA     Z,8DA
08C2:  BRA     8C8
08C4:  DEC     W0,W0
08C6:  BRA     Z,8DA
08C8:  SWAP    W0
08CA:  RRC     W0,W1
08CC:  BSET    W1.F
08CE:  BTSS    W9.F
08D0:  BCLR    W1.F
08D2:  BCLR    W3.7
08D4:  XOR.B   W3L,W1L,W1L
08D6:  MOV     W4,W0
08D8:  BRA     8E0
08DA:  MOV     #0,W0
08DC:  MOV     #0,W1
08DE:  BRA     8E0
08E0:  MOV     #14,W5
08E2:  REPEAT  #4
08E4:  MOV     [--W15],[W5--]
08E6:  MOV     [--W15],W5
08E8:  RETURN  
08EA:  MOV     W8,[W15++]
08EC:  MOV     #12,W8
08EE:  REPEAT  #4
08F0:  MOV     [W8++],[W15++]
08F2:  MOV     #0,W9
08F4:  BTSC.B  43.0
08F6:  MOV     #1,W9
08F8:  MOV     W9,[W15++]
08FA:  CLR     W8
08FC:  CLR     W9
08FE:  CLR     W10
0900:  CLR     W11
0902:  CLR     W12
0904:  CLR     W13
0906:  MOV     #E,W8
0908:  MOV     #0,W9
090A:  LNK     #10
090C:  MOV     W12,[W14+W8]
090E:  DEC2    W8,W8
0910:  BRA     NN,90C
0912:  XOR     W4,W5,W8
0914:  BRA     NZ,91A
0916:  XOR     W6,W7,W8
0918:  BRA     Z,9AA
091A:  CLR     W8
091C:  CLR     W13
091E:  MOV     W13,[W15++]
0920:  BTSS    W3.F
0922:  BRA     938
0924:  MOV     [--W15],W13
0926:  BSET    W13.F
0928:  MOV     W13,[W15++]
092A:  COM     W3,W3
092C:  COM     W2,W2
092E:  COM     W1,W1
0930:  NEG     W0,W0
0932:  ADDC    W1,#0,W1
0934:  ADDC    W2,#0,W2
0936:  ADDC    W3,#0,W3
0938:  BTSS    W7.F
093A:  BRA     950
093C:  MOV     [--W15],W13
093E:  BTG     W13.F
0940:  MOV     W13,[W15++]
0942:  COM     W7,W7
0944:  COM     W6,W6
0946:  COM     W5,W5
0948:  NEG     W4,W4
094A:  ADDC    W5,#0,W5
094C:  ADDC    W6,#0,W6
094E:  ADDC    W7,#0,W7
0950:  MOV     #40,W13
0952:  BCLR.B  42.0
0954:  RLC     W0,W0
0956:  RLC     W1,W1
0958:  RLC     W2,W2
095A:  RLC     W3,W3
095C:  RLC     W8,W8
095E:  RLC     W9,W9
0960:  RLC     W10,W10
0962:  RLC     W11,W11
0964:  CP      W11,W7
0966:  BRA     NZ,972
0968:  CPB     W10,W6
096A:  BRA     NZ,972
096C:  CPB     W9,W5
096E:  BRA     NZ,972
0970:  CPB     W8,W4
0972:  BRA     NC,97E
0974:  SUB     W8,W4,W8
0976:  SUBB    W9,W5,W9
0978:  SUBB    W10,W6,W10
097A:  SUBB    W11,W7,W11
097C:  BSET.B  42.0
097E:  MOV     W8,[W14]
0980:  MOV     W9,[W14+#2]
0982:  MOV     W10,[W14+#4]
0984:  MOV     W11,[W14+#6]
0986:  MOV     [W14+#8],W8
0988:  MOV     [W14+#A],W9
098A:  MOV     [W14+#C],W10
098C:  MOV     [W14+#E],W11
098E:  RLC     W8,W8
0990:  RLC     W9,W9
0992:  RLC     W10,W10
0994:  RLC     W11,W11
0996:  MOV     W8,[W14+#8]
0998:  MOV     W9,[W14+#A]
099A:  MOV     W10,[W14+#C]
099C:  MOV     W11,[W14+#E]
099E:  MOV     [W14],W8
09A0:  MOV     [W14+#2],W9
09A2:  MOV     [W14+#4],W10
09A4:  MOV     [W14+#6],W11
09A6:  DEC     W13,W13
09A8:  BRA     NZ,952
09AA:  MOV     [W14+#8],W0
09AC:  MOV     [W14+#A],W1
09AE:  MOV     [W14+#C],W2
09B0:  MOV     [W14+#E],W3
09B2:  MOV     [--W15],W13
09B4:  BTSS    W13.F
09B6:  BRA     9C6
09B8:  COM     W3,W3
09BA:  COM     W2,W2
09BC:  COM     W1,W1
09BE:  NEG     W0,W0
09C0:  ADDC    W1,#0,W1
09C2:  ADDC    W2,#0,W2
09C4:  ADDC    W3,#0,W3
09C6:  ULNK    
09C8:  BRA     9CA
09CA:  MOV     [--W15],W9
09CC:  CP0     W9
09CE:  BRA     Z,9D8
09D0:  MOV     W8,W0
09D2:  MOV     W9,W1
09D4:  MOV     W10,W2
09D6:  MOV     W11,W3
09D8:  MOV     #1A,W8
09DA:  REPEAT  #4
09DC:  MOV     [--W15],[W8--]
09DE:  MOV     [--W15],W8
09E0:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
0244:  MOV     W5,[W15++]
0246:  MOV     #4B00,W5
0248:  REPEAT  #19E
024A:  NOP     
024C:  DEC     W5,W5
024E:  BRA     NZ,256
0250:  CLR     85A
0252:  MOV     #0,W0
0254:  BRA     262
0256:  BTSS.B  232.0
0258:  BRA     248
025A:  PUSH    232
025C:  POP     85A
025E:  MOV     236,W0
0260:  BCLR.B  232.1
0262:  MOV     [--W15],W5
0264:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14   
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
.................... unsigned int8 InboundTriggerValue[4]; 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... signed int16  TempInputSamples[2]; 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
.................... FlagType OutputFlag = 0; 
.................... FlagType DMATriggerFlag = 0; 
.................... FlagType DigitTerminationFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... void DisableInterrupts(void); 
.................... void EnableInterrupts(void); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH]; // =  
.................... //!{ 
.................... //!210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... //!-246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... //!368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... //!1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... //!1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... //!368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... //!-246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... //!210 
.................... //! 
.................... //!}; 
.................... //! 
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,961
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0266:  PUSH    42
0268:  PUSH    36
026A:  PUSH    32
026C:  MOV     W0,[W15++]
026E:  MOV     #2,W0
0270:  REPEAT  #C
0272:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
0274:  CALL    244
0278:  MOV.B   W0L,861
....................    UARTRXFlag = 1; 
027A:  MOV.B   #1,W0L
027C:  MOV.B   W0L,1227
.................... } 
....................  
027E:  BCLR.B  87.6
0280:  MOV     #1A,W0
0282:  REPEAT  #C
0284:  MOV     [--W15],[W0--]
0286:  MOV     [--W15],W0
0288:  POP     32
028A:  POP     36
028C:  POP     42
028E:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
0290:  PUSH    42
0292:  PUSH    36
0294:  PUSH    32
0296:  MOV     W0,[W15++]
0298:  MOV     #2,W0
029A:  REPEAT  #C
029C:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); 
029E:  BCLR.B  2C9.6
02A0:  BTG.B   2CD.6
....................    read_adc(); 
02A2:  BCLR.B  320.0
02A4:  BSET.B  320.1
02A6:  BTSS.B  320.0
02A8:  BRA     2A6
.................... //!   if(NormalizeFlag == 1) 
.................... //!   { 
.................... //!      read_adc(); 
.................... //!      NormalizeDataCounter++; 
.................... //!   } 
.................... //!   else 
.................... //!   { 
.................... //!      unsigned int16 ADCValue = 0; 
.................... //!       
.................... //!      if (TriggerFlag != 2) 
.................... //!      { 
.................... //!          ADCValue = QuickDigitize(read_adc()); 
.................... //!      } 
.................... //!       
.................... //!      if (DMAFlag == 0) 
.................... //!      { 
.................... //!         disable_interrupts(INT_DMA0); 
.................... //!         memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!         DMAFlag = 1; 
.................... //!      } 
.................... //!       
.................... //!      if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
.................... //!      { 
.................... //!         TempInputSamples[0] = ADCValue; 
.................... //!         TriggerFlag = 1; 
.................... //!      } 
.................... //!      else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) 
.................... //!      { 
.................... //!         TempInputSamples[1] = ADCValue; 
.................... //!         TriggerFlag = 2; 
.................... //!      } 
.................... //!      else if(TriggerFlag == 2) 
.................... //!      { 
.................... //!         if(DMAFlag == 1) 
.................... //!         { 
.................... //!            memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!            dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
.................... //!            enable_interrupts(INT_DMA0); 
.................... //!            DMAFlag = 2; 
.................... //!         } 
.................... //!          
.................... //!         read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
.................... //!      }   
.................... //!      else 
.................... //!      { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
.................... //!          
.................... //!         TriggerFlag = 0; 
.................... //!      } 
.................... //!   } 
02AA:  BCLR.B  84.3
02AC:  MOV     #1A,W0
02AE:  REPEAT  #C
02B0:  MOV     [--W15],[W0--]
02B2:  MOV     [--W15],W0
02B4:  POP     32
02B6:  POP     36
02B8:  POP     42
02BA:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0DCA:  MOV     #4444,W0
0DCC:  MOV     W0,A4
0DCE:  BSET.B  81.7
0DD0:  MOV     #46,W0
0DD2:  MOV.B   W0L,742
0DD4:  MOV     #57,W0
0DD6:  MOV.B   W0L,742
0DD8:  BCLR.B  742.6
0DDA:  MOV     #3F07,W0
0DDC:  MOV     W0,6A6
0DDE:  MOV     #5,W0
0DE0:  MOV     W0,6C6
0DE2:  MOV     #46,W0
0DE4:  MOV.B   W0L,742
0DE6:  MOV     #57,W0
0DE8:  MOV.B   W0L,742
0DEA:  BSET.B  742.6
0DEC:  MOV     #41,W4
0DEE:  MOV     W4,744
0DF0:  MOV     #32,W4
0DF2:  MOV     W4,746
0DF4:  CLR     85A
0DF6:  MOV     #8000,W4
0DF8:  MOV     W4,230
0DFA:  MOV     #400,W4
0DFC:  MOV     W4,232
0DFE:  BSET.B  230.3
0E00:  MOV     #22,W4
0E02:  MOV     W4,238
0E04:  CLR     85E
0E06:  CLR     968
0E08:  CLR     96A
0E0A:  CLR     96C
0E0C:  CLR     96E
0E0E:  CLR     970
0E10:  CLR     116A
0E12:  CLR     116C
0E14:  CLR     116E
0E16:  CLR     1170
0E18:  CLR     1172
0E1A:  CLR     1174
0E1C:  CLR     1176
0E1E:  CLR     1178
0E20:  CLR     1202
0E22:  CLR     1204
0E24:  CLR     1206
0E26:  CLR     1208
0E28:  CLR.B   861
0E2A:  CLR     120A
0E2C:  CLR     120C
0E2E:  CLR     120E
0E30:  CLR     1210
0E32:  CLR     1212
0E34:  CLR     1214
0E36:  CLR     1216
0E38:  CLR     1218
0E3A:  CLR     121A
0E3C:  CLR     121C
0E3E:  CLR     121E
0E40:  CLR     1220
0E42:  CLR     1222
0E44:  CLR     1224
0E46:  CLR.B   961
0E48:  CLR.B   1226
0E4A:  CLR.B   1227
0E4C:  CLR.B   1228
0E4E:  CLR.B   1229
0E50:  CLR.B   122A
0E52:  CLR.B   122B
0E54:  CLR.B   122C
0E56:  CLR.B   122D
0E58:  MOV     #41,W4
0E5A:  MOV     W4,744
0E5C:  MOV     #32,W4
0E5E:  MOV     W4,746
0E60:  DISI    #E
0E62:  MOV     #101,W0
0E64:  MOV     #743,W1
0E66:  MOV     #78,W2
0E68:  MOV     #9A,W3
0E6A:  MOV.B   W2L,[W1]
0E6C:  MOV.B   W3L,[W1]
0E6E:  MOV.B   W0L,743
0E70:  LSR     W0,#8,W0
0E72:  MOV     #742,W1
0E74:  MOV     #46,W2
0E76:  MOV     #57,W3
0E78:  MOV.B   W2L,[W1]
0E7A:  MOV.B   W3L,[W1]
0E7C:  MOV.B   W0L,[W1]
0E7E:  SETM    32C
0E80:  MOV     #3F80,W15
0E82:  MOV     #3FFF,W0
0E84:  MOV     W0,20
0E86:  NOP     
0E88:  CLR     85C
0E8A:  MOV     #3F80,W15
0E8C:  MOV     #3FFF,W0
0E8E:  MOV     W0,20
0E90:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0E92:  MOV     #4000,W1
0E94:  MOV     #0,W2
0E96:  REPEAT  #FE
0E98:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0E9A:  MOV     #41FE,W1
0E9C:  MOV     #61,W2
0E9E:  MOV.B   #61,W2L
0EA0:  REPEAT  #FE
0EA2:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0EA4:  CLR.B   381
0EA6:  MOV.B   #D,W0L
0EA8:  MOV.B   W0L,382
0EAA:  MOV     #300,W4
0EAC:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0EAE:  BCLR.B  381.7
0EB0:  CLR.B   380
0EB2:  MOV     #4000,W4
0EB4:  MOV     W4,384
0EB6:  MOV     #FF,W4
0EB8:  MOV     W4,38A
0EBA:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
0EBC:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0EBE:  MOV     #9F00,W4
0EC0:  MOV     W4,324
0EC2:  MOV     #84E0,W4
0EC4:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0EC6:  MOV     #FFFE,W4
0EC8:  MOV     W4,32C
0ECA:  CLR     322
....................     
....................    read_adc(); 
0ECC:  BCLR.B  320.0
0ECE:  BSET.B  320.1
0ED0:  BTSS.B  320.0
0ED2:  BRA     ED0
....................     
....................    //TimerTicks = 53334; 
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0ED4:  CLR     104
0ED6:  PUSH    85E
0ED8:  POP     102
0EDA:  MOV     #8000,W4
0EDC:  MOV     W4,104
....................    EnableInterrupts(); 
0EDE:  CALL    2BC
....................     
....................    NormalizeFlag = 1; 
0EE2:  MOV.B   #1,W0L
0EE4:  MOV.B   W0L,1226
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
0EE6:  CP0.B   961
0EE8:  BRA     NZ,EF4
0EEA:  MOV     1222,W4
0EEC:  XOR     #FF,W4
0EEE:  BRA     NZ,FB0
0EF0:  CP0     1224
0EF2:  BRA     NZ,FB0
....................       { 
....................          disable_interrupts(INT_DMA0); 
0EF4:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
0EF6:  CLR     12AE
0EF8:  CLR     12B0
0EFA:  MOV     12B0,W4
0EFC:  CP      W4,#0
0EFE:  BRA     GTU,F1E
0F00:  BRA     NC,F0A
0F02:  MOV     12AE,W4
0F04:  MOV     #FF,W3
0F06:  CP      W3,W4
0F08:  BRA     LEU,F1E
....................          { 
....................             AccumulateAnalogData(Index); 
0F0A:  PUSH    12AE
0F0C:  POP     12B8
0F0E:  PUSH    12B0
0F10:  POP     12BA
0F12:  CALL    606
0F16:  INC     12AE
0F18:  BTSC.B  42.1
0F1A:  INC     12B0
0F1C:  BRA     EFA
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
0F1E:  MOV     1226,W4
0F20:  CP.B    W4L,#1
0F22:  BRA     NZ,F28
....................          { 
....................             NormalizeData(); 
0F24:  CALL    9E2
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
0F28:  MOV     1228,W4
0F2A:  CP.B    W4L,#1
0F2C:  BRA     NZ,FA0
....................          { 
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0F2E:  CLR     12B2
0F30:  CLR     12B4
0F32:  MOV     12B4,W4
0F34:  CP      W4,#0
0F36:  BRA     GTU,F5C
0F38:  BRA     NC,F42
0F3A:  MOV     12B2,W4
0F3C:  MOV     #FF,W3
0F3E:  CP      W3,W4
0F40:  BRA     LEU,F5C
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
0F42:  MOV     #862,W4
0F44:  MOV     12B2,W3
0F46:  ADD     W3,W4,W0
0F48:  MOV.B   [W0],W5L
0F4A:  BTSC.B  233.1
0F4C:  BRA     F4A
0F4E:  PUSH    234
0F50:  MOV.B   W5L,[W15-#2]
0F52:  POP     234
0F54:  INC     12B2
0F56:  BTSC.B  42.1
0F58:  INC     12B4
0F5A:  BRA     F32
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
0F5C:  CLR     12B2
0F5E:  CLR     12B4
0F60:  MOV     12B4,W4
0F62:  CP      W4,#0
0F64:  BRA     GTU,FA0
0F66:  BRA     NC,F70
0F68:  MOV     12B2,W4
0F6A:  MOV     #FF,W3
0F6C:  CP      W3,W4
0F6E:  BRA     LEU,FA0
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
0F70:  MOV     #2,W4
0F72:  CLR.B   9
0F74:  MOV     12B2,W0
0F76:  MOV     12B4,W1
0F78:  INC     W4,W4
0F7A:  DEC     W4,W4
0F7C:  BRA     Z,F84
0F7E:  SL      W0,W0
0F80:  RLC     W1,W1
0F82:  BRA     F7A
0F84:  MOV     #972,W4
0F86:  ADD     W0,W4,W0
0F88:  MOV     #A,W4
0F8A:  MOV     [W0++],[W4++]
0F8C:  MOV     [W0++],[W4++]
0F8E:  BTSC.B  233.1
0F90:  BRA     F8E
0F92:  PUSH    234
0F94:  MOV.B   W5L,[W15-#2]
0F96:  POP     234
0F98:  INC     12B2
0F9A:  BTSC.B  42.1
0F9C:  INC     12B4
0F9E:  BRA     F60
....................             } 
....................          } 
....................           
....................          NormalizeFlag = 0; 
0FA0:  CLR.B   1226
....................          HandShakeFlag = 0;    
0FA2:  CLR.B   1228
....................          CurrentIndex = 0; 
0FA4:  CLR     1216
0FA6:  CLR     1218
....................          enable_interrupts(INT_DMA0); 
0FA8:  BSET.B  94.4
....................          DMADoneFlag = 0; 
0FAA:  CLR.B   961
....................          TriggerFlag = 0; 
0FAC:  CLR.B   1229
....................          DMAFlag = 0; 
0FAE:  CLR.B   122A
....................       }   
....................        
....................       if (UARTRXFlag) 
0FB0:  CP0.B   1227
0FB2:  BRA     Z,FBC
....................       { 
....................          CommHandler(UARTRX); 
0FB4:  MOV.B   861,W0L
0FB6:  MOV.B   W0L,12B8
0FB8:  CALL    C14
....................       }   
0FBC:  BRA     EE6
....................    } 
.................... } 
....................  
0FBE:  BRA     FBE
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
0606:  MOV     W5,[W15++]
0608:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
060A:  MOV     #1,W4
060C:  CLR.B   9
060E:  MOV     1216,W0
0610:  MOV     1218,W1
0612:  INC     W4,W4
0614:  DEC     W4,W4
0616:  BRA     Z,61E
0618:  SL      W0,W0
061A:  RLC     W1,W1
061C:  BRA     614
061E:  MOV     #117A,W4
0620:  ADD     W0,W4,W5
0622:  MOV     #1,W4
0624:  CLR.B   9
0626:  MOV     12B8,W0
0628:  MOV     12BA,W1
062A:  INC     W4,W4
062C:  DEC     W4,W4
062E:  BRA     Z,636
0630:  SL      W0,W0
0632:  RLC     W1,W1
0634:  BRA     62C
0636:  MOV     #4000,W4
0638:  ADD     W0,W4,W0
063A:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
063C:  PUSH    1216
063E:  POP     1212
0640:  PUSH    1218
0642:  POP     1214
....................    Accumulator = 0; 
0644:  CLR     96E
0646:  CLR     970
....................    CoefficentIndex = 0; 
0648:  CLR     120E
064A:  CLR     1210
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
064C:  MOV     1210,W4
064E:  CP      W4,#0
0650:  BRA     GTU,6D4
0652:  BRA     NC,65C
0654:  MOV     120E,W4
0656:  MOV     #3F,W3
0658:  CP      W3,W4
065A:  BRA     LEU,6D4
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
065C:  MOV     #1,W4
065E:  CLR.B   9
0660:  MOV     1212,W0
0662:  MOV     1214,W1
0664:  INC     W4,W4
0666:  DEC     W4,W4
0668:  BRA     Z,670
066A:  SL      W0,W0
066C:  RLC     W1,W1
066E:  BRA     666
0670:  MOV     #117A,W4
0672:  ADD     W0,W4,W0
0674:  MOV     W0,W4
0676:  MOV     [W4],W0
0678:  MOV     W0,W5
067A:  CLR     W6
067C:  BTSC    W5.F
067E:  SETM    W6
0680:  MOV     #1,W4
0682:  CLR.B   9
0684:  MOV     120E,W0
0686:  MOV     1210,W1
0688:  INC     W4,W4
068A:  DEC     W4,W4
068C:  BRA     Z,694
068E:  SL      W0,W0
0690:  RLC     W1,W1
0692:  BRA     68A
0694:  MOV     #122E,W4
0696:  ADD     W0,W4,W0
0698:  MOV     W0,W4
069A:  MOV     [W4],W0
069C:  CLR     W1
069E:  BTSC    W0.F
06A0:  SETM    W1
06A2:  MOV     W0,W2
06A4:  MOV     W1,W3
06A6:  MOV     W5,W0
06A8:  MOV     W6,W1
06AA:  CALL    2C8
06AE:  ADD     96E
06B0:  MOV     W1,W0
06B2:  ADDC    970,W0
06B4:  MOV     W0,970
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
06B6:  MOV     1212,W4
06B8:  XOR     #3F,W4
06BA:  BRA     NZ,6C6
06BC:  CP0     1214
06BE:  BRA     NZ,6C6
....................       { 
....................          InputIndex = 0; 
06C0:  CLR     1212
06C2:  CLR     1214
....................       } 
06C4:  BRA     6CC
....................       else 
....................       { 
....................          InputIndex++; 
06C6:  INC     1212
06C8:  BTSC.B  42.1
06CA:  INC     1214
....................       } 
....................        
....................       CoefficentIndex++; 
06CC:  INC     120E
06CE:  BTSC.B  42.1
06D0:  INC     1210
06D2:  BRA     64C
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
06D4:  MOV     #862,W4
06D6:  MOV     12B8,W3
06D8:  ADD     W3,W4,W5
06DA:  MOV     #1,W4
06DC:  CLR.B   9
06DE:  MOV     1216,W0
06E0:  MOV     1218,W1
06E2:  INC     W4,W4
06E4:  DEC     W4,W4
06E6:  BRA     Z,6EE
06E8:  SL      W0,W0
06EA:  RLC     W1,W1
06EC:  BRA     6E4
06EE:  MOV     #117A,W4
06F0:  ADD     W0,W4,W0
06F2:  MOV     [W0],W6
06F4:  LSR     W6,#4,W0
06F6:  MOV.B   W0L,[W5]
06F8:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
06FA:  MOV     1226,W4
06FC:  CP.B    W4L,#1
06FE:  BRA     NZ,720
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
0700:  MOV     #2,W4
0702:  CLR.B   9
0704:  MOV     12B8,W0
0706:  MOV     12BA,W1
0708:  INC     W4,W4
070A:  DEC     W4,W4
070C:  BRA     Z,714
070E:  SL      W0,W0
0710:  RLC     W1,W1
0712:  BRA     70A
0714:  MOV     #972,W4
0716:  ADD     W0,W4,W5
0718:  MOV     #96E,W4
071A:  MOV     [W4++],[W5++]
071C:  MOV     [W4++],[W5++]
....................    } 
071E:  BRA     7B6
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
0720:  MOV     96E,W0
0722:  MOV     970,W1
0724:  CLR     W3
0726:  BTSC    W1.F
0728:  SETM    W3
072A:  MOV     W3,W2
072C:  MOV     1172,W4
072E:  SUB     W0,W4,W0
0730:  MOV     1174,W4
0732:  SUBB    W1,W4,W1
0734:  MOV     1176,W4
0736:  SUBB    W2,W4,W2
0738:  MOV     1178,W4
073A:  SUBB    W3,W4,W3
073C:  CALL    30A
0740:  MOV     W0,12BC
0742:  MOV     W1,12BE
0744:  MOV     12BC,W0
0746:  MOV     12BE,W1
0748:  MOV     1206,W2
074A:  MOV     1208,W3
074C:  CALL    36C
0750:  MOV     W0,12C0
0752:  MOV     W1,12C2
0754:  BCLR.B  43.0
0756:  MOV     12C0,W0
0758:  MOV     12C2,W1
075A:  MOV     #0,W2
075C:  MOV     #42FE,W3
075E:  CALL    430
0762:  MOV     W0,12C4
0764:  MOV     W1,12C6
....................       //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................       //ConversionValue = (unsigned int8)OutputValue; 
....................       ConversionValue = (unsigned int8)StepThree; 
0766:  MOV     12C4,W0
0768:  MOV     12C6,W1
076A:  CALL    5DA
076E:  MOV.B   W0L,860
....................       DebugAccumulator[DMAADCIndex] = Accumulator; 
0770:  MOV     #2,W4
0772:  CLR.B   9
0774:  MOV     12B8,W0
0776:  MOV     12BA,W1
0778:  INC     W4,W4
077A:  DEC     W4,W4
077C:  BRA     Z,784
077E:  SL      W0,W0
0780:  RLC     W1,W1
0782:  BRA     77A
0784:  MOV     #D6E,W4
0786:  ADD     W0,W4,W5
0788:  MOV     #96E,W4
078A:  MOV     [W4++],[W5++]
078C:  MOV     [W4++],[W5++]
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
078E:  MOV     #2,W4
0790:  CLR.B   9
0792:  MOV     12B8,W0
0794:  MOV     12BA,W1
0796:  INC     W4,W4
0798:  DEC     W4,W4
079A:  BRA     Z,7A2
079C:  SL      W0,W0
079E:  RLC     W1,W1
07A0:  BRA     798
07A2:  MOV     #972,W4
07A4:  ADD     W0,W4,W5
07A6:  MOV     860,W0
07A8:  MOV.B   W0L,[W5+#0]
07AA:  MOV.B   #0,W0L
07AC:  MOV.B   W0L,[W5+#1]
07AE:  MOV.B   #0,W0L
07B0:  MOV.B   W0L,[W5+#2]
07B2:  MOV.B   #0,W0L
07B4:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................     if (CurrentIndex == 0) 
07B6:  CP0     1216
07B8:  BRA     NZ,7C6
07BA:  CP0     1218
07BC:  BRA     NZ,7C6
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
07BE:  MOV     #3F,W4
07C0:  MOV     W4,1216
07C2:  CLR     1218
....................    } 
07C4:  BRA     7CC
....................    else 
....................    { 
....................      CurrentIndex--; 
07C6:  DEC     1216
07C8:  BTSS.B  42.0
07CA:  DEC     1218
....................    }  
07CC:  MOV     [--W15],W6
07CE:  MOV     [--W15],W5
07D0:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
09E2:  MOV     W5,[W15++]
09E4:  MOV     W6,[W15++]
09E6:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
09E8:  MOV     1220,W4
09EA:  CP      W4,#0
09EC:  BRA     GTU,B8C
09EE:  BRA     NC,9F8
09F0:  MOV     121E,W4
09F2:  MOV     #BB8,W3
09F4:  CP      W3,W4
09F6:  BRA     LEU,B8C
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
09F8:  PUSH    A72
09FA:  POP     116A
09FC:  PUSH    A74
09FE:  POP     116C
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A00:  PUSH    A72
0A02:  POP     116E
0A04:  PUSH    A74
0A06:  POP     1170
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0A08:  PUSH    4080
0A0A:  POP     968
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A0C:  MOV     #41,W4
0A0E:  MOV     W4,12B8
0A10:  CLR     12BA
0A12:  MOV     12BA,W4
0A14:  CP      W4,#0
0A16:  BRA     GTU,B3C
0A18:  BRA     NC,A22
0A1A:  MOV     12B8,W4
0A1C:  MOV     #FF,W3
0A1E:  CP      W3,W4
0A20:  BRA     LEU,B3C
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0A22:  MOV     #2,W4
0A24:  CLR.B   9
0A26:  MOV     12B8,W0
0A28:  MOV     12BA,W1
0A2A:  INC     W4,W4
0A2C:  DEC     W4,W4
0A2E:  BRA     Z,A36
0A30:  SL      W0,W0
0A32:  RLC     W1,W1
0A34:  BRA     A2C
0A36:  MOV     #972,W4
0A38:  ADD     W0,W4,W0
0A3A:  MOV     W0,W4
0A3C:  MOV     #0,W3
0A3E:  MOV     [W4++],[W3++]
0A40:  MOV     [W4++],[W3++]
0A42:  MOV     1170,W4
0A44:  CP      W4,W1
0A46:  BRA     LT,A6E
0A48:  BRA     GT,A50
0A4A:  MOV     116E,W4
0A4C:  CP      W4,W0
0A4E:  BRA     LEU,A6E
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0A50:  MOV     #2,W4
0A52:  CLR.B   9
0A54:  MOV     12B8,W0
0A56:  MOV     12BA,W1
0A58:  INC     W4,W4
0A5A:  DEC     W4,W4
0A5C:  BRA     Z,A64
0A5E:  SL      W0,W0
0A60:  RLC     W1,W1
0A62:  BRA     A5A
0A64:  MOV     #972,W4
0A66:  ADD     W0,W4,W0
0A68:  MOV     #116E,W4
0A6A:  MOV     [W0++],[W4++]
0A6C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0A6E:  MOV     #2,W4
0A70:  CLR.B   9
0A72:  MOV     12B8,W0
0A74:  MOV     12BA,W1
0A76:  INC     W4,W4
0A78:  DEC     W4,W4
0A7A:  BRA     Z,A82
0A7C:  SL      W0,W0
0A7E:  RLC     W1,W1
0A80:  BRA     A78
0A82:  MOV     #972,W4
0A84:  ADD     W0,W4,W0
0A86:  MOV     W0,W4
0A88:  MOV     #0,W3
0A8A:  MOV     [W4++],[W3++]
0A8C:  MOV     [W4++],[W3++]
0A8E:  MOV     116C,W4
0A90:  CP      W4,W1
0A92:  BRA     GT,ABA
0A94:  BRA     LT,A9C
0A96:  MOV     116A,W4
0A98:  CP      W4,W0
0A9A:  BRA     C,ABA
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0A9C:  MOV     #2,W4
0A9E:  CLR.B   9
0AA0:  MOV     12B8,W0
0AA2:  MOV     12BA,W1
0AA4:  INC     W4,W4
0AA6:  DEC     W4,W4
0AA8:  BRA     Z,AB0
0AAA:  SL      W0,W0
0AAC:  RLC     W1,W1
0AAE:  BRA     AA6
0AB0:  MOV     #972,W4
0AB2:  ADD     W0,W4,W0
0AB4:  MOV     #116A,W4
0AB6:  MOV     [W0++],[W4++]
0AB8:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0ABA:  MOV     #1,W4
0ABC:  CLR.B   9
0ABE:  MOV     12B8,W0
0AC0:  MOV     12BA,W1
0AC2:  INC     W4,W4
0AC4:  DEC     W4,W4
0AC6:  BRA     Z,ACE
0AC8:  SL      W0,W0
0ACA:  RLC     W1,W1
0ACC:  BRA     AC4
0ACE:  MOV     #4000,W4
0AD0:  ADD     W0,W4,W0
0AD2:  MOV     W0,W4
0AD4:  MOV     [W4],W0
0AD6:  MOV     968,W4
0AD8:  CP      W4,W0
0ADA:  BRA     LEU,AF8
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0ADC:  MOV     #1,W4
0ADE:  CLR.B   9
0AE0:  MOV     12B8,W0
0AE2:  MOV     12BA,W1
0AE4:  INC     W4,W4
0AE6:  DEC     W4,W4
0AE8:  BRA     Z,AF0
0AEA:  SL      W0,W0
0AEC:  RLC     W1,W1
0AEE:  BRA     AE6
0AF0:  MOV     #4000,W4
0AF2:  ADD     W0,W4,W0
0AF4:  MOV     [W0],[W15++]
0AF6:  POP     968
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0AF8:  MOV     #2,W4
0AFA:  CLR.B   9
0AFC:  MOV     12B8,W0
0AFE:  MOV     12BA,W1
0B00:  INC     W4,W4
0B02:  DEC     W4,W4
0B04:  BRA     Z,B0C
0B06:  SL      W0,W0
0B08:  RLC     W1,W1
0B0A:  BRA     B02
0B0C:  MOV     #972,W4
0B0E:  ADD     W0,W4,W0
0B10:  MOV     W0,W4
0B12:  MOV     #0,W3
0B14:  MOV     [W4++],[W3++]
0B16:  MOV     [W4++],[W3++]
0B18:  CLR     W3
0B1A:  BTSC    W1.F
0B1C:  SETM    W3
0B1E:  MOV     W3,W2
0B20:  ADD     1172
0B22:  MOV     W1,W0
0B24:  ADDC    1174,W0
0B26:  MOV     W0,1174
0B28:  MOV     1176,W4
0B2A:  ADDC    W2,W4,W0
0B2C:  MOV     W0,1176
0B2E:  MOV     1178,W4
0B30:  ADDC    W3,W4,W0
0B32:  MOV     W0,1178
0B34:  INC     12B8
0B36:  BTSC.B  42.1
0B38:  INC     12BA
0B3A:  BRA     A12
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0B3C:  MOV     116A,W4
0B3E:  MOV     116E,W3
0B40:  SUB     W4,W3,W0
0B42:  MOV     116C,W4
0B44:  MOV     1170,W3
0B46:  SUBB    W4,W3,W1
0B48:  CALL    7D2
0B4C:  MOV     W0,1202
0B4E:  MOV     W1,1204
....................       AverageMultiplier = (255.0/ AverageDivider); 
0B50:  MOV     #0,W0
0B52:  MOV     #437F,W1
0B54:  MOV     1202,W2
0B56:  MOV     1204,W3
0B58:  CALL    820
0B5C:  MOV     W0,1206
0B5E:  MOV     W1,1208
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0B60:  BCLR.B  43.0
0B62:  MOV     1172,W0
0B64:  MOV     1174,W1
0B66:  MOV     1176,W2
0B68:  MOV     1178,W3
0B6A:  MOV     #BF,W4
0B6C:  MOV     #0,W5
0B6E:  MOV     #0,W6
0B70:  MOV     #0,W7
0B72:  CALL    8EA
0B76:  MOV     W0,1172
0B78:  MOV     W1,1174
0B7A:  MOV     W2,1176
0B7C:  MOV     W3,1178
....................        
....................       TriggerValue = InitialTriggerValue; 
0B7E:  PUSH    968
0B80:  POP     96A
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0B82:  MOV     #972,W1
0B84:  MOV     #0,W2
0B86:  REPEAT  #1FD
0B88:  CLR.B   [W1++]
....................    }   
0B8A:  BRA     BF4
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0B8C:  PUSH    4080
0B8E:  POP     968
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0B90:  MOV     #41,W4
0B92:  MOV     W4,12BC
0B94:  CLR     12BE
0B96:  MOV     12BE,W4
0B98:  CP      W4,#0
0B9A:  BRA     GTU,BEC
0B9C:  BRA     NC,BA6
0B9E:  MOV     12BC,W4
0BA0:  MOV     #FF,W3
0BA2:  CP      W3,W4
0BA4:  BRA     LEU,BEC
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0BA6:  MOV     #1,W4
0BA8:  CLR.B   9
0BAA:  MOV     12BC,W0
0BAC:  MOV     12BE,W1
0BAE:  INC     W4,W4
0BB0:  DEC     W4,W4
0BB2:  BRA     Z,BBA
0BB4:  SL      W0,W0
0BB6:  RLC     W1,W1
0BB8:  BRA     BB0
0BBA:  MOV     #4000,W4
0BBC:  ADD     W0,W4,W0
0BBE:  MOV     W0,W4
0BC0:  MOV     [W4],W0
0BC2:  MOV     968,W4
0BC4:  CP      W4,W0
0BC6:  BRA     LEU,BE4
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0BC8:  MOV     #1,W4
0BCA:  CLR.B   9
0BCC:  MOV     12BC,W0
0BCE:  MOV     12BE,W1
0BD0:  INC     W4,W4
0BD2:  DEC     W4,W4
0BD4:  BRA     Z,BDC
0BD6:  SL      W0,W0
0BD8:  RLC     W1,W1
0BDA:  BRA     BD2
0BDC:  MOV     #4000,W4
0BDE:  ADD     W0,W4,W0
0BE0:  MOV     [W0],[W15++]
0BE2:  POP     968
....................         }              
0BE4:  INC     12BC
0BE6:  BTSC.B  42.1
0BE8:  INC     12BE
0BEA:  BRA     B96
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0BEC:  PUSH    968
0BEE:  POP     96A
....................       ErrorCounter = 0;  
0BF0:  CLR     121E
0BF2:  CLR     1220
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0BF4:  CLR     1222
0BF6:  CLR     1224
....................    NormalizeFlag = 0; 
0BF8:  CLR.B   1226
....................    CurrentIndex = 0; 
0BFA:  CLR     1216
0BFC:  CLR     1218
0BFE:  MOV     [--W15],W7
0C00:  MOV     [--W15],W6
0C02:  MOV     [--W15],W5
0C04:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
.................... { 
....................     InputIndex = CurrentIndex; 
....................     CoefficentIndex = 0; 
....................     Accumulator = 0; 
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
....................       { 
....................          Accumulator += (signed int32)ADCValue * (signed int32)fir_coef[CoefficentIndex]; 
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
....................          { 
....................             InputIndex = 0; 
....................          } 
....................          else 
....................          { 
....................             InputIndex++; 
....................          } 
....................          CoefficentIndex++; 
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
....................        
....................     return ConversionValue;   
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0C14:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0C16:  MOV.B   12B8,W0L
0C18:  CLR.B   1
0C1A:  XOR     #2B,W0
0C1C:  BRA     Z,C34
0C1E:  XOR     #1,W0
0C20:  BRA     Z,C3A
0C22:  XOR     #6E,W0
0C24:  BRA     Z,C3E
0C26:  XOR     #8,W0
0C28:  BRA     Z,C50
0C2A:  XOR     #68,W0
0C2C:  BRA     Z,D0E
0C2E:  XOR     #1,W0
0C30:  BRA     Z,D6A
0C32:  BRA     DC2
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0C34:  MOV.B   #1,W0L
0C36:  MOV.B   W0L,1228
....................          break; 
0C38:  BRA     DC2
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0C3A:  BCLR.B  94.3
....................          break; 
0C3C:  BRA     DC2
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0C3E:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0C40:  CLR     104
0C42:  PUSH    85E
0C44:  POP     102
0C46:  MOV     #8000,W4
0C48:  MOV     W4,104
....................          HandshakeFlag = 1;   
0C4A:  MOV.B   #1,W0L
0C4C:  MOV.B   W0L,1228
....................          break;  
0C4E:  BRA     DC2
....................                       
....................       case 'L': 
....................          DisableInterrupts(); 
0C50:  CALL    C06
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0C54:  MOV     #122E,W1
0C56:  MOV     #0,W2
0C58:  REPEAT  #7F
0C5A:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0C5C:  MOV     120A,W4
0C5E:  XOR     #40,W4
0C60:  BRA     NZ,C66
0C62:  CP0     120C
0C64:  BRA     Z,CDA
....................          { 
....................             if (kbhit(SHARP)) 
0C66:  BTSS.B  232.0
0C68:  BRA     CD8
0C6A:  PUSH    42
0C6C:  BCLR.B  81.7
0C6E:  SETM.B  42
0C70:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0C72:  CALL    244
0C76:  BCLR.B  81.7
0C78:  POP     42
0C7A:  BSET.B  81.7
0C7C:  MOV.B   W0L,12B9
....................                 
....................                if (CoefficentByte == 'L') 
0C7E:  MOV     12B8,W4
0C80:  LSR     W4,#8,W4
0C82:  XOR.B   #4C,W4L
0C84:  BRA     NZ,C88
....................                { 
....................                   ; // Do nothing 
....................                }               
0C86:  BRA     CD8
....................                else if (NumberCSharpByteRecieved == 0) 
0C88:  CP0     121A
0C8A:  BRA     NZ,C9C
0C8C:  CP0     121C
0C8E:  BRA     NZ,C9C
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0C90:  MOV.B   12B9,W0L
0C92:  MOV.B   W0L,962
....................                   NumberCSharpByteRecieved = 1; 
0C94:  MOV     #1,W4
0C96:  MOV     W4,121A
0C98:  CLR     121C
....................                }            
0C9A:  BRA     CD8
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0C9C:  MOV.B   12B9,W0L
0C9E:  MOV.B   W0L,963
....................                   NumberCSharpByteRecieved = 0; 
0CA0:  CLR     121A
0CA2:  CLR     121C
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0CA4:  MOV.B   963,W0L
0CA6:  MOV.B   W0L,W5L
0CA8:  CLR.B   B
0CAA:  MOV.B   W5L,W0L
0CAC:  MOV.B   W0L,B
0CAE:  CLR.B   W5
0CB0:  MOV     W5,W0
0CB2:  IOR     962,W0
0CB4:  MOV     W0,96C
....................                   fir_coef[CSharpCoefficentRecieved] =  ByteConversionResult; 
0CB6:  MOV     #1,W4
0CB8:  CLR.B   9
0CBA:  MOV     120A,W0
0CBC:  MOV     120C,W1
0CBE:  INC     W4,W4
0CC0:  DEC     W4,W4
0CC2:  BRA     Z,CCA
0CC4:  SL      W0,W0
0CC6:  RLC     W1,W1
0CC8:  BRA     CC0
0CCA:  MOV     #122E,W4
0CCC:  ADD     W0,W4,W5
0CCE:  MOV     96C,W4
0CD0:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0CD2:  INC     120A
0CD4:  BTSC.B  42.1
0CD6:  INC     120C
....................                } 
....................             } 
0CD8:  BRA     C5C
....................          } 
....................           
....................          switch (fir_coef[0]) 
0CDA:  MOV     122E,W0
0CDC:  XOR     #D2,W0
0CDE:  BRA     Z,CEA
0CE0:  XOR     #FA,W0
0CE2:  BRA     Z,CF0
0CE4:  XOR     #149,W0
0CE6:  BRA     Z,CF6
0CE8:  BRA     CFC
....................          { 
....................          case 210: //Todo:: Fall Through  
....................             TimerTicks = 53334; 
0CEA:  MOV     #D056,W4
0CEC:  MOV     W4,85E
....................             break; 
0CEE:  BRA     D00
....................          case 40: 
....................             TimerTicks = 53334; 
0CF0:  MOV     #D056,W4
0CF2:  MOV     W4,85E
....................             break; 
0CF4:  BRA     D00
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0CF6:  MOV     #1F40,W4
0CF8:  MOV     W4,85E
....................             break; 
0CFA:  BRA     D00
....................          default:  
....................             TimerTicks = 8000; 
0CFC:  MOV     #1F40,W4
0CFE:  MOV     W4,85E
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0D00:  CLR     120A
0D02:  CLR     120C
....................          HandshakeFlag = 1; 
0D04:  MOV.B   #1,W0L
0D06:  MOV.B   W0L,1228
....................          EnableInterrupts(); 
0D08:  CALL    2BC
....................          break; 
0D0C:  BRA     DC2
....................          
....................       case '$': 
....................          DisableInterrupts(); 
0D0E:  CALL    C06
....................          TriggerValue = 0; // reset trigger value 
0D12:  CLR     96A
....................           
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0D14:  BTSS.B  232.0
0D16:  BRA     D58
0D18:  PUSH    42
0D1A:  BCLR.B  81.7
0D1C:  SETM.B  42
0D1E:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0D20:  CALL    244
0D24:  BCLR.B  81.7
0D26:  POP     42
0D28:  BSET.B  81.7
0D2A:  MOV.B   W0L,12BA
....................                 
....................                if (isdigit(DigitByte)) 
0D2C:  MOV     12BA,W4
0D2E:  MOV     #30,W3
0D30:  CP.B    W3L,W4L
0D32:  BRA     GTU,D4E
0D34:  MOV     12BA,W4
0D36:  MOV     #39,W3
0D38:  CP.B    W3L,W4L
0D3A:  BRA     NC,D4E
....................                { 
....................                   TriggerValue = TriggerValue * 10 + CharToInt(DigitByte); 
0D3C:  MOV     96A,W4
0D3E:  MUL.UU  W4,#A,W0
0D40:  MOV     W0,W5
0D42:  MOV.B   12BA,W0L
0D44:  SE      W0,W0
0D46:  SUB     #30,W0
0D48:  ADD     W0,W5,W0
0D4A:  MOV     W0,96A
....................                } 
0D4C:  BRA     D58
....................                else if (DigitByte == ')') 
0D4E:  MOV     12BA,W4
0D50:  XOR.B   #29,W4L
0D52:  BRA     NZ,D58
....................                { 
....................                   break; 
0D54:  BRA     D5A
....................                } 
0D56:  BRA     D58
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0D58:  BRA     D14
....................          } 
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0D5A:  CLR     104
0D5C:  PUSH    85E
0D5E:  POP     102
0D60:  MOV     #8000,W4
0D62:  MOV     W4,104
....................          EnableInterrupts(); 
0D64:  CALL    2BC
....................          break;  
0D68:  BRA     DC2
....................           
....................       case '%': 
....................          DisableInterrupts();   
0D6A:  CALL    C06
....................          TimerTicks = 0; // reset trigger value 
0D6E:  CLR     85E
....................              
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0D70:  BTSS.B  232.0
0D72:  BRA     DBA
0D74:  PUSH    42
0D76:  BCLR.B  81.7
0D78:  SETM.B  42
0D7A:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0D7C:  CALL    244
0D80:  BCLR.B  81.7
0D82:  POP     42
0D84:  BSET.B  81.7
0D86:  MOV.B   W0L,12BB
....................                 
....................                if (isdigit(DigitByte)) 
0D88:  MOV     12BA,W4
0D8A:  LSR     W4,#8,W4
0D8C:  MOV     #30,W3
0D8E:  CP.B    W3L,W4L
0D90:  BRA     GTU,DAE
0D92:  MOV     12BA,W4
0D94:  LSR     W4,#8,W4
0D96:  MOV     #39,W3
0D98:  CP.B    W3L,W4L
0D9A:  BRA     NC,DAE
....................                { 
....................                   TimerTicks = TimerTicks * 10 + CharToInt(DigitByte); 
0D9C:  MOV     85E,W4
0D9E:  MUL.UU  W4,#A,W0
0DA0:  MOV     W0,W5
0DA2:  MOV.B   12BB,W0L
0DA4:  SE      W0,W0
0DA6:  SUB     #30,W0
0DA8:  ADD     W0,W5,W0
0DAA:  MOV     W0,85E
....................                } 
0DAC:  BRA     DBA
....................                else if (DigitByte == ')') 
0DAE:  MOV     12BA,W4
0DB0:  LSR     W4,#8,W4
0DB2:  XOR.B   #29,W4L
0DB4:  BRA     NZ,DBA
....................                { 
....................                   break; 
0DB6:  BRA     DBC
....................                } 
0DB8:  BRA     DBA
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0DBA:  BRA     D70
....................          } 
....................          EnableInterrupts(); 
0DBC:  CALL    2BC
....................          break; 
0DC0:  BRA     DC2
....................           
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0DC2:  CLR.B   12B8
....................    UARTRXFlag = 0; 
0DC4:  CLR.B   1227
0DC6:  MOV     [--W15],W5
0DC8:  RETURN  
.................... } 
....................  
.................... void DisableInterrupts(void) 
.................... { 
....................    disable_interrupts(INT_TIMER1); // disable timer 
*
0C06:  BCLR.B  94.3
....................    disable_interrupts(INT_RDA2); 
0C08:  BCLR.B  97.6
....................    disable_interrupts(GLOBAL);  
0C0A:  BCLR.B  81.7
0C0C:  MOV     #E0,W4
0C0E:  MOV     W4,42
0C10:  BSET.B  81.7
0C12:  RETURN  
.................... } 
....................  
.................... void EnableInterrupts(void) 
.................... { 
....................    enable_interrupts(INT_RDA2); 
*
02BC:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
02BE:  BSET.B  94.3
....................    enable_interrupts(GLOBAL); 
02C0:  BCLR.B  81.7
02C2:  CLR     42
02C4:  BSET.B  81.7
02C6:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
