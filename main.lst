CCS PCD C Compiler, Version 5.008, 5967               09-Nov-22 21:34

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4268 bytes (10%)
                           Largest free fragment is 39764
               RAM used:   3541 (22%) at main() level
                           3613 (22%) worst case
               Stack used: 84 locations (50 in main + 34 for interrupts)
               Stack size: 30

*
0000:  GOTO    EB2
*
001A:  DATA    A4,06,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    66,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
0290:  MOV     W5,[W15++]
0292:  MOV     #C,W5
0294:  REPEAT  #3
0296:  MOV     [W5++],[W15++]
0298:  MUL.UU  W0,W2,W4
029A:  BTSS    W3.F
029C:  BRA     2A2
029E:  MUL.SS  W0,W3,W6
02A0:  BRA     2A4
02A2:  MUL.UU  W0,W3,W6
02A4:  BCLR.B  42.0
02A6:  ADD     W6,W5,W5
02A8:  ADDC    W7,#0,W8
02AA:  BTSS    W1.F
02AC:  BRA     2B2
02AE:  MUL.SS  W1,W2,W6
02B0:  BRA     2B4
02B2:  MUL.UU  W1,W2,W6
02B4:  ADDC    W6,W5,W5
02B6:  ADDC    W7,W8,W8
02B8:  ADDC    #0,W9
02BA:  MUL.SS  W1,W3,W6
02BC:  ADDC    W6,W8,W8
02BE:  ADDC    W9,W7,W7
02C0:  MOV     W7,W3
02C2:  MOV     W8,W2
02C4:  MOV     W5,W1
02C6:  MOV     W4,W0
02C8:  MOV     #12,W5
02CA:  REPEAT  #3
02CC:  MOV     [--W15],[W5--]
02CE:  MOV     [--W15],W5
02D0:  RETURN  
02D2:  MOV     W5,[W15++]
02D4:  MOV     #C,W5
02D6:  REPEAT  #3
02D8:  MOV     [W5++],[W15++]
02DA:  MOV     W0,W4
02DC:  MOV     W1,W5
02DE:  MOV     W2,W6
02E0:  MOV     W3,W7
02E2:  CLR     W0
02E4:  CLR     W1
02E6:  CLR     W2
02E8:  CLR     W3
02EA:  BCLR    W8.0
02EC:  BTSS    W7.F
02EE:  BRA     2FA
02F0:  BSET    W6.0
02F2:  NEG     W4,W4
02F4:  COM     W5,W5
02F6:  COM     W6,W6
02F8:  COM     W7,W7
02FA:  XOR     W4,W5,W9
02FC:  BRA     NZ,302
02FE:  XOR     W6,W7,W9
0300:  BRA     Z,32A
0302:  MOV     #D6,W1
0304:  BTSC    W2.7
0306:  BRA     31A
0308:  BCLR.B  42.0
030A:  RLC     W4,W4
030C:  RLC     W5,W5
030E:  RLC     W6,W6
0310:  RLC     W7,W7
0312:  RLC     W0,W0
0314:  RLC     W2,W2
0316:  DEC     W1,W1
0318:  BRA     NZ,304
031A:  SWAP    W1
031C:  BCLR.B  42.0
031E:  RRC     W1,W1
0320:  BCLR    W1.F
0322:  BCLR    W2.7
0324:  XOR.B   W2L,W1L,W1L
0326:  BTSC    W6.0
0328:  BSET    W1.F
032A:  MOV     #12,W5
032C:  REPEAT  #3
032E:  MOV     [--W15],[W5--]
0330:  MOV     [--W15],W5
0332:  RETURN  
0334:  MOV     W5,[W15++]
0336:  MOV     #C,W5
0338:  REPEAT  #4
033A:  MOV     [W5++],[W15++]
033C:  MOV     W0,W4
033E:  MOV     W1,W5
0340:  MOV     W3,W7
0342:  MOV     W2,W6
0344:  BCLR.B  42.0
0346:  BCLR.B  42.1
0348:  RLC     W1,W1
034A:  SWAP    W1
034C:  AND     #FF,W1
034E:  CP0     W1
0350:  BRA     Z,3E8
0352:  BCLR.B  42.0
0354:  BCLR.B  42.1
0356:  RLC     W3,W3
0358:  SWAP    W3
035A:  AND     #FF,W3
035C:  CP0     W3
035E:  BRA     Z,3E8
0360:  ZE      W0,W0
0362:  ADD.B   W3L,W1L,W0L
0364:  BRA     C,36E
0366:  SUB     #7F,W0
0368:  BRA     Z,3E8
036A:  BRA     NC,3E8
036C:  BRA     372
036E:  ADD.B   #81,W0L
0370:  BRA     C,3E8
0372:  XOR     W5,W7,W10
0374:  BCLR.B  42.0
0376:  BCLR.B  42.1
0378:  AND     #FF,W5
037A:  BSET    W5.7
037C:  BCLR.B  42.0
037E:  AND     #FF,W7
0380:  BSET    W7.7
0382:  MUL.UU  W4,W6,W2
0384:  MUL.UU  W5,W6,W8
0386:  ADDC    W8,W3,W3
0388:  MOV     W9,W1
038A:  BTSC.B  42.0
038C:  INC     W1,W1
038E:  BCLR.B  42.0
0390:  MUL.UU  W7,W4,W8
0392:  ADDC    W8,W3,W3
0394:  ADDC    W9,W1,W1
0396:  MUL.UU  W5,W7,W8
0398:  ADDC    W8,W1,W1
039A:  INC     W0,W0
039C:  CP0     W1
039E:  BTSC.B  42.1
03A0:  BRA     3A4
03A2:  BRA     3AA
03A4:  CP0     W3
03A6:  BTSC.B  42.1
03A8:  BRA     3B4
03AA:  BTSC    W1.F
03AC:  BRA     3B4
03AE:  RLC     W3,W3
03B0:  RLC     W1,W1
03B2:  DEC     W0,W0
03B4:  MOV     W1,W2
03B6:  BCLR.B  42.0
03B8:  BTSS    W3.7
03BA:  BRA     3CE
03BC:  MOV     #FF00,W7
03BE:  AND     W3,W7,W3
03C0:  ADD     #100,W3
03C2:  ADDC    W2,#0,W2
03C4:  CP0     W2
03C6:  BRA     NZ,3CE
03C8:  CP0     W3
03CA:  BRA     NZ,3CE
03CC:  INC     W0,W0
03CE:  SWAP    W0
03D0:  BCLR.B  42.0
03D2:  BCLR.B  42.1
03D4:  RRC     W0,W1
03D6:  BTSC    W10.F
03D8:  BSET    W1.F
03DA:  BCLR    W2.F
03DC:  SWAP    W2
03DE:  XOR.B   W2L,W1L,W1L
03E0:  SWAP    W3
03E2:  MOV.B   W3L,W2L
03E4:  MOV     W2,W0
03E6:  BRA     3EE
03E8:  MOV     #0,W0
03EA:  MOV     #0,W1
03EC:  BRA     3EE
03EE:  MOV     #14,W5
03F0:  REPEAT  #4
03F2:  MOV     [--W15],[W5--]
03F4:  MOV     [--W15],W5
03F6:  RETURN  
03F8:  MOV     W5,[W15++]
03FA:  MOV     #C,W5
03FC:  REPEAT  #3
03FE:  MOV     [W5++],[W15++]
0400:  CLR     W9
0402:  MOV     #8000,W8
0404:  BTSC.B  43.0
0406:  XOR     W8,W3,W3
0408:  CP0     W0
040A:  BRA     NZ,412
040C:  MOV     #7FFF,W10
040E:  AND     W1,W10,W10
0410:  BTSS.B  42.1
0412:  MOV     W1,W10
0414:  XOR     W3,W10,W11
0416:  MOV     W1,W6
0418:  MOV     W3,W7
041A:  MOV     W3,W12
041C:  BCLR.B  42.1
041E:  BCLR.B  42.0
0420:  RLC     W6,W6
0422:  SWAP    W6
0424:  AND     #FF,W6
0426:  CP0     W6
0428:  BRA     Z,56C
042A:  BCLR.B  42.1
042C:  BCLR.B  42.0
042E:  RLC     W7,W7
0430:  SWAP    W7
0432:  AND     #FF,W7
0434:  CP0     W7
0436:  BRA     Z,576
0438:  BCLR.B  42.1
043A:  BCLR.B  42.0
043C:  CP      W7,W6
043E:  BRA     Z,578
0440:  BRA     N,588
0442:  BCLR    W9.0
0444:  BSET    W9.1
0446:  SUB     W7,W6,W8
0448:  MOV     W7,W6
044A:  AND     #FF,W1
044C:  BSET    W1.7
044E:  AND     #FF,W3
0450:  BSET    W3.7
0452:  MOV     #28,W7
0454:  CP      W7,W8
0456:  BRA     N,47A
0458:  BCLR.B  42.1
045A:  BCLR.B  42.0
045C:  RRC     W1,W1
045E:  RRC     W0,W0
0460:  DEC     W8,W8
0462:  BRA     NZ,458
0464:  BRA     480
0466:  MOV     #28,W7
0468:  CP      W7,W8
046A:  BRA     N,47E
046C:  BCLR.B  42.1
046E:  BCLR.B  42.0
0470:  RRC     W3,W3
0472:  RRC     W2,W2
0474:  DEC     W8,W8
0476:  BRA     NZ,46C
0478:  BRA     498
047A:  MOV     W2,W0
047C:  MOV     W3,W1
047E:  BRA     506
0480:  BTSS    W11.F
0482:  BRA     4A6
0484:  BTSC    W9.4
0486:  MOV     W12,W11
0488:  NEG     W0,W0
048A:  BRA     Z,490
048C:  COM.B   W1L,W1L
048E:  BRA     492
0490:  NEG     W1,W1
0492:  BTSC    W9.4
0494:  BRA     4EC
0496:  BRA     4A6
0498:  BTSS    W11.F
049A:  BRA     4A6
049C:  NEG     W2,W2
049E:  BRA     Z,4A4
04A0:  COM.B   W3L,W3L
04A2:  BRA     4A6
04A4:  NEG     W3,W3
04A6:  AND     #FF,W5
04A8:  BCLR.B  42.1
04AA:  BCLR.B  42.0
04AC:  ADD     W0,W2,W0
04AE:  ADDC.B  W1L,W3L,W1L
04B0:  BTSC.B  42.0
04B2:  BSET    W9.3
04B4:  BTSC    W9.0
04B6:  BRA     4CA
04B8:  BTSC    W9.1
04BA:  BRA     4BE
04BC:  BRA     4D4
04BE:  BTSC    W11.F
04C0:  BRA     4EC
04C2:  BTSC    W9.3
04C4:  BRA     518
04C6:  BSET    W9.6
04C8:  BRA     506
04CA:  BTSC    W11.F
04CC:  BRA     4EC
04CE:  BTSC    W9.3
04D0:  BRA     518
04D2:  BRA     506
04D4:  BCLR    W9.2
04D6:  BTSC    W11.F
04D8:  BRA     4E2
04DA:  MOV     W10,W11
04DC:  BTSC    W9.3
04DE:  BRA     518
04E0:  BRA     54E
04E2:  BSET    W9.4
04E4:  XOR.B   #80,W1L
04E6:  BTSC    W1.7
04E8:  BRA     484
04EA:  MOV     W10,W11
04EC:  AND     #FF,W1
04EE:  IOR      W0,  W1,W7
04F0:  BRA     Z,506
04F2:  BTSC    W1.7
04F4:  BRA     506
04F6:  BCLR.B  42.1
04F8:  BCLR.B  42.0
04FA:  RLC     W0,W0
04FC:  RLC     W1,W1
04FE:  DEC     W6,W6
0500:  BTSC.B  42.1
0502:  BRA     566
0504:  BRA     4F2
0506:  BTSC    W9.0
0508:  MOV     W10,W11
050A:  BTSC    W9.1
050C:  MOV     W12,W11
050E:  BTSS    W9.5
0510:  BRA     546
0512:  BTSC    W10.F
0514:  BSET    W0.8
0516:  BRA     54E
0518:  BSET.B  42.0
051A:  RRC.B   W1L,W1L
051C:  RRC     W0,W0
051E:  BTSC.B  42.0
0520:  BSET    W9.5
0522:  INC     W6,W6
0524:  BRA     Z,566
0526:  BTSS    W9.5
0528:  BRA     53A
052A:  INC     W0,W0
052C:  BRA     NZ,53A
052E:  INC.B   W1L,W1L
0530:  BRA     NZ,53A
0532:  RRC.B   W1L,W1L
0534:  RRC     W0,W0
0536:  INC     W6,W6
0538:  BRA     Z,566
053A:  BTSC    W9.0
053C:  MOV     W10,W11
053E:  BTSC    W9.1
0540:  MOV     W12,W11
0542:  BTSC.B  42.1
0544:  BRA     566
0546:  BTSC    W9.6
0548:  MOV     W10,W11
054A:  BTSC    W9.7
054C:  MOV     W12,W11
054E:  IOR      W0,  W1,W2
0550:  BRA     Z,598
0552:  BCLR    W1.7
0554:  SWAP    W6
0556:  BCLR.B  42.1
0558:  BCLR.B  42.0
055A:  RRC     W6,W6
055C:  XOR     W6,W1,W1
055E:  BSET    W1.F
0560:  BTSS    W11.F
0562:  BCLR    W1.F
0564:  BRA     598
0566:  MOV     #0,W0
0568:  MOV     #0,W1
056A:  BRA     598
056C:  BTSC    W10.F
056E:  XOR     W8,W3,W3
0570:  MOV     W2,W0
0572:  MOV     W3,W1
0574:  BRA     598
0576:  BRA     598
0578:  AND     #FF,W3
057A:  BSET    W3.7
057C:  AND     #FF,W1
057E:  BSET    W1.7
0580:  BTSC    W11.F
0582:  BCLR    W3.7
0584:  BSET    W9.2
0586:  BRA     498
0588:  SUB     W6,W7,W8
058A:  AND     #FF,W1
058C:  BSET    W1.7
058E:  AND     #FF,W3
0590:  BSET    W3.7
0592:  BCLR    W9.1
0594:  BSET    W9.0
0596:  BRA     466
0598:  MOV     #12,W5
059A:  REPEAT  #3
059C:  MOV     [--W15],[W5--]
059E:  MOV     [--W15],W5
05A0:  RETURN  
05A2:  MOV     W0,W2
05A4:  MOV     W1,W3
05A6:  MOV.B   W1L,W0L
05A8:  SWAP    W0
05AA:  BSET    W0.F
05AC:  RLC     W1,W1
05AE:  SWAP    W1
05B0:  ZE      W1,W1
05B2:  MOV     #8E,W4
05B4:  SUB.B   W4L,W1L,W1L
05B6:  BRA     Z,5C4
05B8:  CP0     W0
05BA:  BRA     Z,5C4
05BC:  BCLR.B  42.0
05BE:  RRC     W0,W0
05C0:  DEC     W1,W1
05C2:  BRA     NZ,5B8
05C4:  BTSS    W3.F
05C6:  BRA     5CC
05C8:  NEG     W0,W0
05CA:  BRA     5CC
05CC:  RETURN  
*
0976:  MOV     W5,[W15++]
0978:  MOV     W6,[W15++]
097A:  MOV     W0,W4
097C:  MOV     W1,W5
097E:  CLR     W0
0980:  CLR     W1
0982:  BCLR    W6.0
0984:  BTSS    W5.F
0986:  BRA     994
0988:  BSET    W6.0
098A:  NEG     W4,W4
098C:  BRA     Z,992
098E:  COM     W5,W5
0990:  BRA     994
0992:  NEG     W5,W5
0994:  IOR      W4,  W5,W3
0996:  BRA     Z,9BE
0998:  CLR     W2
099A:  MOV     #B6,W1
099C:  BTSC    W2.7
099E:  BRA     9AE
09A0:  BCLR.B  42.0
09A2:  RLC     W4,W4
09A4:  RLC     W5,W5
09A6:  RLC     W0,W0
09A8:  RLC     W2,W2
09AA:  DEC     W1,W1
09AC:  BRA     NZ,99C
09AE:  SWAP    W1
09B0:  BCLR.B  42.0
09B2:  RRC     W1,W1
09B4:  BCLR    W1.F
09B6:  BCLR    W2.7
09B8:  XOR.B   W2L,W1L,W1L
09BA:  BTSC    W6.0
09BC:  BSET    W1.F
09BE:  MOV     [--W15],W6
09C0:  MOV     [--W15],W5
09C2:  RETURN  
09C4:  MOV     W5,[W15++]
09C6:  MOV     #C,W5
09C8:  REPEAT  #4
09CA:  MOV     [W5++],[W15++]
09CC:  CLR     W9
09CE:  XOR     W1,W3,W9
09D0:  MOV     W1,W6
09D2:  MOV     W0,W5
09D4:  MOV     W3,W8
09D6:  MOV     W2,W7
09D8:  RLC     W1,W1
09DA:  SWAP    W1
09DC:  ZE      W1,W1
09DE:  CP0     W1
09E0:  BRA     Z,A7E
09E2:  RLC     W3,W3
09E4:  SWAP    W3
09E6:  ZE      W3,W3
09E8:  CP0     W3
09EA:  BRA     Z,A7E
09EC:  CLR     W0
09EE:  SUB.B   W1L,W3L,W0L
09F0:  BRA     NC,9F8
09F2:  ADD.B   #7F,W0L
09F4:  BRA     C,A7E
09F6:  BRA     9FE
09F8:  SUB.B   #81,W0L
09FA:  BRA     NC,A7E
09FC:  BRA     Z,A7E
09FE:  MOV     W5,W1
0A00:  MOV     W6,W2
0A02:  BSET    W2.7
0A04:  AND     #FF,W2
0A06:  AND     #FF,W8
0A08:  BSET    W8.7
0A0A:  MOV     #19,W10
0A0C:  CLR     W3
0A0E:  CLR     W4
0A10:  SUB     W1,W7,W1
0A12:  SUBB    W2,W8,W2
0A14:  BRA     N,A1A
0A16:  BRA     C,A20
0A18:  BRA     NZ,A22
0A1A:  ADD     W1,W7,W1
0A1C:  ADDC    W2,W8,W2
0A1E:  BRA     A22
0A20:  BSET    W4.0
0A22:  DEC     W10,W10
0A24:  BRA     Z,A34
0A26:  BCLR.B  42.0
0A28:  RLC     W1,W1
0A2A:  RLC     W2,W2
0A2C:  BCLR.B  42.0
0A2E:  RLC     W4,W4
0A30:  RLC     W3,W3
0A32:  BRA     A10
0A34:  CLR     W10
0A36:  BTSC    W3.8
0A38:  BRA     A3C
0A3A:  BRA     A48
0A3C:  BCLR.B  42.0
0A3E:  RRC     W3,W3
0A40:  BCLR    W3.7
0A42:  RRC     W4,W4
0A44:  RLC     W10,W10
0A46:  BRA     A4C
0A48:  DEC     W0,W0
0A4A:  BRA     Z,A7E
0A4C:  BTSC    W10.F
0A4E:  BRA     NC,A5A
0A50:  RLC     W1,W1
0A52:  RLC     W2,W2
0A54:  SUB     W1,W7,W1
0A56:  SUBB    W2,W8,W2
0A58:  BRA     NC,A6C
0A5A:  INC     W4,W4
0A5C:  BRA     NZ,A6C
0A5E:  INC     W3,W3
0A60:  BRA     NZ,A6C
0A62:  INC     W0,W0
0A64:  BRA     Z,A7E
0A66:  BRA     A6C
0A68:  DEC     W0,W0
0A6A:  BRA     Z,A7E
0A6C:  SWAP    W0
0A6E:  RRC     W0,W1
0A70:  BSET    W1.F
0A72:  BTSS    W9.F
0A74:  BCLR    W1.F
0A76:  BCLR    W3.7
0A78:  XOR.B   W3L,W1L,W1L
0A7A:  MOV     W4,W0
0A7C:  BRA     A84
0A7E:  MOV     #0,W0
0A80:  MOV     #0,W1
0A82:  BRA     A84
0A84:  MOV     #14,W5
0A86:  REPEAT  #4
0A88:  MOV     [--W15],[W5--]
0A8A:  MOV     [--W15],W5
0A8C:  RETURN  
0A8E:  MOV     W8,[W15++]
0A90:  MOV     #12,W8
0A92:  REPEAT  #4
0A94:  MOV     [W8++],[W15++]
0A96:  MOV     #0,W9
0A98:  BTSC.B  43.0
0A9A:  MOV     #1,W9
0A9C:  MOV     W9,[W15++]
0A9E:  CLR     W8
0AA0:  CLR     W9
0AA2:  CLR     W10
0AA4:  CLR     W11
0AA6:  CLR     W12
0AA8:  CLR     W13
0AAA:  MOV     #E,W8
0AAC:  MOV     #0,W9
0AAE:  LNK     #10
0AB0:  MOV     W12,[W14+W8]
0AB2:  DEC2    W8,W8
0AB4:  BRA     NN,AB0
0AB6:  XOR     W4,W5,W8
0AB8:  BRA     NZ,ABE
0ABA:  XOR     W6,W7,W8
0ABC:  BRA     Z,B4E
0ABE:  CLR     W8
0AC0:  CLR     W13
0AC2:  MOV     W13,[W15++]
0AC4:  BTSS    W3.F
0AC6:  BRA     ADC
0AC8:  MOV     [--W15],W13
0ACA:  BSET    W13.F
0ACC:  MOV     W13,[W15++]
0ACE:  COM     W3,W3
0AD0:  COM     W2,W2
0AD2:  COM     W1,W1
0AD4:  NEG     W0,W0
0AD6:  ADDC    W1,#0,W1
0AD8:  ADDC    W2,#0,W2
0ADA:  ADDC    W3,#0,W3
0ADC:  BTSS    W7.F
0ADE:  BRA     AF4
0AE0:  MOV     [--W15],W13
0AE2:  BTG     W13.F
0AE4:  MOV     W13,[W15++]
0AE6:  COM     W7,W7
0AE8:  COM     W6,W6
0AEA:  COM     W5,W5
0AEC:  NEG     W4,W4
0AEE:  ADDC    W5,#0,W5
0AF0:  ADDC    W6,#0,W6
0AF2:  ADDC    W7,#0,W7
0AF4:  MOV     #40,W13
0AF6:  BCLR.B  42.0
0AF8:  RLC     W0,W0
0AFA:  RLC     W1,W1
0AFC:  RLC     W2,W2
0AFE:  RLC     W3,W3
0B00:  RLC     W8,W8
0B02:  RLC     W9,W9
0B04:  RLC     W10,W10
0B06:  RLC     W11,W11
0B08:  CP      W11,W7
0B0A:  BRA     NZ,B16
0B0C:  CPB     W10,W6
0B0E:  BRA     NZ,B16
0B10:  CPB     W9,W5
0B12:  BRA     NZ,B16
0B14:  CPB     W8,W4
0B16:  BRA     NC,B22
0B18:  SUB     W8,W4,W8
0B1A:  SUBB    W9,W5,W9
0B1C:  SUBB    W10,W6,W10
0B1E:  SUBB    W11,W7,W11
0B20:  BSET.B  42.0
0B22:  MOV     W8,[W14]
0B24:  MOV     W9,[W14+#2]
0B26:  MOV     W10,[W14+#4]
0B28:  MOV     W11,[W14+#6]
0B2A:  MOV     [W14+#8],W8
0B2C:  MOV     [W14+#A],W9
0B2E:  MOV     [W14+#C],W10
0B30:  MOV     [W14+#E],W11
0B32:  RLC     W8,W8
0B34:  RLC     W9,W9
0B36:  RLC     W10,W10
0B38:  RLC     W11,W11
0B3A:  MOV     W8,[W14+#8]
0B3C:  MOV     W9,[W14+#A]
0B3E:  MOV     W10,[W14+#C]
0B40:  MOV     W11,[W14+#E]
0B42:  MOV     [W14],W8
0B44:  MOV     [W14+#2],W9
0B46:  MOV     [W14+#4],W10
0B48:  MOV     [W14+#6],W11
0B4A:  DEC     W13,W13
0B4C:  BRA     NZ,AF6
0B4E:  MOV     [W14+#8],W0
0B50:  MOV     [W14+#A],W1
0B52:  MOV     [W14+#C],W2
0B54:  MOV     [W14+#E],W3
0B56:  MOV     [--W15],W13
0B58:  BTSS    W13.F
0B5A:  BRA     B6A
0B5C:  COM     W3,W3
0B5E:  COM     W2,W2
0B60:  COM     W1,W1
0B62:  NEG     W0,W0
0B64:  ADDC    W1,#0,W1
0B66:  ADDC    W2,#0,W2
0B68:  ADDC    W3,#0,W3
0B6A:  ULNK    
0B6C:  BRA     B6E
0B6E:  MOV     [--W15],W9
0B70:  CP0     W9
0B72:  BRA     Z,B7C
0B74:  MOV     W8,W0
0B76:  MOV     W9,W1
0B78:  MOV     W10,W2
0B7A:  MOV     W11,W3
0B7C:  MOV     #1A,W8
0B7E:  REPEAT  #4
0B80:  MOV     [--W15],[W8--]
0B82:  MOV     [--W15],W8
0B84:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
0244:  MOV     W5,[W15++]
0246:  MOV     #4B00,W5
0248:  REPEAT  #19E
024A:  NOP     
024C:  DEC     W5,W5
024E:  BRA     NZ,256
0250:  CLR     85A
0252:  MOV     #0,W0
0254:  BRA     262
0256:  BTSS.B  232.0
0258:  BRA     248
025A:  PUSH    232
025C:  POP     85A
025E:  MOV     236,W0
0260:  BCLR.B  232.1
0262:  MOV     [--W15],W5
0264:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14    
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
.................... unsigned int8 InboundTriggerValue[4]; 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... signed int16  TempInputSamples[2]; 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
.................... FlagType OutputFlag = 0; 
.................... FlagType DMATriggerFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH]; // =  
.................... //!{ 
.................... //!210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... //!-246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... //!368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... //!1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... //!1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... //!368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... //!-246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... //!210 
.................... //! 
.................... //!}; 
.................... //! 
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,961
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0266:  PUSH    42
0268:  PUSH    36
026A:  PUSH    32
026C:  MOV     W0,[W15++]
026E:  MOV     #2,W0
0270:  REPEAT  #C
0272:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
0274:  CALL    244
0278:  MOV.B   W0L,861
....................    UARTRXFlag = 1; 
027A:  MOV.B   #1,W0L
027C:  MOV.B   W0L,1227
.................... } 
....................  
027E:  BCLR.B  87.6
0280:  MOV     #1A,W0
0282:  REPEAT  #C
0284:  MOV     [--W15],[W0--]
0286:  MOV     [--W15],W0
0288:  POP     32
028A:  POP     36
028C:  POP     42
028E:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
*
06A4:  PUSH    42
06A6:  PUSH    36
06A8:  PUSH    32
06AA:  MOV     W0,[W15++]
06AC:  MOV     #2,W0
06AE:  REPEAT  #C
06B0:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); 
06B2:  BCLR.B  2C9.6
06B4:  BTG.B   2CD.6
....................    //read_adc(); 
....................    if(NormalizeFlag == 1) 
06B6:  MOV     1226,W4
06B8:  CP.B    W4L,#1
06BA:  BRA     NZ,6CC
....................    { 
....................       read_adc(); 
06BC:  BCLR.B  320.0
06BE:  BSET.B  320.1
06C0:  BTSS.B  320.0
06C2:  BRA     6C0
....................       NormalizeDataCounter++; 
06C4:  INC     1222
06C6:  BTSC.B  42.1
06C8:  INC     1224
....................    } 
06CA:  BRA     760
....................    else 
....................    { 
....................       unsigned int16 ADCValue = 0; 
06CC:  CLR     12D6
....................        
....................       if (TriggerFlag != 2) 
06CE:  MOV     1228,W4
06D0:  LSR     W4,#8,W4
06D2:  CP.B    W4L,#2
06D4:  BRA     Z,6EA
....................       { 
....................           ADCValue = QuickDigitize(read_adc()); 
06D6:  BCLR.B  320.0
06D8:  BSET.B  320.1
06DA:  BTSS.B  320.0
06DC:  BRA     6DA
06DE:  MOV     300,W5
06E0:  MOV     W5,12DC
06E2:  CALL    5CE
06E6:  MOV.B   W0L,12D6
06E8:  CLR.B   12D7
....................       } 
....................        
....................       if (DMAFlag == 0) 
06EA:  CP0.B   122A
06EC:  BRA     NZ,6FC
....................       { 
....................          disable_interrupts(INT_DMA0); 
06EE:  BCLR.B  94.4
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
06F0:  MOV     #4000,W1
06F2:  MOV     #0,W2
06F4:  REPEAT  #1FD
06F6:  CLR.B   [W1++]
....................          DMAFlag = 1; 
06F8:  MOV.B   #1,W0L
06FA:  MOV.B   W0L,122A
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
06FC:  MOV     12D6,W0
06FE:  CP      96A
0700:  BRA     NZ,710
0702:  CP0.B   1229
0704:  BRA     NZ,710
....................       { 
....................          TempInputSamples[0] = ADCValue; 
0706:  PUSH    12D6
0708:  POP     11FA
....................          TriggerFlag = 1; 
070A:  MOV.B   #1,W0L
070C:  MOV.B   W0L,1229
....................       } 
070E:  BRA     760
....................       else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) 
0710:  MOV     11FA,W0
0712:  MOV     12D6,W4
0714:  CP      W4,W0
0716:  BRA     LE,72A
0718:  MOV     1228,W4
071A:  LSR     W4,#8,W4
071C:  CP.B    W4L,#1
071E:  BRA     NZ,72A
....................       { 
....................          TempInputSamples[1] = ADCValue; 
0720:  PUSH    12D6
0722:  POP     11FC
....................          TriggerFlag = 2; 
0724:  MOV.B   #2,W0L
0726:  MOV.B   W0L,1229
....................       } 
0728:  BRA     760
....................       else if(TriggerFlag == 2) 
072A:  MOV     1228,W4
072C:  LSR     W4,#8,W4
072E:  CP.B    W4L,#2
0730:  BRA     NZ,75E
....................       { 
....................          if(DMAFlag == 1) 
0732:  MOV     122A,W4
0734:  CP.B    W4L,#1
0736:  BRA     NZ,754
....................          { 
....................             memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0738:  MOV     #4000,W1
073A:  MOV     #0,W2
073C:  REPEAT  #1FD
073E:  CLR.B   [W1++]
....................             dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0740:  BCLR.B  381.7
0742:  CLR.B   380
0744:  MOV     #4000,W4
0746:  MOV     W4,384
0748:  MOV     #FF,W4
074A:  MOV     W4,38A
074C:  BSET.B  381.7
....................             enable_interrupts(INT_DMA0); 
074E:  BSET.B  94.4
....................             DMAFlag = 2; 
0750:  MOV.B   #2,W0L
0752:  MOV.B   W0L,122A
....................          } 
....................           
....................          read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
0754:  BCLR.B  320.0
0756:  BSET.B  320.1
0758:  BTSS.B  320.0
075A:  BRA     758
....................       }   
075C:  BRA     760
....................       else 
....................       { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
....................           
....................          TriggerFlag = 0; 
075E:  CLR.B   1229
....................       } 
....................    } 
0760:  BCLR.B  84.3
0762:  MOV     #1A,W0
0764:  REPEAT  #C
0766:  MOV     [--W15],[W0--]
0768:  MOV     [--W15],W0
076A:  POP     32
076C:  POP     36
076E:  POP     42
0770:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0EB2:  MOV     #4444,W0
0EB4:  MOV     W0,A4
0EB6:  BSET.B  81.7
0EB8:  MOV     #46,W0
0EBA:  MOV.B   W0L,742
0EBC:  MOV     #57,W0
0EBE:  MOV.B   W0L,742
0EC0:  BCLR.B  742.6
0EC2:  MOV     #3F07,W0
0EC4:  MOV     W0,6A6
0EC6:  MOV     #5,W0
0EC8:  MOV     W0,6C6
0ECA:  MOV     #46,W0
0ECC:  MOV.B   W0L,742
0ECE:  MOV     #57,W0
0ED0:  MOV.B   W0L,742
0ED2:  BSET.B  742.6
0ED4:  MOV     #41,W4
0ED6:  MOV     W4,744
0ED8:  MOV     #32,W4
0EDA:  MOV     W4,746
0EDC:  CLR     85A
0EDE:  MOV     #8000,W4
0EE0:  MOV     W4,230
0EE2:  MOV     #400,W4
0EE4:  MOV     W4,232
0EE6:  BSET.B  230.3
0EE8:  MOV     #22,W4
0EEA:  MOV     W4,238
0EEC:  CLR     85E
0EEE:  CLR     968
0EF0:  CLR     96A
0EF2:  CLR     96C
0EF4:  CLR     96E
0EF6:  CLR     970
0EF8:  CLR     116A
0EFA:  CLR     116C
0EFC:  CLR     116E
0EFE:  CLR     1170
0F00:  CLR     1172
0F02:  CLR     1174
0F04:  CLR     1176
0F06:  CLR     1178
0F08:  CLR     1202
0F0A:  CLR     1204
0F0C:  CLR     1206
0F0E:  CLR     1208
0F10:  CLR.B   861
0F12:  CLR     120A
0F14:  CLR     120C
0F16:  CLR     120E
0F18:  CLR     1210
0F1A:  CLR     1212
0F1C:  CLR     1214
0F1E:  CLR     1216
0F20:  CLR     1218
0F22:  CLR     121A
0F24:  CLR     121C
0F26:  CLR     121E
0F28:  CLR     1220
0F2A:  CLR     1222
0F2C:  CLR     1224
0F2E:  CLR.B   961
0F30:  CLR.B   1226
0F32:  CLR.B   1227
0F34:  CLR.B   1228
0F36:  CLR.B   1229
0F38:  CLR.B   122A
0F3A:  CLR.B   122B
0F3C:  CLR.B   122C
0F3E:  MOV     #41,W4
0F40:  MOV     W4,744
0F42:  MOV     #32,W4
0F44:  MOV     W4,746
0F46:  DISI    #E
0F48:  MOV     #101,W0
0F4A:  MOV     #743,W1
0F4C:  MOV     #78,W2
0F4E:  MOV     #9A,W3
0F50:  MOV.B   W2L,[W1]
0F52:  MOV.B   W3L,[W1]
0F54:  MOV.B   W0L,743
0F56:  LSR     W0,#8,W0
0F58:  MOV     #742,W1
0F5A:  MOV     #46,W2
0F5C:  MOV     #57,W3
0F5E:  MOV.B   W2L,[W1]
0F60:  MOV.B   W3L,[W1]
0F62:  MOV.B   W0L,[W1]
0F64:  SETM    32C
0F66:  MOV     #3F80,W15
0F68:  MOV     #3FFF,W0
0F6A:  MOV     W0,20
0F6C:  NOP     
0F6E:  CLR     85C
0F70:  MOV     #3F80,W15
0F72:  MOV     #3FFF,W0
0F74:  MOV     W0,20
0F76:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0F78:  MOV     #4000,W1
0F7A:  MOV     #0,W2
0F7C:  REPEAT  #FE
0F7E:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0F80:  MOV     #41FE,W1
0F82:  MOV     #61,W2
0F84:  MOV.B   #61,W2L
0F86:  REPEAT  #FE
0F88:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0F8A:  CLR.B   381
0F8C:  MOV.B   #D,W0L
0F8E:  MOV.B   W0L,382
0F90:  MOV     #300,W4
0F92:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0F94:  BCLR.B  381.7
0F96:  CLR.B   380
0F98:  MOV     #4000,W4
0F9A:  MOV     W4,384
0F9C:  MOV     #FF,W4
0F9E:  MOV     W4,38A
0FA0:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
0FA2:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0FA4:  MOV     #9F00,W4
0FA6:  MOV     W4,324
0FA8:  MOV     #84E0,W4
0FAA:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0FAC:  MOV     #FFFE,W4
0FAE:  MOV     W4,32C
0FB0:  CLR     322
....................     
....................    read_adc(); 
0FB2:  BCLR.B  320.0
0FB4:  BSET.B  320.1
0FB6:  BTSS.B  320.0
0FB8:  BRA     FB6
....................     
....................    //TimerTicks = 53334; 
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0FBA:  CLR     104
0FBC:  PUSH    85E
0FBE:  POP     102
0FC0:  MOV     #8000,W4
0FC2:  MOV     W4,104
....................    enable_interrupts(INT_RDA2); 
0FC4:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
0FC6:  BSET.B  94.3
....................    enable_interrupts(INTR_GLOBAL); 
0FC8:  BCLR.B  81.7
0FCA:  CLR     42
0FCC:  BSET.B  81.7
....................     
....................    NormalizeFlag = 1; 
0FCE:  MOV.B   #1,W0L
0FD0:  MOV.B   W0L,1226
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
0FD2:  CP0.B   961
0FD4:  BRA     NZ,FE0
0FD6:  MOV     1222,W4
0FD8:  XOR     #FF,W4
0FDA:  BRA     NZ,109C
0FDC:  CP0     1224
0FDE:  BRA     NZ,109C
....................       { 
....................          disable_interrupts(INT_DMA0); 
0FE0:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
0FE2:  CLR     12AE
0FE4:  CLR     12B0
0FE6:  MOV     12B0,W4
0FE8:  CP      W4,#0
0FEA:  BRA     GTU,100A
0FEC:  BRA     NC,FF6
0FEE:  MOV     12AE,W4
0FF0:  MOV     #FF,W3
0FF2:  CP      W3,W4
0FF4:  BRA     LEU,100A
....................          { 
....................             AccumulateAnalogData(Index); 
0FF6:  PUSH    12AE
0FF8:  POP     12B8
0FFA:  PUSH    12B0
0FFC:  POP     12BA
0FFE:  CALL    772
1002:  INC     12AE
1004:  BTSC.B  42.1
1006:  INC     12B0
1008:  BRA     FE6
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
100A:  MOV     1226,W4
100C:  CP.B    W4L,#1
100E:  BRA     NZ,1014
....................          { 
....................             NormalizeData(); 
1010:  CALL    B86
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
1014:  MOV     1228,W4
1016:  CP.B    W4L,#1
1018:  BRA     NZ,108C
....................          { 
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
101A:  CLR     12B2
101C:  CLR     12B4
101E:  MOV     12B4,W4
1020:  CP      W4,#0
1022:  BRA     GTU,1048
1024:  BRA     NC,102E
1026:  MOV     12B2,W4
1028:  MOV     #FF,W3
102A:  CP      W3,W4
102C:  BRA     LEU,1048
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
102E:  MOV     #862,W4
1030:  MOV     12B2,W3
1032:  ADD     W3,W4,W0
1034:  MOV.B   [W0],W5L
1036:  BTSC.B  233.1
1038:  BRA     1036
103A:  PUSH    234
103C:  MOV.B   W5L,[W15-#2]
103E:  POP     234
1040:  INC     12B2
1042:  BTSC.B  42.1
1044:  INC     12B4
1046:  BRA     101E
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
1048:  CLR     12B2
104A:  CLR     12B4
104C:  MOV     12B4,W4
104E:  CP      W4,#0
1050:  BRA     GTU,108C
1052:  BRA     NC,105C
1054:  MOV     12B2,W4
1056:  MOV     #FF,W3
1058:  CP      W3,W4
105A:  BRA     LEU,108C
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
105C:  MOV     #2,W4
105E:  CLR.B   9
1060:  MOV     12B2,W0
1062:  MOV     12B4,W1
1064:  INC     W4,W4
1066:  DEC     W4,W4
1068:  BRA     Z,1070
106A:  SL      W0,W0
106C:  RLC     W1,W1
106E:  BRA     1066
1070:  MOV     #972,W4
1072:  ADD     W0,W4,W0
1074:  MOV     #A,W4
1076:  MOV     [W0++],[W4++]
1078:  MOV     [W0++],[W4++]
107A:  BTSC.B  233.1
107C:  BRA     107A
107E:  PUSH    234
1080:  MOV.B   W5L,[W15-#2]
1082:  POP     234
1084:  INC     12B2
1086:  BTSC.B  42.1
1088:  INC     12B4
108A:  BRA     104C
....................             } 
....................          } 
....................           
....................          NormalizeFlag = 0; 
108C:  CLR.B   1226
....................          HandShakeFlag = 0;    
108E:  CLR.B   1228
....................          CurrentIndex = 0; 
1090:  CLR     1216
1092:  CLR     1218
....................          enable_interrupts(INT_DMA0); 
1094:  BSET.B  94.4
....................          DMADoneFlag = 0; 
1096:  CLR.B   961
....................          TriggerFlag = 0; 
1098:  CLR.B   1229
....................          DMAFlag = 0; 
109A:  CLR.B   122A
....................       }   
....................        
....................       if (UARTRXFlag) 
109C:  CP0.B   1227
109E:  BRA     Z,10A8
....................       { 
....................          CommHandler(UARTRX); 
10A0:  MOV.B   861,W0L
10A2:  MOV.B   W0L,12B8
10A4:  CALL    DAA
....................       }   
10A8:  BRA     FD2
....................    } 
.................... } 
....................  
10AA:  BRA     10AA
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
0772:  MOV     W5,[W15++]
0774:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
0776:  MOV     #1,W4
0778:  CLR.B   9
077A:  MOV     1216,W0
077C:  MOV     1218,W1
077E:  INC     W4,W4
0780:  DEC     W4,W4
0782:  BRA     Z,78A
0784:  SL      W0,W0
0786:  RLC     W1,W1
0788:  BRA     780
078A:  MOV     #117A,W4
078C:  ADD     W0,W4,W5
078E:  MOV     #1,W4
0790:  CLR.B   9
0792:  MOV     12B8,W0
0794:  MOV     12BA,W1
0796:  INC     W4,W4
0798:  DEC     W4,W4
079A:  BRA     Z,7A2
079C:  SL      W0,W0
079E:  RLC     W1,W1
07A0:  BRA     798
07A2:  MOV     #4000,W4
07A4:  ADD     W0,W4,W0
07A6:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
07A8:  PUSH    1216
07AA:  POP     1212
07AC:  PUSH    1218
07AE:  POP     1214
....................    Accumulator = 0; 
07B0:  CLR     96E
07B2:  CLR     970
....................    CoefficentIndex = 0; 
07B4:  CLR     120E
07B6:  CLR     1210
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
07B8:  MOV     1210,W4
07BA:  CP      W4,#0
07BC:  BRA     GTU,84E
07BE:  BRA     NC,7C8
07C0:  MOV     120E,W4
07C2:  MOV     #3F,W3
07C4:  CP      W3,W4
07C6:  BRA     LEU,84E
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
07C8:  MOV     #1,W4
07CA:  CLR.B   9
07CC:  MOV     1212,W0
07CE:  MOV     1214,W1
07D0:  INC     W4,W4
07D2:  DEC     W4,W4
07D4:  BRA     Z,7DC
07D6:  SL      W0,W0
07D8:  RLC     W1,W1
07DA:  BRA     7D2
07DC:  MOV     #117A,W4
07DE:  ADD     W0,W4,W0
07E0:  MOV     W0,W4
07E2:  MOV     [W4],W0
07E4:  MOV     W0,W5
07E6:  CLR     W6
07E8:  BTSC    W5.F
07EA:  SETM    W6
07EC:  MOV     #1,W4
07EE:  CLR.B   9
07F0:  MOV     120E,W0
07F2:  MOV     1210,W1
07F4:  INC     W4,W4
07F6:  DEC     W4,W4
07F8:  BRA     Z,800
07FA:  SL      W0,W0
07FC:  RLC     W1,W1
07FE:  BRA     7F6
0800:  MOV     #122E,W4
0802:  ADD     W0,W4,W0
0804:  MOV     W0,W4
0806:  MOV     [W4],W0
0808:  CLR     W1
080A:  BTSC    W0.F
080C:  SETM    W1
080E:  PUSH    42
0810:  BCLR.B  81.7
0812:  SETM.B  42
0814:  BSET.B  81.7
0816:  MOV     W0,W2
0818:  MOV     W1,W3
081A:  MOV     W5,W0
081C:  MOV     W6,W1
081E:  CALL    290
0822:  BCLR.B  81.7
0824:  POP     42
0826:  BSET.B  81.7
0828:  ADD     96E
082A:  MOV     W1,W0
082C:  ADDC    970,W0
082E:  MOV     W0,970
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
0830:  MOV     1212,W4
0832:  XOR     #3F,W4
0834:  BRA     NZ,840
0836:  CP0     1214
0838:  BRA     NZ,840
....................       { 
....................          InputIndex = 0; 
083A:  CLR     1212
083C:  CLR     1214
....................       } 
083E:  BRA     846
....................       else 
....................       { 
....................          InputIndex++; 
0840:  INC     1212
0842:  BTSC.B  42.1
0844:  INC     1214
....................       } 
....................        
....................       CoefficentIndex++; 
0846:  INC     120E
0848:  BTSC.B  42.1
084A:  INC     1210
084C:  BRA     7B8
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
084E:  MOV     #862,W4
0850:  MOV     12B8,W3
0852:  ADD     W3,W4,W5
0854:  MOV     #1,W4
0856:  CLR.B   9
0858:  MOV     1216,W0
085A:  MOV     1218,W1
085C:  INC     W4,W4
085E:  DEC     W4,W4
0860:  BRA     Z,868
0862:  SL      W0,W0
0864:  RLC     W1,W1
0866:  BRA     85E
0868:  MOV     #117A,W4
086A:  ADD     W0,W4,W0
086C:  MOV     [W0],W6
086E:  LSR     W6,#4,W0
0870:  MOV.B   W0L,[W5]
0872:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
0874:  MOV     1226,W4
0876:  CP.B    W4L,#1
0878:  BRA     NZ,89A
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
087A:  MOV     #2,W4
087C:  CLR.B   9
087E:  MOV     12B8,W0
0880:  MOV     12BA,W1
0882:  INC     W4,W4
0884:  DEC     W4,W4
0886:  BRA     Z,88E
0888:  SL      W0,W0
088A:  RLC     W1,W1
088C:  BRA     884
088E:  MOV     #972,W4
0890:  ADD     W0,W4,W5
0892:  MOV     #96E,W4
0894:  MOV     [W4++],[W5++]
0896:  MOV     [W4++],[W5++]
....................    } 
0898:  BRA     95A
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
089A:  MOV     96E,W0
089C:  MOV     970,W1
089E:  CLR     W3
08A0:  BTSC    W1.F
08A2:  SETM    W3
08A4:  MOV     W3,W2
08A6:  MOV     1172,W4
08A8:  SUB     W0,W4,W0
08AA:  MOV     1174,W4
08AC:  SUBB    W1,W4,W1
08AE:  MOV     1176,W4
08B0:  SUBB    W2,W4,W2
08B2:  MOV     1178,W4
08B4:  SUBB    W3,W4,W3
08B6:  CALL    2D2
08BA:  MOV     W0,12BC
08BC:  MOV     W1,12BE
08BE:  PUSH    42
08C0:  BCLR.B  81.7
08C2:  SETM.B  42
08C4:  BSET.B  81.7
08C6:  MOV     12BC,W0
08C8:  MOV     12BE,W1
08CA:  MOV     1206,W2
08CC:  MOV     1208,W3
08CE:  CALL    334
08D2:  BCLR.B  81.7
08D4:  POP     42
08D6:  BSET.B  81.7
08D8:  MOV     W0,12C0
08DA:  MOV     W1,12C2
08DC:  BCLR.B  43.0
08DE:  PUSH    42
08E0:  BCLR.B  81.7
08E2:  SETM.B  42
08E4:  BSET.B  81.7
08E6:  MOV     12C0,W0
08E8:  MOV     12C2,W1
08EA:  MOV     #0,W2
08EC:  MOV     #42FE,W3
08EE:  CALL    3F8
08F2:  BCLR.B  81.7
08F4:  POP     42
08F6:  BSET.B  81.7
08F8:  MOV     W0,12C4
08FA:  MOV     W1,12C6
....................       //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................       //ConversionValue = (unsigned int8)OutputValue; 
....................       ConversionValue = (unsigned int8)StepThree; 
08FC:  PUSH    42
08FE:  BCLR.B  81.7
0900:  SETM.B  42
0902:  BSET.B  81.7
0904:  MOV     12C4,W0
0906:  MOV     12C6,W1
0908:  CALL    5A2
090C:  BCLR.B  81.7
090E:  POP     42
0910:  BSET.B  81.7
0912:  MOV.B   W0L,860
....................       DebugAccumulator[DMAADCIndex] = Accumulator; 
0914:  MOV     #2,W4
0916:  CLR.B   9
0918:  MOV     12B8,W0
091A:  MOV     12BA,W1
091C:  INC     W4,W4
091E:  DEC     W4,W4
0920:  BRA     Z,928
0922:  SL      W0,W0
0924:  RLC     W1,W1
0926:  BRA     91E
0928:  MOV     #D6E,W4
092A:  ADD     W0,W4,W5
092C:  MOV     #96E,W4
092E:  MOV     [W4++],[W5++]
0930:  MOV     [W4++],[W5++]
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
0932:  MOV     #2,W4
0934:  CLR.B   9
0936:  MOV     12B8,W0
0938:  MOV     12BA,W1
093A:  INC     W4,W4
093C:  DEC     W4,W4
093E:  BRA     Z,946
0940:  SL      W0,W0
0942:  RLC     W1,W1
0944:  BRA     93C
0946:  MOV     #972,W4
0948:  ADD     W0,W4,W5
094A:  MOV     860,W0
094C:  MOV.B   W0L,[W5+#0]
094E:  MOV.B   #0,W0L
0950:  MOV.B   W0L,[W5+#1]
0952:  MOV.B   #0,W0L
0954:  MOV.B   W0L,[W5+#2]
0956:  MOV.B   #0,W0L
0958:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................     if (CurrentIndex == 0) 
095A:  CP0     1216
095C:  BRA     NZ,96A
095E:  CP0     1218
0960:  BRA     NZ,96A
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
0962:  MOV     #3F,W4
0964:  MOV     W4,1216
0966:  CLR     1218
....................    } 
0968:  BRA     970
....................    else 
....................    { 
....................      CurrentIndex--; 
096A:  DEC     1216
096C:  BTSS.B  42.0
096E:  DEC     1218
....................    }  
0970:  MOV     [--W15],W6
0972:  MOV     [--W15],W5
0974:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
0B86:  MOV     W5,[W15++]
0B88:  MOV     W6,[W15++]
0B8A:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0B8C:  MOV     1220,W4
0B8E:  CP      W4,#0
0B90:  BRA     GTU,D30
0B92:  BRA     NC,B9C
0B94:  MOV     121E,W4
0B96:  MOV     #BB8,W3
0B98:  CP      W3,W4
0B9A:  BRA     LEU,D30
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0B9C:  PUSH    A72
0B9E:  POP     116A
0BA0:  PUSH    A74
0BA2:  POP     116C
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0BA4:  PUSH    A72
0BA6:  POP     116E
0BA8:  PUSH    A74
0BAA:  POP     1170
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0BAC:  PUSH    4080
0BAE:  POP     968
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0BB0:  MOV     #41,W4
0BB2:  MOV     W4,12B8
0BB4:  CLR     12BA
0BB6:  MOV     12BA,W4
0BB8:  CP      W4,#0
0BBA:  BRA     GTU,CE0
0BBC:  BRA     NC,BC6
0BBE:  MOV     12B8,W4
0BC0:  MOV     #FF,W3
0BC2:  CP      W3,W4
0BC4:  BRA     LEU,CE0
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0BC6:  MOV     #2,W4
0BC8:  CLR.B   9
0BCA:  MOV     12B8,W0
0BCC:  MOV     12BA,W1
0BCE:  INC     W4,W4
0BD0:  DEC     W4,W4
0BD2:  BRA     Z,BDA
0BD4:  SL      W0,W0
0BD6:  RLC     W1,W1
0BD8:  BRA     BD0
0BDA:  MOV     #972,W4
0BDC:  ADD     W0,W4,W0
0BDE:  MOV     W0,W4
0BE0:  MOV     #0,W3
0BE2:  MOV     [W4++],[W3++]
0BE4:  MOV     [W4++],[W3++]
0BE6:  MOV     1170,W4
0BE8:  CP      W4,W1
0BEA:  BRA     LT,C12
0BEC:  BRA     GT,BF4
0BEE:  MOV     116E,W4
0BF0:  CP      W4,W0
0BF2:  BRA     LEU,C12
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0BF4:  MOV     #2,W4
0BF6:  CLR.B   9
0BF8:  MOV     12B8,W0
0BFA:  MOV     12BA,W1
0BFC:  INC     W4,W4
0BFE:  DEC     W4,W4
0C00:  BRA     Z,C08
0C02:  SL      W0,W0
0C04:  RLC     W1,W1
0C06:  BRA     BFE
0C08:  MOV     #972,W4
0C0A:  ADD     W0,W4,W0
0C0C:  MOV     #116E,W4
0C0E:  MOV     [W0++],[W4++]
0C10:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0C12:  MOV     #2,W4
0C14:  CLR.B   9
0C16:  MOV     12B8,W0
0C18:  MOV     12BA,W1
0C1A:  INC     W4,W4
0C1C:  DEC     W4,W4
0C1E:  BRA     Z,C26
0C20:  SL      W0,W0
0C22:  RLC     W1,W1
0C24:  BRA     C1C
0C26:  MOV     #972,W4
0C28:  ADD     W0,W4,W0
0C2A:  MOV     W0,W4
0C2C:  MOV     #0,W3
0C2E:  MOV     [W4++],[W3++]
0C30:  MOV     [W4++],[W3++]
0C32:  MOV     116C,W4
0C34:  CP      W4,W1
0C36:  BRA     GT,C5E
0C38:  BRA     LT,C40
0C3A:  MOV     116A,W4
0C3C:  CP      W4,W0
0C3E:  BRA     C,C5E
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0C40:  MOV     #2,W4
0C42:  CLR.B   9
0C44:  MOV     12B8,W0
0C46:  MOV     12BA,W1
0C48:  INC     W4,W4
0C4A:  DEC     W4,W4
0C4C:  BRA     Z,C54
0C4E:  SL      W0,W0
0C50:  RLC     W1,W1
0C52:  BRA     C4A
0C54:  MOV     #972,W4
0C56:  ADD     W0,W4,W0
0C58:  MOV     #116A,W4
0C5A:  MOV     [W0++],[W4++]
0C5C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0C5E:  MOV     #1,W4
0C60:  CLR.B   9
0C62:  MOV     12B8,W0
0C64:  MOV     12BA,W1
0C66:  INC     W4,W4
0C68:  DEC     W4,W4
0C6A:  BRA     Z,C72
0C6C:  SL      W0,W0
0C6E:  RLC     W1,W1
0C70:  BRA     C68
0C72:  MOV     #4000,W4
0C74:  ADD     W0,W4,W0
0C76:  MOV     W0,W4
0C78:  MOV     [W4],W0
0C7A:  MOV     968,W4
0C7C:  CP      W4,W0
0C7E:  BRA     LEU,C9C
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0C80:  MOV     #1,W4
0C82:  CLR.B   9
0C84:  MOV     12B8,W0
0C86:  MOV     12BA,W1
0C88:  INC     W4,W4
0C8A:  DEC     W4,W4
0C8C:  BRA     Z,C94
0C8E:  SL      W0,W0
0C90:  RLC     W1,W1
0C92:  BRA     C8A
0C94:  MOV     #4000,W4
0C96:  ADD     W0,W4,W0
0C98:  MOV     [W0],[W15++]
0C9A:  POP     968
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0C9C:  MOV     #2,W4
0C9E:  CLR.B   9
0CA0:  MOV     12B8,W0
0CA2:  MOV     12BA,W1
0CA4:  INC     W4,W4
0CA6:  DEC     W4,W4
0CA8:  BRA     Z,CB0
0CAA:  SL      W0,W0
0CAC:  RLC     W1,W1
0CAE:  BRA     CA6
0CB0:  MOV     #972,W4
0CB2:  ADD     W0,W4,W0
0CB4:  MOV     W0,W4
0CB6:  MOV     #0,W3
0CB8:  MOV     [W4++],[W3++]
0CBA:  MOV     [W4++],[W3++]
0CBC:  CLR     W3
0CBE:  BTSC    W1.F
0CC0:  SETM    W3
0CC2:  MOV     W3,W2
0CC4:  ADD     1172
0CC6:  MOV     W1,W0
0CC8:  ADDC    1174,W0
0CCA:  MOV     W0,1174
0CCC:  MOV     1176,W4
0CCE:  ADDC    W2,W4,W0
0CD0:  MOV     W0,1176
0CD2:  MOV     1178,W4
0CD4:  ADDC    W3,W4,W0
0CD6:  MOV     W0,1178
0CD8:  INC     12B8
0CDA:  BTSC.B  42.1
0CDC:  INC     12BA
0CDE:  BRA     BB6
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0CE0:  MOV     116A,W4
0CE2:  MOV     116E,W3
0CE4:  SUB     W4,W3,W0
0CE6:  MOV     116C,W4
0CE8:  MOV     1170,W3
0CEA:  SUBB    W4,W3,W1
0CEC:  CALL    976
0CF0:  MOV     W0,1202
0CF2:  MOV     W1,1204
....................       AverageMultiplier = (255.0/ AverageDivider); 
0CF4:  MOV     #0,W0
0CF6:  MOV     #437F,W1
0CF8:  MOV     1202,W2
0CFA:  MOV     1204,W3
0CFC:  CALL    9C4
0D00:  MOV     W0,1206
0D02:  MOV     W1,1208
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0D04:  BCLR.B  43.0
0D06:  MOV     1172,W0
0D08:  MOV     1174,W1
0D0A:  MOV     1176,W2
0D0C:  MOV     1178,W3
0D0E:  MOV     #BF,W4
0D10:  MOV     #0,W5
0D12:  MOV     #0,W6
0D14:  MOV     #0,W7
0D16:  CALL    A8E
0D1A:  MOV     W0,1172
0D1C:  MOV     W1,1174
0D1E:  MOV     W2,1176
0D20:  MOV     W3,1178
....................        
....................       TriggerValue = InitialTriggerValue; 
0D22:  PUSH    968
0D24:  POP     96A
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0D26:  MOV     #972,W1
0D28:  MOV     #0,W2
0D2A:  REPEAT  #1FD
0D2C:  CLR.B   [W1++]
....................    }   
0D2E:  BRA     D98
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0D30:  PUSH    4080
0D32:  POP     968
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0D34:  MOV     #41,W4
0D36:  MOV     W4,12BC
0D38:  CLR     12BE
0D3A:  MOV     12BE,W4
0D3C:  CP      W4,#0
0D3E:  BRA     GTU,D90
0D40:  BRA     NC,D4A
0D42:  MOV     12BC,W4
0D44:  MOV     #FF,W3
0D46:  CP      W3,W4
0D48:  BRA     LEU,D90
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0D4A:  MOV     #1,W4
0D4C:  CLR.B   9
0D4E:  MOV     12BC,W0
0D50:  MOV     12BE,W1
0D52:  INC     W4,W4
0D54:  DEC     W4,W4
0D56:  BRA     Z,D5E
0D58:  SL      W0,W0
0D5A:  RLC     W1,W1
0D5C:  BRA     D54
0D5E:  MOV     #4000,W4
0D60:  ADD     W0,W4,W0
0D62:  MOV     W0,W4
0D64:  MOV     [W4],W0
0D66:  MOV     968,W4
0D68:  CP      W4,W0
0D6A:  BRA     LEU,D88
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0D6C:  MOV     #1,W4
0D6E:  CLR.B   9
0D70:  MOV     12BC,W0
0D72:  MOV     12BE,W1
0D74:  INC     W4,W4
0D76:  DEC     W4,W4
0D78:  BRA     Z,D80
0D7A:  SL      W0,W0
0D7C:  RLC     W1,W1
0D7E:  BRA     D76
0D80:  MOV     #4000,W4
0D82:  ADD     W0,W4,W0
0D84:  MOV     [W0],[W15++]
0D86:  POP     968
....................         }              
0D88:  INC     12BC
0D8A:  BTSC.B  42.1
0D8C:  INC     12BE
0D8E:  BRA     D3A
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0D90:  PUSH    968
0D92:  POP     96A
....................       ErrorCounter = 0;  
0D94:  CLR     121E
0D96:  CLR     1220
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0D98:  CLR     1222
0D9A:  CLR     1224
....................    NormalizeFlag = 0; 
0D9C:  CLR.B   1226
....................    CurrentIndex = 0; 
0D9E:  CLR     1216
0DA0:  CLR     1218
0DA2:  MOV     [--W15],W7
0DA4:  MOV     [--W15],W6
0DA6:  MOV     [--W15],W5
0DA8:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
*
05CE:  MOV     W5,[W15++]
05D0:  MOV     W6,[W15++]
.................... { 
....................     InputIndex = CurrentIndex; 
05D2:  PUSH    1216
05D4:  POP     1212
05D6:  PUSH    1218
05D8:  POP     1214
....................     CoefficentIndex = 0; 
05DA:  CLR     120E
05DC:  CLR     1210
....................     Accumulator = 0; 
05DE:  CLR     96E
05E0:  CLR     970
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
05E2:  MOV     1210,W4
05E4:  CP      W4,#0
05E6:  BRA     GTU,64A
05E8:  BRA     NC,5F2
05EA:  MOV     120E,W4
05EC:  MOV     #3F,W3
05EE:  CP      W3,W4
05F0:  BRA     LEU,64A
....................       { 
....................          Accumulator += (signed int32)ADCValue * (signed int32)fir_coef[CoefficentIndex]; 
05F2:  MOV     12DC,W5
05F4:  MOV     #0,W6
05F6:  MOV     #1,W4
05F8:  CLR.B   9
05FA:  MOV     120E,W0
05FC:  MOV     1210,W1
05FE:  INC     W4,W4
0600:  DEC     W4,W4
0602:  BRA     Z,60A
0604:  SL      W0,W0
0606:  RLC     W1,W1
0608:  BRA     600
060A:  MOV     #122E,W4
060C:  ADD     W0,W4,W0
060E:  MOV     W0,W4
0610:  MOV     [W4],W0
0612:  CLR     W1
0614:  BTSC    W0.F
0616:  SETM    W1
0618:  MOV     W0,W2
061A:  MOV     W1,W3
061C:  MOV     W5,W0
061E:  MOV     W6,W1
0620:  CALL    290
0624:  ADD     96E
0626:  MOV     W1,W0
0628:  ADDC    970,W0
062A:  MOV     W0,970
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
062C:  MOV     1212,W4
062E:  XOR     #3F,W4
0630:  BRA     NZ,63C
0632:  CP0     1214
0634:  BRA     NZ,63C
....................          { 
....................             InputIndex = 0; 
0636:  CLR     1212
0638:  CLR     1214
....................          } 
063A:  BRA     642
....................          else 
....................          { 
....................             InputIndex++; 
063C:  INC     1212
063E:  BTSC.B  42.1
0640:  INC     1214
....................          } 
....................          CoefficentIndex++; 
0642:  INC     120E
0644:  BTSC.B  42.1
0646:  INC     1210
0648:  BRA     5E2
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
064A:  MOV     96E,W0
064C:  MOV     970,W1
064E:  CLR     W3
0650:  BTSC    W1.F
0652:  SETM    W3
0654:  MOV     W3,W2
0656:  MOV     1172,W4
0658:  SUB     W0,W4,W0
065A:  MOV     1174,W4
065C:  SUBB    W1,W4,W1
065E:  MOV     1176,W4
0660:  SUBB    W2,W4,W2
0662:  MOV     1178,W4
0664:  SUBB    W3,W4,W3
0666:  CALL    2D2
066A:  MOV     W0,12DE
066C:  MOV     W1,12E0
066E:  MOV     12DE,W0
0670:  MOV     12E0,W1
0672:  MOV     1206,W2
0674:  MOV     1208,W3
0676:  CALL    334
067A:  MOV     W0,12E2
067C:  MOV     W1,12E4
067E:  BCLR.B  43.0
0680:  MOV     12E2,W0
0682:  MOV     12E4,W1
0684:  MOV     #0,W2
0686:  MOV     #42FE,W3
0688:  CALL    3F8
068C:  MOV     W0,12E6
068E:  MOV     W1,12E8
0690:  MOV     12E6,W0
0692:  MOV     12E8,W1
0694:  CALL    5A2
0698:  MOV.B   W0L,12EA
....................        
....................     return ConversionValue;   
069A:  MOV.B   12EA,W0L
069C:  MOV.B   W0L,0
069E:  MOV     [--W15],W6
06A0:  MOV     [--W15],W5
06A2:  RETURN  
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0DAA:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0DAC:  MOV.B   12B8,W0L
0DAE:  CLR.B   1
0DB0:  XOR     #2B,W0
0DB2:  BRA     Z,DC2
0DB4:  XOR     #1,W0
0DB6:  BRA     Z,DC8
0DB8:  XOR     #6E,W0
0DBA:  BRA     Z,DCC
0DBC:  XOR     #8,W0
0DBE:  BRA     Z,DDE
0DC0:  BRA     EAA
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0DC2:  MOV.B   #1,W0L
0DC4:  MOV.B   W0L,1228
....................          break; 
0DC6:  BRA     EAA
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0DC8:  BCLR.B  94.3
....................          break; 
0DCA:  BRA     EAA
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0DCC:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0DCE:  CLR     104
0DD0:  PUSH    85E
0DD2:  POP     102
0DD4:  MOV     #8000,W4
0DD6:  MOV     W4,104
....................          HandshakeFlag = 1;   
0DD8:  MOV.B   #1,W0L
0DDA:  MOV.B   W0L,1228
....................          break;  
0DDC:  BRA     EAA
....................                       
....................       case 'L': 
....................          disable_interrupts(INT_TIMER1); 
0DDE:  BCLR.B  94.3
....................          disable_interrupts(INT_RDA2); 
0DE0:  BCLR.B  97.6
....................          disable_interrupts(GLOBAL);  
0DE2:  BCLR.B  81.7
0DE4:  MOV     #E0,W4
0DE6:  MOV     W4,42
0DE8:  BSET.B  81.7
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0DEA:  MOV     #122E,W1
0DEC:  MOV     #0,W2
0DEE:  REPEAT  #7F
0DF0:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0DF2:  MOV     120A,W4
0DF4:  XOR     #40,W4
0DF6:  BRA     NZ,DFC
0DF8:  CP0     120C
0DFA:  BRA     Z,E70
....................          { 
....................             if (kbhit(SHARP)) 
0DFC:  BTSS.B  232.0
0DFE:  BRA     E6E
0E00:  PUSH    42
0E02:  BCLR.B  81.7
0E04:  SETM.B  42
0E06:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0E08:  CALL    244
0E0C:  BCLR.B  81.7
0E0E:  POP     42
0E10:  BSET.B  81.7
0E12:  MOV.B   W0L,12B9
....................                 
....................                if (CoefficentByte == 'L') 
0E14:  MOV     12B8,W4
0E16:  LSR     W4,#8,W4
0E18:  XOR.B   #4C,W4L
0E1A:  BRA     NZ,E1E
....................                { 
....................                   ; // Do nothing 
....................                }               
0E1C:  BRA     E6E
....................                else if (NumberCSharpByteRecieved == 0) 
0E1E:  CP0     121A
0E20:  BRA     NZ,E32
0E22:  CP0     121C
0E24:  BRA     NZ,E32
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0E26:  MOV.B   12B9,W0L
0E28:  MOV.B   W0L,962
....................                   NumberCSharpByteRecieved = 1; 
0E2A:  MOV     #1,W4
0E2C:  MOV     W4,121A
0E2E:  CLR     121C
....................                }            
0E30:  BRA     E6E
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0E32:  MOV.B   12B9,W0L
0E34:  MOV.B   W0L,963
....................                   NumberCSharpByteRecieved = 0; 
0E36:  CLR     121A
0E38:  CLR     121C
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0E3A:  MOV.B   963,W0L
0E3C:  MOV.B   W0L,W5L
0E3E:  CLR.B   B
0E40:  MOV.B   W5L,W0L
0E42:  MOV.B   W0L,B
0E44:  CLR.B   W5
0E46:  MOV     W5,W0
0E48:  IOR     962,W0
0E4A:  MOV     W0,96C
....................                   fir_coef[CSharpCoefficentRecieved] =  ByteConversionResult; 
0E4C:  MOV     #1,W4
0E4E:  CLR.B   9
0E50:  MOV     120A,W0
0E52:  MOV     120C,W1
0E54:  INC     W4,W4
0E56:  DEC     W4,W4
0E58:  BRA     Z,E60
0E5A:  SL      W0,W0
0E5C:  RLC     W1,W1
0E5E:  BRA     E56
0E60:  MOV     #122E,W4
0E62:  ADD     W0,W4,W5
0E64:  MOV     96C,W4
0E66:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0E68:  INC     120A
0E6A:  BTSC.B  42.1
0E6C:  INC     120C
....................                } 
....................             } 
0E6E:  BRA     DF2
....................          } 
....................           
....................          switch (fir_coef[0]) 
0E70:  MOV     122E,W0
0E72:  XOR     #D2,W0
0E74:  BRA     Z,E80
0E76:  XOR     #FA,W0
0E78:  BRA     Z,E86
0E7A:  XOR     #149,W0
0E7C:  BRA     Z,E8C
0E7E:  BRA     E92
....................          { 
....................          case 210: 
....................             TimerTicks = 53334; 
0E80:  MOV     #D056,W4
0E82:  MOV     W4,85E
....................             break; 
0E84:  BRA     E96
....................          case 40: 
....................             TimerTicks = 53334; 
0E86:  MOV     #D056,W4
0E88:  MOV     W4,85E
....................             break; 
0E8A:  BRA     E96
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0E8C:  MOV     #1F40,W4
0E8E:  MOV     W4,85E
....................             break; 
0E90:  BRA     E96
....................          default:  
....................             TimerTicks = 8000; 
0E92:  MOV     #1F40,W4
0E94:  MOV     W4,85E
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0E96:  CLR     120A
0E98:  CLR     120C
....................          HandshakeFlag = 1; 
0E9A:  MOV.B   #1,W0L
0E9C:  MOV.B   W0L,1228
....................          enable_interrupts(INT_RDA2); 
0E9E:  BSET.B  97.6
....................          enable_interrupts(INT_TIMER1); 
0EA0:  BSET.B  94.3
....................          enable_interrupts(GLOBAL); 
0EA2:  BCLR.B  81.7
0EA4:  CLR     42
0EA6:  BSET.B  81.7
....................          break; 
0EA8:  BRA     EAA
....................           
.................... //!      case '%': 
.................... //!      disable_interrupts(INT_TIMER1); 
.................... //!      disable_interrupts(INT_RDA2); 
.................... //!      disable_interrupts(GLOBAL);  
.................... //!       
.................... //!      IndexType DataLength = CharToInt(fgetc(SHARP)); 
.................... //!      IndexType DataCounter = 0; 
.................... //!       
.................... //!      while(DataCounter != DataLength) 
.................... //!      { 
.................... //!         InboundTriggerValue[DataCounter] = CharToInt(fgetc(SHARP)); 
.................... //!         DataCounter++; 
.................... //!      } 
.................... //!      break; 
....................           
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0EAA:  CLR.B   12B8
....................    UARTRXFlag = 0; 
0EAC:  CLR.B   1227
0EAE:  MOV     [--W15],W5
0EB0:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
