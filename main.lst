CCS PCD C Compiler, Version 5.008, 5967               20-Nov-22 19:53

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4600 bytes (10%)
                           Largest free fragment is 39432
               RAM used:   3537 (22%) at main() level
                           3611 (22%) worst case
               Stack used: 90 locations (56 in main + 34 for interrupts)
               Stack size: 30

*
0000:  GOTO    FF0
*
001A:  DATA    00,07,00
001C:  DATA    00,02,00
*
0030:  DATA    2E,02,00
*
0050:  DATA    70,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
029A:  MOV     W5,[W15++]
029C:  MOV     #C,W5
029E:  REPEAT  #3
02A0:  MOV     [W5++],[W15++]
02A2:  MUL.UU  W0,W2,W4
02A4:  BTSS    W3.F
02A6:  BRA     2AC
02A8:  MUL.SS  W0,W3,W6
02AA:  BRA     2AE
02AC:  MUL.UU  W0,W3,W6
02AE:  BCLR.B  42.0
02B0:  ADD     W6,W5,W5
02B2:  ADDC    W7,#0,W8
02B4:  BTSS    W1.F
02B6:  BRA     2BC
02B8:  MUL.SS  W1,W2,W6
02BA:  BRA     2BE
02BC:  MUL.UU  W1,W2,W6
02BE:  ADDC    W6,W5,W5
02C0:  ADDC    W7,W8,W8
02C2:  ADDC    #0,W9
02C4:  MUL.SS  W1,W3,W6
02C6:  ADDC    W6,W8,W8
02C8:  ADDC    W9,W7,W7
02CA:  MOV     W7,W3
02CC:  MOV     W8,W2
02CE:  MOV     W5,W1
02D0:  MOV     W4,W0
02D2:  MOV     #12,W5
02D4:  REPEAT  #3
02D6:  MOV     [--W15],[W5--]
02D8:  MOV     [--W15],W5
02DA:  RETURN  
02DC:  MOV     W5,[W15++]
02DE:  MOV     #C,W5
02E0:  REPEAT  #3
02E2:  MOV     [W5++],[W15++]
02E4:  MOV     W0,W4
02E6:  MOV     W1,W5
02E8:  MOV     W2,W6
02EA:  MOV     W3,W7
02EC:  CLR     W0
02EE:  CLR     W1
02F0:  CLR     W2
02F2:  CLR     W3
02F4:  BCLR    W8.0
02F6:  BTSS    W7.F
02F8:  BRA     304
02FA:  BSET    W6.0
02FC:  NEG     W4,W4
02FE:  COM     W5,W5
0300:  COM     W6,W6
0302:  COM     W7,W7
0304:  XOR     W4,W5,W9
0306:  BRA     NZ,30C
0308:  XOR     W6,W7,W9
030A:  BRA     Z,334
030C:  MOV     #D6,W1
030E:  BTSC    W2.7
0310:  BRA     324
0312:  BCLR.B  42.0
0314:  RLC     W4,W4
0316:  RLC     W5,W5
0318:  RLC     W6,W6
031A:  RLC     W7,W7
031C:  RLC     W0,W0
031E:  RLC     W2,W2
0320:  DEC     W1,W1
0322:  BRA     NZ,30E
0324:  SWAP    W1
0326:  BCLR.B  42.0
0328:  RRC     W1,W1
032A:  BCLR    W1.F
032C:  BCLR    W2.7
032E:  XOR.B   W2L,W1L,W1L
0330:  BTSC    W6.0
0332:  BSET    W1.F
0334:  MOV     #12,W5
0336:  REPEAT  #3
0338:  MOV     [--W15],[W5--]
033A:  MOV     [--W15],W5
033C:  RETURN  
033E:  MOV     W5,[W15++]
0340:  MOV     #C,W5
0342:  REPEAT  #4
0344:  MOV     [W5++],[W15++]
0346:  MOV     W0,W4
0348:  MOV     W1,W5
034A:  MOV     W3,W7
034C:  MOV     W2,W6
034E:  BCLR.B  42.0
0350:  BCLR.B  42.1
0352:  RLC     W1,W1
0354:  SWAP    W1
0356:  AND     #FF,W1
0358:  CP0     W1
035A:  BRA     Z,3F2
035C:  BCLR.B  42.0
035E:  BCLR.B  42.1
0360:  RLC     W3,W3
0362:  SWAP    W3
0364:  AND     #FF,W3
0366:  CP0     W3
0368:  BRA     Z,3F2
036A:  ZE      W0,W0
036C:  ADD.B   W3L,W1L,W0L
036E:  BRA     C,378
0370:  SUB     #7F,W0
0372:  BRA     Z,3F2
0374:  BRA     NC,3F2
0376:  BRA     37C
0378:  ADD.B   #81,W0L
037A:  BRA     C,3F2
037C:  XOR     W5,W7,W10
037E:  BCLR.B  42.0
0380:  BCLR.B  42.1
0382:  AND     #FF,W5
0384:  BSET    W5.7
0386:  BCLR.B  42.0
0388:  AND     #FF,W7
038A:  BSET    W7.7
038C:  MUL.UU  W4,W6,W2
038E:  MUL.UU  W5,W6,W8
0390:  ADDC    W8,W3,W3
0392:  MOV     W9,W1
0394:  BTSC.B  42.0
0396:  INC     W1,W1
0398:  BCLR.B  42.0
039A:  MUL.UU  W7,W4,W8
039C:  ADDC    W8,W3,W3
039E:  ADDC    W9,W1,W1
03A0:  MUL.UU  W5,W7,W8
03A2:  ADDC    W8,W1,W1
03A4:  INC     W0,W0
03A6:  CP0     W1
03A8:  BTSC.B  42.1
03AA:  BRA     3AE
03AC:  BRA     3B4
03AE:  CP0     W3
03B0:  BTSC.B  42.1
03B2:  BRA     3BE
03B4:  BTSC    W1.F
03B6:  BRA     3BE
03B8:  RLC     W3,W3
03BA:  RLC     W1,W1
03BC:  DEC     W0,W0
03BE:  MOV     W1,W2
03C0:  BCLR.B  42.0
03C2:  BTSS    W3.7
03C4:  BRA     3D8
03C6:  MOV     #FF00,W7
03C8:  AND     W3,W7,W3
03CA:  ADD     #100,W3
03CC:  ADDC    W2,#0,W2
03CE:  CP0     W2
03D0:  BRA     NZ,3D8
03D2:  CP0     W3
03D4:  BRA     NZ,3D8
03D6:  INC     W0,W0
03D8:  SWAP    W0
03DA:  BCLR.B  42.0
03DC:  BCLR.B  42.1
03DE:  RRC     W0,W1
03E0:  BTSC    W10.F
03E2:  BSET    W1.F
03E4:  BCLR    W2.F
03E6:  SWAP    W2
03E8:  XOR.B   W2L,W1L,W1L
03EA:  SWAP    W3
03EC:  MOV.B   W3L,W2L
03EE:  MOV     W2,W0
03F0:  BRA     3F8
03F2:  MOV     #0,W0
03F4:  MOV     #0,W1
03F6:  BRA     3F8
03F8:  MOV     #14,W5
03FA:  REPEAT  #4
03FC:  MOV     [--W15],[W5--]
03FE:  MOV     [--W15],W5
0400:  RETURN  
0402:  MOV     W5,[W15++]
0404:  MOV     #C,W5
0406:  REPEAT  #3
0408:  MOV     [W5++],[W15++]
040A:  CLR     W9
040C:  MOV     #8000,W8
040E:  BTSC.B  43.0
0410:  XOR     W8,W3,W3
0412:  CP0     W0
0414:  BRA     NZ,41C
0416:  MOV     #7FFF,W10
0418:  AND     W1,W10,W10
041A:  BTSS.B  42.1
041C:  MOV     W1,W10
041E:  XOR     W3,W10,W11
0420:  MOV     W1,W6
0422:  MOV     W3,W7
0424:  MOV     W3,W12
0426:  BCLR.B  42.1
0428:  BCLR.B  42.0
042A:  RLC     W6,W6
042C:  SWAP    W6
042E:  AND     #FF,W6
0430:  CP0     W6
0432:  BRA     Z,576
0434:  BCLR.B  42.1
0436:  BCLR.B  42.0
0438:  RLC     W7,W7
043A:  SWAP    W7
043C:  AND     #FF,W7
043E:  CP0     W7
0440:  BRA     Z,580
0442:  BCLR.B  42.1
0444:  BCLR.B  42.0
0446:  CP      W7,W6
0448:  BRA     Z,582
044A:  BRA     N,592
044C:  BCLR    W9.0
044E:  BSET    W9.1
0450:  SUB     W7,W6,W8
0452:  MOV     W7,W6
0454:  AND     #FF,W1
0456:  BSET    W1.7
0458:  AND     #FF,W3
045A:  BSET    W3.7
045C:  MOV     #28,W7
045E:  CP      W7,W8
0460:  BRA     N,484
0462:  BCLR.B  42.1
0464:  BCLR.B  42.0
0466:  RRC     W1,W1
0468:  RRC     W0,W0
046A:  DEC     W8,W8
046C:  BRA     NZ,462
046E:  BRA     48A
0470:  MOV     #28,W7
0472:  CP      W7,W8
0474:  BRA     N,488
0476:  BCLR.B  42.1
0478:  BCLR.B  42.0
047A:  RRC     W3,W3
047C:  RRC     W2,W2
047E:  DEC     W8,W8
0480:  BRA     NZ,476
0482:  BRA     4A2
0484:  MOV     W2,W0
0486:  MOV     W3,W1
0488:  BRA     510
048A:  BTSS    W11.F
048C:  BRA     4B0
048E:  BTSC    W9.4
0490:  MOV     W12,W11
0492:  NEG     W0,W0
0494:  BRA     Z,49A
0496:  COM.B   W1L,W1L
0498:  BRA     49C
049A:  NEG     W1,W1
049C:  BTSC    W9.4
049E:  BRA     4F6
04A0:  BRA     4B0
04A2:  BTSS    W11.F
04A4:  BRA     4B0
04A6:  NEG     W2,W2
04A8:  BRA     Z,4AE
04AA:  COM.B   W3L,W3L
04AC:  BRA     4B0
04AE:  NEG     W3,W3
04B0:  AND     #FF,W5
04B2:  BCLR.B  42.1
04B4:  BCLR.B  42.0
04B6:  ADD     W0,W2,W0
04B8:  ADDC.B  W1L,W3L,W1L
04BA:  BTSC.B  42.0
04BC:  BSET    W9.3
04BE:  BTSC    W9.0
04C0:  BRA     4D4
04C2:  BTSC    W9.1
04C4:  BRA     4C8
04C6:  BRA     4DE
04C8:  BTSC    W11.F
04CA:  BRA     4F6
04CC:  BTSC    W9.3
04CE:  BRA     522
04D0:  BSET    W9.6
04D2:  BRA     510
04D4:  BTSC    W11.F
04D6:  BRA     4F6
04D8:  BTSC    W9.3
04DA:  BRA     522
04DC:  BRA     510
04DE:  BCLR    W9.2
04E0:  BTSC    W11.F
04E2:  BRA     4EC
04E4:  MOV     W10,W11
04E6:  BTSC    W9.3
04E8:  BRA     522
04EA:  BRA     558
04EC:  BSET    W9.4
04EE:  XOR.B   #80,W1L
04F0:  BTSC    W1.7
04F2:  BRA     48E
04F4:  MOV     W10,W11
04F6:  AND     #FF,W1
04F8:  IOR      W0,  W1,W7
04FA:  BRA     Z,510
04FC:  BTSC    W1.7
04FE:  BRA     510
0500:  BCLR.B  42.1
0502:  BCLR.B  42.0
0504:  RLC     W0,W0
0506:  RLC     W1,W1
0508:  DEC     W6,W6
050A:  BTSC.B  42.1
050C:  BRA     570
050E:  BRA     4FC
0510:  BTSC    W9.0
0512:  MOV     W10,W11
0514:  BTSC    W9.1
0516:  MOV     W12,W11
0518:  BTSS    W9.5
051A:  BRA     550
051C:  BTSC    W10.F
051E:  BSET    W0.8
0520:  BRA     558
0522:  BSET.B  42.0
0524:  RRC.B   W1L,W1L
0526:  RRC     W0,W0
0528:  BTSC.B  42.0
052A:  BSET    W9.5
052C:  INC     W6,W6
052E:  BRA     Z,570
0530:  BTSS    W9.5
0532:  BRA     544
0534:  INC     W0,W0
0536:  BRA     NZ,544
0538:  INC.B   W1L,W1L
053A:  BRA     NZ,544
053C:  RRC.B   W1L,W1L
053E:  RRC     W0,W0
0540:  INC     W6,W6
0542:  BRA     Z,570
0544:  BTSC    W9.0
0546:  MOV     W10,W11
0548:  BTSC    W9.1
054A:  MOV     W12,W11
054C:  BTSC.B  42.1
054E:  BRA     570
0550:  BTSC    W9.6
0552:  MOV     W10,W11
0554:  BTSC    W9.7
0556:  MOV     W12,W11
0558:  IOR      W0,  W1,W2
055A:  BRA     Z,5A2
055C:  BCLR    W1.7
055E:  SWAP    W6
0560:  BCLR.B  42.1
0562:  BCLR.B  42.0
0564:  RRC     W6,W6
0566:  XOR     W6,W1,W1
0568:  BSET    W1.F
056A:  BTSS    W11.F
056C:  BCLR    W1.F
056E:  BRA     5A2
0570:  MOV     #0,W0
0572:  MOV     #0,W1
0574:  BRA     5A2
0576:  BTSC    W10.F
0578:  XOR     W8,W3,W3
057A:  MOV     W2,W0
057C:  MOV     W3,W1
057E:  BRA     5A2
0580:  BRA     5A2
0582:  AND     #FF,W3
0584:  BSET    W3.7
0586:  AND     #FF,W1
0588:  BSET    W1.7
058A:  BTSC    W11.F
058C:  BCLR    W3.7
058E:  BSET    W9.2
0590:  BRA     4A2
0592:  SUB     W6,W7,W8
0594:  AND     #FF,W1
0596:  BSET    W1.7
0598:  AND     #FF,W3
059A:  BSET    W3.7
059C:  BCLR    W9.1
059E:  BSET    W9.0
05A0:  BRA     470
05A2:  MOV     #12,W5
05A4:  REPEAT  #3
05A6:  MOV     [--W15],[W5--]
05A8:  MOV     [--W15],W5
05AA:  RETURN  
05AC:  MOV     W0,W2
05AE:  MOV     W1,W3
05B0:  MOV.B   W1L,W0L
05B2:  SWAP    W0
05B4:  BSET    W0.F
05B6:  RLC     W1,W1
05B8:  SWAP    W1
05BA:  ZE      W1,W1
05BC:  MOV     #8E,W4
05BE:  SUB.B   W4L,W1L,W1L
05C0:  BRA     Z,5CE
05C2:  CP0     W0
05C4:  BRA     Z,5CE
05C6:  BCLR.B  42.0
05C8:  RRC     W0,W0
05CA:  DEC     W1,W1
05CC:  BRA     NZ,5C2
05CE:  BTSS    W3.F
05D0:  BRA     5D6
05D2:  NEG     W0,W0
05D4:  BRA     5D6
05D6:  RETURN  
*
09C0:  MOV     W5,[W15++]
09C2:  MOV     W6,[W15++]
09C4:  MOV     W0,W4
09C6:  MOV     W1,W5
09C8:  CLR     W0
09CA:  CLR     W1
09CC:  BCLR    W6.0
09CE:  BTSS    W5.F
09D0:  BRA     9DE
09D2:  BSET    W6.0
09D4:  NEG     W4,W4
09D6:  BRA     Z,9DC
09D8:  COM     W5,W5
09DA:  BRA     9DE
09DC:  NEG     W5,W5
09DE:  IOR      W4,  W5,W3
09E0:  BRA     Z,A08
09E2:  CLR     W2
09E4:  MOV     #B6,W1
09E6:  BTSC    W2.7
09E8:  BRA     9F8
09EA:  BCLR.B  42.0
09EC:  RLC     W4,W4
09EE:  RLC     W5,W5
09F0:  RLC     W0,W0
09F2:  RLC     W2,W2
09F4:  DEC     W1,W1
09F6:  BRA     NZ,9E6
09F8:  SWAP    W1
09FA:  BCLR.B  42.0
09FC:  RRC     W1,W1
09FE:  BCLR    W1.F
0A00:  BCLR    W2.7
0A02:  XOR.B   W2L,W1L,W1L
0A04:  BTSC    W6.0
0A06:  BSET    W1.F
0A08:  MOV     [--W15],W6
0A0A:  MOV     [--W15],W5
0A0C:  RETURN  
0A0E:  MOV     W5,[W15++]
0A10:  MOV     #C,W5
0A12:  REPEAT  #4
0A14:  MOV     [W5++],[W15++]
0A16:  CLR     W9
0A18:  XOR     W1,W3,W9
0A1A:  MOV     W1,W6
0A1C:  MOV     W0,W5
0A1E:  MOV     W3,W8
0A20:  MOV     W2,W7
0A22:  RLC     W1,W1
0A24:  SWAP    W1
0A26:  ZE      W1,W1
0A28:  CP0     W1
0A2A:  BRA     Z,AC8
0A2C:  RLC     W3,W3
0A2E:  SWAP    W3
0A30:  ZE      W3,W3
0A32:  CP0     W3
0A34:  BRA     Z,AC8
0A36:  CLR     W0
0A38:  SUB.B   W1L,W3L,W0L
0A3A:  BRA     NC,A42
0A3C:  ADD.B   #7F,W0L
0A3E:  BRA     C,AC8
0A40:  BRA     A48
0A42:  SUB.B   #81,W0L
0A44:  BRA     NC,AC8
0A46:  BRA     Z,AC8
0A48:  MOV     W5,W1
0A4A:  MOV     W6,W2
0A4C:  BSET    W2.7
0A4E:  AND     #FF,W2
0A50:  AND     #FF,W8
0A52:  BSET    W8.7
0A54:  MOV     #19,W10
0A56:  CLR     W3
0A58:  CLR     W4
0A5A:  SUB     W1,W7,W1
0A5C:  SUBB    W2,W8,W2
0A5E:  BRA     N,A64
0A60:  BRA     C,A6A
0A62:  BRA     NZ,A6C
0A64:  ADD     W1,W7,W1
0A66:  ADDC    W2,W8,W2
0A68:  BRA     A6C
0A6A:  BSET    W4.0
0A6C:  DEC     W10,W10
0A6E:  BRA     Z,A7E
0A70:  BCLR.B  42.0
0A72:  RLC     W1,W1
0A74:  RLC     W2,W2
0A76:  BCLR.B  42.0
0A78:  RLC     W4,W4
0A7A:  RLC     W3,W3
0A7C:  BRA     A5A
0A7E:  CLR     W10
0A80:  BTSC    W3.8
0A82:  BRA     A86
0A84:  BRA     A92
0A86:  BCLR.B  42.0
0A88:  RRC     W3,W3
0A8A:  BCLR    W3.7
0A8C:  RRC     W4,W4
0A8E:  RLC     W10,W10
0A90:  BRA     A96
0A92:  DEC     W0,W0
0A94:  BRA     Z,AC8
0A96:  BTSC    W10.F
0A98:  BRA     NC,AA4
0A9A:  RLC     W1,W1
0A9C:  RLC     W2,W2
0A9E:  SUB     W1,W7,W1
0AA0:  SUBB    W2,W8,W2
0AA2:  BRA     NC,AB6
0AA4:  INC     W4,W4
0AA6:  BRA     NZ,AB6
0AA8:  INC     W3,W3
0AAA:  BRA     NZ,AB6
0AAC:  INC     W0,W0
0AAE:  BRA     Z,AC8
0AB0:  BRA     AB6
0AB2:  DEC     W0,W0
0AB4:  BRA     Z,AC8
0AB6:  SWAP    W0
0AB8:  RRC     W0,W1
0ABA:  BSET    W1.F
0ABC:  BTSS    W9.F
0ABE:  BCLR    W1.F
0AC0:  BCLR    W3.7
0AC2:  XOR.B   W3L,W1L,W1L
0AC4:  MOV     W4,W0
0AC6:  BRA     ACE
0AC8:  MOV     #0,W0
0ACA:  MOV     #0,W1
0ACC:  BRA     ACE
0ACE:  MOV     #14,W5
0AD0:  REPEAT  #4
0AD2:  MOV     [--W15],[W5--]
0AD4:  MOV     [--W15],W5
0AD6:  RETURN  
0AD8:  MOV     W8,[W15++]
0ADA:  MOV     #12,W8
0ADC:  REPEAT  #4
0ADE:  MOV     [W8++],[W15++]
0AE0:  MOV     #0,W9
0AE2:  BTSC.B  43.0
0AE4:  MOV     #1,W9
0AE6:  MOV     W9,[W15++]
0AE8:  CLR     W8
0AEA:  CLR     W9
0AEC:  CLR     W10
0AEE:  CLR     W11
0AF0:  CLR     W12
0AF2:  CLR     W13
0AF4:  MOV     #E,W8
0AF6:  MOV     #0,W9
0AF8:  LNK     #10
0AFA:  MOV     W12,[W14+W8]
0AFC:  DEC2    W8,W8
0AFE:  BRA     NN,AFA
0B00:  XOR     W4,W5,W8
0B02:  BRA     NZ,B08
0B04:  XOR     W6,W7,W8
0B06:  BRA     Z,B98
0B08:  CLR     W8
0B0A:  CLR     W13
0B0C:  MOV     W13,[W15++]
0B0E:  BTSS    W3.F
0B10:  BRA     B26
0B12:  MOV     [--W15],W13
0B14:  BSET    W13.F
0B16:  MOV     W13,[W15++]
0B18:  COM     W3,W3
0B1A:  COM     W2,W2
0B1C:  COM     W1,W1
0B1E:  NEG     W0,W0
0B20:  ADDC    W1,#0,W1
0B22:  ADDC    W2,#0,W2
0B24:  ADDC    W3,#0,W3
0B26:  BTSS    W7.F
0B28:  BRA     B3E
0B2A:  MOV     [--W15],W13
0B2C:  BTG     W13.F
0B2E:  MOV     W13,[W15++]
0B30:  COM     W7,W7
0B32:  COM     W6,W6
0B34:  COM     W5,W5
0B36:  NEG     W4,W4
0B38:  ADDC    W5,#0,W5
0B3A:  ADDC    W6,#0,W6
0B3C:  ADDC    W7,#0,W7
0B3E:  MOV     #40,W13
0B40:  BCLR.B  42.0
0B42:  RLC     W0,W0
0B44:  RLC     W1,W1
0B46:  RLC     W2,W2
0B48:  RLC     W3,W3
0B4A:  RLC     W8,W8
0B4C:  RLC     W9,W9
0B4E:  RLC     W10,W10
0B50:  RLC     W11,W11
0B52:  CP      W11,W7
0B54:  BRA     NZ,B60
0B56:  CPB     W10,W6
0B58:  BRA     NZ,B60
0B5A:  CPB     W9,W5
0B5C:  BRA     NZ,B60
0B5E:  CPB     W8,W4
0B60:  BRA     NC,B6C
0B62:  SUB     W8,W4,W8
0B64:  SUBB    W9,W5,W9
0B66:  SUBB    W10,W6,W10
0B68:  SUBB    W11,W7,W11
0B6A:  BSET.B  42.0
0B6C:  MOV     W8,[W14]
0B6E:  MOV     W9,[W14+#2]
0B70:  MOV     W10,[W14+#4]
0B72:  MOV     W11,[W14+#6]
0B74:  MOV     [W14+#8],W8
0B76:  MOV     [W14+#A],W9
0B78:  MOV     [W14+#C],W10
0B7A:  MOV     [W14+#E],W11
0B7C:  RLC     W8,W8
0B7E:  RLC     W9,W9
0B80:  RLC     W10,W10
0B82:  RLC     W11,W11
0B84:  MOV     W8,[W14+#8]
0B86:  MOV     W9,[W14+#A]
0B88:  MOV     W10,[W14+#C]
0B8A:  MOV     W11,[W14+#E]
0B8C:  MOV     [W14],W8
0B8E:  MOV     [W14+#2],W9
0B90:  MOV     [W14+#4],W10
0B92:  MOV     [W14+#6],W11
0B94:  DEC     W13,W13
0B96:  BRA     NZ,B40
0B98:  MOV     [W14+#8],W0
0B9A:  MOV     [W14+#A],W1
0B9C:  MOV     [W14+#C],W2
0B9E:  MOV     [W14+#E],W3
0BA0:  MOV     [--W15],W13
0BA2:  BTSS    W13.F
0BA4:  BRA     BB4
0BA6:  COM     W3,W3
0BA8:  COM     W2,W2
0BAA:  COM     W1,W1
0BAC:  NEG     W0,W0
0BAE:  ADDC    W1,#0,W1
0BB0:  ADDC    W2,#0,W2
0BB2:  ADDC    W3,#0,W3
0BB4:  ULNK    
0BB6:  BRA     BB8
0BB8:  MOV     [--W15],W9
0BBA:  CP0     W9
0BBC:  BRA     Z,BC6
0BBE:  MOV     W8,W0
0BC0:  MOV     W9,W1
0BC2:  MOV     W10,W2
0BC4:  MOV     W11,W3
0BC6:  MOV     #1A,W8
0BC8:  REPEAT  #4
0BCA:  MOV     [--W15],[W8--]
0BCC:  MOV     [--W15],W8
0BCE:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
024E:  MOV     W5,[W15++]
0250:  MOV     #4B00,W5
0252:  REPEAT  #19E
0254:  NOP     
0256:  DEC     W5,W5
0258:  BRA     NZ,260
025A:  CLR     85A
025C:  MOV     #0,W0
025E:  BRA     26C
0260:  BTSS.B  232.0
0262:  BRA     252
0264:  PUSH    232
0266:  POP     85A
0268:  MOV     236,W0
026A:  BCLR.B  232.1
026C:  MOV     [--W15],W5
026E:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14   
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 PercentError; 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... unsigned int16 TempInputSamples[2]; 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
.................... FlagType TriggerValueFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... void DisableInterrupts(void); 
.................... void EnableInterrupts(void); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH]; // =  
.................... //!{ 
.................... //!     -129,     19,     39,    -74,    -39,    301,    604,    354,   -397, 
.................... //!     -894,   -580,     91,    196,   -272,   -154,   1241,   2589,   1599, 
.................... //!    -1984,  -5096,  -4105,    977,   5788,   5788,    977,  -4105,  -5096, 
.................... //!    -1984,   1599,   2589,   1241,   -154,   -272,    196,     91,   -580, 
.................... //!     -894,   -397,    354,    604,    301,    -39,    -74,     39,     19, 
.................... //!     -129,   -192,    -81,     71,    115,     55,     -6,    -15,     16, 
.................... //!       -9 
.................... //!}; 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    if ((TriggerFlag == 2) || (TriggerValueFlag == 0)) 
020E:  MOV     1226,W4
0210:  CP.B    W4L,#2
0212:  BRA     Z,218
0214:  CP0.B   1228
0216:  BRA     NZ,21C
....................    { 
....................       DMADoneFlag = 1; 
0218:  MOV.B   #1,W0L
021A:  MOV.B   W0L,1222
....................    } 
.................... } 
....................  
021C:  BCLR.B  84.4
021E:  MOV     #1A,W0
0220:  REPEAT  #C
0222:  MOV     [--W15],[W0--]
0224:  MOV     [--W15],W0
0226:  POP     32
0228:  POP     36
022A:  POP     42
022C:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
022E:  PUSH    42
0230:  PUSH    36
0232:  PUSH    32
0234:  MOV     W0,[W15++]
0236:  MOV     #2,W0
0238:  REPEAT  #C
023A:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
023C:  BCLR.B  85.6
023E:  MOV     #1A,W0
0240:  REPEAT  #C
0242:  MOV     [--W15],[W0--]
0244:  MOV     [--W15],W0
0246:  POP     32
0248:  POP     36
024A:  POP     42
024C:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0270:  PUSH    42
0272:  PUSH    36
0274:  PUSH    32
0276:  MOV     W0,[W15++]
0278:  MOV     #2,W0
027A:  REPEAT  #C
027C:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
027E:  CALL    24E
0282:  MOV.B   W0L,961
....................    UARTRXFlag = 1; 
0284:  MOV.B   #1,W0L
0286:  MOV.B   W0L,1224
.................... } 
....................  
0288:  BCLR.B  87.6
028A:  MOV     #1A,W0
028C:  REPEAT  #C
028E:  MOV     [--W15],[W0--]
0290:  MOV     [--W15],W0
0292:  POP     32
0294:  POP     36
0296:  POP     42
0298:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
*
0700:  PUSH    42
0702:  PUSH    36
0704:  PUSH    32
0706:  MOV     W0,[W15++]
0708:  MOV     #2,W0
070A:  REPEAT  #C
070C:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); 
070E:  BCLR.B  2C9.6
0710:  BTG.B   2CD.6
....................    //read_adc(); 
....................    if((NormalizeFlag == 1) || (TriggerValueFlag == 0)) 
0712:  MOV     1222,W4
0714:  LSR     W4,#8,W4
0716:  CP.B    W4L,#1
0718:  BRA     Z,71E
071A:  CP0.B   1228
071C:  BRA     NZ,72E
....................    { 
....................       read_adc(); 
071E:  BCLR.B  320.0
0720:  BSET.B  320.1
0722:  BTSS.B  320.0
0724:  BRA     722
....................       NormalizeDataCounter++; 
0726:  INC     121E
0728:  BTSC.B  42.1
072A:  INC     1220
....................    } 
072C:  BRA     7BA
....................    else 
....................    { 
....................       unsigned int16 ADCValue = 0; 
072E:  CLR     12D4
....................        
....................       if (DMAFlag == 0) 
0730:  CP0.B   1227
0732:  BRA     NZ,742
....................       { 
....................          disable_interrupts(INT_DMA0); 
0734:  BCLR.B  94.4
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0736:  MOV     #4000,W1
0738:  MOV     #0,W2
073A:  REPEAT  #1FD
073C:  CLR.B   [W1++]
....................          DMAFlag = 1; 
073E:  MOV.B   #1,W0L
0740:  MOV.B   W0L,1227
....................       } 
....................        
....................       if (TriggerFlag != 2) 
0742:  MOV     1226,W4
0744:  CP.B    W4L,#2
0746:  BRA     Z,75C
....................       { 
....................           ADCValue = QuickDigitize(read_adc()); 
0748:  BCLR.B  320.0
074A:  BSET.B  320.1
074C:  BTSS.B  320.0
074E:  BRA     74C
0750:  MOV     300,W5
0752:  MOV     W5,12DA
0754:  CALL    5D8
0758:  MOV.B   W0L,12D4
075A:  CLR.B   12D5
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
075C:  MOV     12D4,W0
075E:  CP      966
0760:  BRA     NZ,770
0762:  CP0.B   1226
0764:  BRA     NZ,770
....................       { 
....................          TempInputSamples[0] = ADCValue; 
0766:  PUSH    12D4
0768:  POP     11F6
....................          TriggerFlag = 1; 
076A:  MOV.B   #1,W0L
076C:  MOV.B   W0L,1226
....................       } 
076E:  BRA     7BA
....................       else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) 
0770:  MOV     11F6,W0
0772:  MOV     12D4,W4
0774:  CP      W4,W0
0776:  BRA     LEU,788
0778:  MOV     1226,W4
077A:  CP.B    W4L,#1
077C:  BRA     NZ,788
....................       { 
....................          TempInputSamples[1] = ADCValue; 
077E:  PUSH    12D4
0780:  POP     11F8
....................          TriggerFlag = 2; 
0782:  MOV.B   #2,W0L
0784:  MOV.B   W0L,1226
....................       } 
0786:  BRA     7BA
....................       else if(TriggerFlag == 2) 
0788:  MOV     1226,W4
078A:  CP.B    W4L,#2
078C:  BRA     NZ,7BA
....................       { 
....................          if(DMAFlag == 1) 
078E:  MOV     1226,W4
0790:  LSR     W4,#8,W4
0792:  CP.B    W4L,#1
0794:  BRA     NZ,7B2
....................          { 
....................             memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0796:  MOV     #4000,W1
0798:  MOV     #0,W2
079A:  REPEAT  #1FD
079C:  CLR.B   [W1++]
....................             dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
079E:  BCLR.B  381.7
07A0:  CLR.B   380
07A2:  MOV     #4000,W4
07A4:  MOV     W4,384
07A6:  MOV     #FF,W4
07A8:  MOV     W4,38A
07AA:  BSET.B  381.7
....................             enable_interrupts(INT_DMA0); 
07AC:  BSET.B  94.4
....................             DMAFlag = 2; 
07AE:  MOV.B   #2,W0L
07B0:  MOV.B   W0L,1227
....................          } 
....................           
....................          read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
07B2:  BCLR.B  320.0
07B4:  BSET.B  320.1
07B6:  BTSS.B  320.0
07B8:  BRA     7B6
....................       }   
.................... //!      else 
.................... //!      { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
.................... //!          
.................... //!         TriggerFlag = 0; 
.................... //!      } 
....................    } 
07BA:  BCLR.B  84.3
07BC:  MOV     #1A,W0
07BE:  REPEAT  #C
07C0:  MOV     [--W15],[W0--]
07C2:  MOV     [--W15],W0
07C4:  POP     32
07C6:  POP     36
07C8:  POP     42
07CA:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0FF0:  MOV     #4444,W0
0FF2:  MOV     W0,A4
0FF4:  BSET.B  81.7
0FF6:  MOV     #46,W0
0FF8:  MOV.B   W0L,742
0FFA:  MOV     #57,W0
0FFC:  MOV.B   W0L,742
0FFE:  BCLR.B  742.6
1000:  MOV     #3F07,W0
1002:  MOV     W0,6A6
1004:  MOV     #5,W0
1006:  MOV     W0,6C6
1008:  MOV     #46,W0
100A:  MOV.B   W0L,742
100C:  MOV     #57,W0
100E:  MOV.B   W0L,742
1010:  BSET.B  742.6
1012:  MOV     #41,W4
1014:  MOV     W4,744
1016:  MOV     #32,W4
1018:  MOV     W4,746
101A:  CLR     85A
101C:  MOV     #8000,W4
101E:  MOV     W4,230
1020:  MOV     #400,W4
1022:  MOV     W4,232
1024:  BSET.B  230.3
1026:  MOV     #22,W4
1028:  MOV     W4,238
102A:  CLR     85E
102C:  CLR     964
102E:  CLR     966
1030:  CLR     968
1032:  CLR     96A
1034:  CLR     96C
1036:  CLR     1166
1038:  CLR     1168
103A:  CLR     116A
103C:  CLR     116C
103E:  CLR     116E
1040:  CLR     1170
1042:  CLR     1172
1044:  CLR     1174
1046:  CLR     11FE
1048:  CLR     1200
104A:  CLR     1202
104C:  CLR     1204
104E:  CLR.B   961
1050:  CLR     1206
1052:  CLR     1208
1054:  CLR     120A
1056:  CLR     120C
1058:  CLR     120E
105A:  CLR     1210
105C:  CLR     1212
105E:  CLR     1214
1060:  CLR     1216
1062:  CLR     1218
1064:  CLR     121A
1066:  CLR     121C
1068:  CLR     121E
106A:  CLR     1220
106C:  CLR.B   1222
106E:  CLR.B   1223
1070:  CLR.B   1224
1072:  CLR.B   1225
1074:  CLR.B   1226
1076:  CLR.B   1227
1078:  CLR.B   1228
107A:  MOV     #41,W4
107C:  MOV     W4,744
107E:  MOV     #32,W4
1080:  MOV     W4,746
1082:  DISI    #E
1084:  MOV     #101,W0
1086:  MOV     #743,W1
1088:  MOV     #78,W2
108A:  MOV     #9A,W3
108C:  MOV.B   W2L,[W1]
108E:  MOV.B   W3L,[W1]
1090:  MOV.B   W0L,743
1092:  LSR     W0,#8,W0
1094:  MOV     #742,W1
1096:  MOV     #46,W2
1098:  MOV     #57,W3
109A:  MOV.B   W2L,[W1]
109C:  MOV.B   W3L,[W1]
109E:  MOV.B   W0L,[W1]
10A0:  SETM    32C
10A2:  MOV     #3F80,W15
10A4:  MOV     #3FFF,W0
10A6:  MOV     W0,20
10A8:  NOP     
10AA:  CLR     85C
10AC:  MOV     #3F80,W15
10AE:  MOV     #3FFF,W0
10B0:  MOV     W0,20
10B2:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
10B4:  MOV     #4000,W1
10B6:  MOV     #0,W2
10B8:  REPEAT  #FE
10BA:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
10BC:  MOV     #41FE,W1
10BE:  MOV     #61,W2
10C0:  MOV.B   #61,W2L
10C2:  REPEAT  #FE
10C4:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
10C6:  CLR.B   381
10C8:  MOV.B   #D,W0L
10CA:  MOV.B   W0L,382
10CC:  MOV     #300,W4
10CE:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
10D0:  BCLR.B  381.7
10D2:  CLR.B   380
10D4:  MOV     #4000,W4
10D6:  MOV     W4,384
10D8:  MOV     #FF,W4
10DA:  MOV     W4,38A
10DC:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
10DE:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
10E0:  MOV     #9F00,W4
10E2:  MOV     W4,324
10E4:  MOV     #84E0,W4
10E6:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
10E8:  MOV     #FFFE,W4
10EA:  MOV     W4,32C
10EC:  CLR     322
....................     
....................    read_adc(); 
10EE:  BCLR.B  320.0
10F0:  BSET.B  320.1
10F2:  BTSS.B  320.0
10F4:  BRA     10F2
....................     
....................    //TimerTicks = 53334; 
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
10F6:  CLR     104
10F8:  PUSH    85E
10FA:  POP     102
10FC:  MOV     #8000,W4
10FE:  MOV     W4,104
....................    EnableInterrupts(); 
1100:  CALL    7CC
....................     
....................    NormalizeFlag = 1; 
1104:  MOV.B   #1,W0L
1106:  MOV.B   W0L,1223
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
1108:  CP0.B   1222
110A:  BRA     NZ,1116
110C:  MOV     121E,W4
110E:  XOR     #FF,W4
1110:  BRA     NZ,11E8
1112:  CP0     1220
1114:  BRA     NZ,11E8
....................       { 
....................          disable_interrupts(INT_DMA0); 
1116:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
1118:  CLR     12AA
111A:  CLR     12AC
111C:  MOV     12AC,W4
111E:  CP      W4,#0
1120:  BRA     GTU,1140
1122:  BRA     NC,112C
1124:  MOV     12AA,W4
1126:  MOV     #FF,W3
1128:  CP      W3,W4
112A:  BRA     LEU,1140
....................          { 
....................             AccumulateAnalogData(Index); 
112C:  PUSH    12AA
112E:  POP     12B4
1130:  PUSH    12AC
1132:  POP     12B6
1134:  CALL    7D8
1138:  INC     12AA
113A:  BTSC.B  42.1
113C:  INC     12AC
113E:  BRA     111C
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
1140:  MOV     1222,W4
1142:  LSR     W4,#8,W4
1144:  CP.B    W4L,#1
1146:  BRA     NZ,114C
....................          { 
....................             NormalizeData(); 
1148:  CALL    BD0
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
114C:  MOV     1224,W4
114E:  LSR     W4,#8,W4
1150:  CP.B    W4L,#1
1152:  BRA     NZ,11D8
....................          { 
....................             if (TriggerValueFlag == 1) 
1154:  MOV     1228,W4
1156:  CP.B    W4L,#1
1158:  BRA     NZ,1166
....................             { 
....................                 DigitizedData[0] = TempInputSamples[0]; 
115A:  PUSH    11F6
115C:  POP     96E
115E:  CLR     970
....................                 DigitizedData[1] = TempInputSamples[1]; 
1160:  PUSH    11F8
1162:  POP     972
1164:  CLR     974
....................             } 
....................             
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
1166:  CLR     12AE
1168:  CLR     12B0
116A:  MOV     12B0,W4
116C:  CP      W4,#0
116E:  BRA     GTU,1194
1170:  BRA     NC,117A
1172:  MOV     12AE,W4
1174:  MOV     #FF,W3
1176:  CP      W3,W4
1178:  BRA     LEU,1194
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
117A:  MOV     #862,W4
117C:  MOV     12AE,W3
117E:  ADD     W3,W4,W0
1180:  MOV.B   [W0],W5L
1182:  BTSC.B  233.1
1184:  BRA     1182
1186:  PUSH    234
1188:  MOV.B   W5L,[W15-#2]
118A:  POP     234
118C:  INC     12AE
118E:  BTSC.B  42.1
1190:  INC     12B0
1192:  BRA     116A
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
1194:  CLR     12AE
1196:  CLR     12B0
1198:  MOV     12B0,W4
119A:  CP      W4,#0
119C:  BRA     GTU,11D8
119E:  BRA     NC,11A8
11A0:  MOV     12AE,W4
11A2:  MOV     #FF,W3
11A4:  CP      W3,W4
11A6:  BRA     LEU,11D8
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
11A8:  MOV     #2,W4
11AA:  CLR.B   9
11AC:  MOV     12AE,W0
11AE:  MOV     12B0,W1
11B0:  INC     W4,W4
11B2:  DEC     W4,W4
11B4:  BRA     Z,11BC
11B6:  SL      W0,W0
11B8:  RLC     W1,W1
11BA:  BRA     11B2
11BC:  MOV     #96E,W4
11BE:  ADD     W0,W4,W0
11C0:  MOV     #A,W4
11C2:  MOV     [W0++],[W4++]
11C4:  MOV     [W0++],[W4++]
11C6:  BTSC.B  233.1
11C8:  BRA     11C6
11CA:  PUSH    234
11CC:  MOV.B   W5L,[W15-#2]
11CE:  POP     234
11D0:  INC     12AE
11D2:  BTSC.B  42.1
11D4:  INC     12B0
11D6:  BRA     1198
....................             } 
....................          } 
....................           
....................          NormalizeFlag = 0; 
11D8:  CLR.B   1223
....................          HandShakeFlag = 0;    
11DA:  CLR.B   1225
....................          CurrentIndex = 0; 
11DC:  CLR     1212
11DE:  CLR     1214
....................          enable_interrupts(INT_DMA0); 
11E0:  BSET.B  94.4
....................          DMADoneFlag = 0; 
11E2:  CLR.B   1222
....................          TriggerFlag = 0; 
11E4:  CLR.B   1226
....................          DMAFlag = 0; 
11E6:  CLR.B   1227
....................       }   
....................        
....................       if (UARTRXFlag) 
11E8:  CP0.B   1224
11EA:  BRA     Z,11F4
....................       { 
....................          CommHandler(UARTRX); 
11EC:  MOV.B   961,W0L
11EE:  MOV.B   W0L,12B4
11F0:  CALL    E02
....................       }   
11F4:  BRA     1108
....................    } 
.................... } 
....................  
11F6:  BRA     11F6
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
07D8:  MOV     W5,[W15++]
07DA:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
07DC:  MOV     #1,W4
07DE:  CLR.B   9
07E0:  MOV     1212,W0
07E2:  MOV     1214,W1
07E4:  INC     W4,W4
07E6:  DEC     W4,W4
07E8:  BRA     Z,7F0
07EA:  SL      W0,W0
07EC:  RLC     W1,W1
07EE:  BRA     7E6
07F0:  MOV     #1176,W4
07F2:  ADD     W0,W4,W5
07F4:  MOV     #1,W4
07F6:  CLR.B   9
07F8:  MOV     12B4,W0
07FA:  MOV     12B6,W1
07FC:  INC     W4,W4
07FE:  DEC     W4,W4
0800:  BRA     Z,808
0802:  SL      W0,W0
0804:  RLC     W1,W1
0806:  BRA     7FE
0808:  MOV     #4000,W4
080A:  ADD     W0,W4,W0
080C:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
080E:  PUSH    1212
0810:  POP     120E
0812:  PUSH    1214
0814:  POP     1210
....................    Accumulator = 0; 
0816:  CLR     96A
0818:  CLR     96C
....................    CoefficentIndex = 0; 
081A:  CLR     120A
081C:  CLR     120C
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
081E:  MOV     120C,W4
0820:  CP      W4,#0
0822:  BRA     GTU,8B4
0824:  BRA     NC,82E
0826:  MOV     120A,W4
0828:  MOV     #3F,W3
082A:  CP      W3,W4
082C:  BRA     LEU,8B4
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
082E:  MOV     #1,W4
0830:  CLR.B   9
0832:  MOV     120E,W0
0834:  MOV     1210,W1
0836:  INC     W4,W4
0838:  DEC     W4,W4
083A:  BRA     Z,842
083C:  SL      W0,W0
083E:  RLC     W1,W1
0840:  BRA     838
0842:  MOV     #1176,W4
0844:  ADD     W0,W4,W0
0846:  MOV     W0,W4
0848:  MOV     [W4],W0
084A:  MOV     W0,W5
084C:  CLR     W6
084E:  BTSC    W5.F
0850:  SETM    W6
0852:  MOV     #1,W4
0854:  CLR.B   9
0856:  MOV     120A,W0
0858:  MOV     120C,W1
085A:  INC     W4,W4
085C:  DEC     W4,W4
085E:  BRA     Z,866
0860:  SL      W0,W0
0862:  RLC     W1,W1
0864:  BRA     85C
0866:  MOV     #122A,W4
0868:  ADD     W0,W4,W0
086A:  MOV     W0,W4
086C:  MOV     [W4],W0
086E:  CLR     W1
0870:  BTSC    W0.F
0872:  SETM    W1
0874:  PUSH    42
0876:  BCLR.B  81.7
0878:  SETM.B  42
087A:  BSET.B  81.7
087C:  MOV     W0,W2
087E:  MOV     W1,W3
0880:  MOV     W5,W0
0882:  MOV     W6,W1
0884:  CALL    29A
0888:  BCLR.B  81.7
088A:  POP     42
088C:  BSET.B  81.7
088E:  ADD     96A
0890:  MOV     W1,W0
0892:  ADDC    96C,W0
0894:  MOV     W0,96C
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
0896:  MOV     120E,W4
0898:  XOR     #3F,W4
089A:  BRA     NZ,8A6
089C:  CP0     1210
089E:  BRA     NZ,8A6
....................       { 
....................          InputIndex = 0; 
08A0:  CLR     120E
08A2:  CLR     1210
....................       } 
08A4:  BRA     8AC
....................       else 
....................       { 
....................          InputIndex++; 
08A6:  INC     120E
08A8:  BTSC.B  42.1
08AA:  INC     1210
....................       } 
....................        
....................       CoefficentIndex++; 
08AC:  INC     120A
08AE:  BTSC.B  42.1
08B0:  INC     120C
08B2:  BRA     81E
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
08B4:  MOV     #862,W4
08B6:  MOV     12B4,W3
08B8:  ADD     W3,W4,W5
08BA:  MOV     #1,W4
08BC:  CLR.B   9
08BE:  MOV     1212,W0
08C0:  MOV     1214,W1
08C2:  INC     W4,W4
08C4:  DEC     W4,W4
08C6:  BRA     Z,8CE
08C8:  SL      W0,W0
08CA:  RLC     W1,W1
08CC:  BRA     8C4
08CE:  MOV     #1176,W4
08D0:  ADD     W0,W4,W0
08D2:  MOV     [W0],W6
08D4:  LSR     W6,#4,W0
08D6:  MOV.B   W0L,[W5]
08D8:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
08DA:  MOV     1222,W4
08DC:  LSR     W4,#8,W4
08DE:  CP.B    W4L,#1
08E0:  BRA     NZ,902
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
08E2:  MOV     #2,W4
08E4:  CLR.B   9
08E6:  MOV     12B4,W0
08E8:  MOV     12B6,W1
08EA:  INC     W4,W4
08EC:  DEC     W4,W4
08EE:  BRA     Z,8F6
08F0:  SL      W0,W0
08F2:  RLC     W1,W1
08F4:  BRA     8EC
08F6:  MOV     #96E,W4
08F8:  ADD     W0,W4,W5
08FA:  MOV     #96A,W4
08FC:  MOV     [W4++],[W5++]
08FE:  MOV     [W4++],[W5++]
....................    } 
0900:  BRA     9A4
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
0902:  MOV     96A,W0
0904:  MOV     96C,W1
0906:  CLR     W3
0908:  BTSC    W1.F
090A:  SETM    W3
090C:  MOV     W3,W2
090E:  MOV     116E,W4
0910:  SUB     W0,W4,W0
0912:  MOV     1170,W4
0914:  SUBB    W1,W4,W1
0916:  MOV     1172,W4
0918:  SUBB    W2,W4,W2
091A:  MOV     1174,W4
091C:  SUBB    W3,W4,W3
091E:  CALL    2DC
0922:  MOV     W0,12B8
0924:  MOV     W1,12BA
0926:  PUSH    42
0928:  BCLR.B  81.7
092A:  SETM.B  42
092C:  BSET.B  81.7
092E:  MOV     12B8,W0
0930:  MOV     12BA,W1
0932:  MOV     1202,W2
0934:  MOV     1204,W3
0936:  CALL    33E
093A:  BCLR.B  81.7
093C:  POP     42
093E:  BSET.B  81.7
0940:  MOV     W0,12BC
0942:  MOV     W1,12BE
0944:  BCLR.B  43.0
0946:  PUSH    42
0948:  BCLR.B  81.7
094A:  SETM.B  42
094C:  BSET.B  81.7
094E:  MOV     12BC,W0
0950:  MOV     12BE,W1
0952:  MOV     #0,W2
0954:  MOV     #42FE,W3
0956:  CALL    402
095A:  BCLR.B  81.7
095C:  POP     42
095E:  BSET.B  81.7
0960:  MOV     W0,12C0
0962:  MOV     W1,12C2
....................       //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................       //ConversionValue = (unsigned int8)OutputValue; 
....................       ConversionValue = (unsigned int8)StepThree; 
0964:  PUSH    42
0966:  BCLR.B  81.7
0968:  SETM.B  42
096A:  BSET.B  81.7
096C:  MOV     12C0,W0
096E:  MOV     12C2,W1
0970:  CALL    5AC
0974:  BCLR.B  81.7
0976:  POP     42
0978:  BSET.B  81.7
097A:  MOV.B   W0L,860
....................      
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
097C:  MOV     #2,W4
097E:  CLR.B   9
0980:  MOV     12B4,W0
0982:  MOV     12B6,W1
0984:  INC     W4,W4
0986:  DEC     W4,W4
0988:  BRA     Z,990
098A:  SL      W0,W0
098C:  RLC     W1,W1
098E:  BRA     986
0990:  MOV     #96E,W4
0992:  ADD     W0,W4,W5
0994:  MOV     860,W0
0996:  MOV.B   W0L,[W5+#0]
0998:  MOV.B   #0,W0L
099A:  MOV.B   W0L,[W5+#1]
099C:  MOV.B   #0,W0L
099E:  MOV.B   W0L,[W5+#2]
09A0:  MOV.B   #0,W0L
09A2:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................    if (CurrentIndex == 0) 
09A4:  CP0     1212
09A6:  BRA     NZ,9B4
09A8:  CP0     1214
09AA:  BRA     NZ,9B4
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
09AC:  MOV     #3F,W4
09AE:  MOV     W4,1212
09B0:  CLR     1214
....................    } 
09B2:  BRA     9BA
....................    else 
....................    { 
....................      CurrentIndex--; 
09B4:  DEC     1212
09B6:  BTSS.B  42.0
09B8:  DEC     1214
....................    }  
09BA:  MOV     [--W15],W6
09BC:  MOV     [--W15],W5
09BE:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
0BD0:  MOV     W5,[W15++]
0BD2:  MOV     W6,[W15++]
0BD4:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0BD6:  MOV     121C,W4
0BD8:  CP      W4,#0
0BDA:  BRA     GTU,D7A
0BDC:  BRA     NC,BE6
0BDE:  MOV     121A,W4
0BE0:  MOV     #BB8,W3
0BE2:  CP      W3,W4
0BE4:  BRA     LEU,D7A
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0BE6:  PUSH    A6E
0BE8:  POP     1166
0BEA:  PUSH    A70
0BEC:  POP     1168
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0BEE:  PUSH    A6E
0BF0:  POP     116A
0BF2:  PUSH    A70
0BF4:  POP     116C
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0BF6:  PUSH    4080
0BF8:  POP     964
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0BFA:  MOV     #41,W4
0BFC:  MOV     W4,12B4
0BFE:  CLR     12B6
0C00:  MOV     12B6,W4
0C02:  CP      W4,#0
0C04:  BRA     GTU,D2A
0C06:  BRA     NC,C10
0C08:  MOV     12B4,W4
0C0A:  MOV     #FF,W3
0C0C:  CP      W3,W4
0C0E:  BRA     LEU,D2A
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0C10:  MOV     #2,W4
0C12:  CLR.B   9
0C14:  MOV     12B4,W0
0C16:  MOV     12B6,W1
0C18:  INC     W4,W4
0C1A:  DEC     W4,W4
0C1C:  BRA     Z,C24
0C1E:  SL      W0,W0
0C20:  RLC     W1,W1
0C22:  BRA     C1A
0C24:  MOV     #96E,W4
0C26:  ADD     W0,W4,W0
0C28:  MOV     W0,W4
0C2A:  MOV     #0,W3
0C2C:  MOV     [W4++],[W3++]
0C2E:  MOV     [W4++],[W3++]
0C30:  MOV     116C,W4
0C32:  CP      W4,W1
0C34:  BRA     LT,C5C
0C36:  BRA     GT,C3E
0C38:  MOV     116A,W4
0C3A:  CP      W4,W0
0C3C:  BRA     LEU,C5C
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0C3E:  MOV     #2,W4
0C40:  CLR.B   9
0C42:  MOV     12B4,W0
0C44:  MOV     12B6,W1
0C46:  INC     W4,W4
0C48:  DEC     W4,W4
0C4A:  BRA     Z,C52
0C4C:  SL      W0,W0
0C4E:  RLC     W1,W1
0C50:  BRA     C48
0C52:  MOV     #96E,W4
0C54:  ADD     W0,W4,W0
0C56:  MOV     #116A,W4
0C58:  MOV     [W0++],[W4++]
0C5A:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0C5C:  MOV     #2,W4
0C5E:  CLR.B   9
0C60:  MOV     12B4,W0
0C62:  MOV     12B6,W1
0C64:  INC     W4,W4
0C66:  DEC     W4,W4
0C68:  BRA     Z,C70
0C6A:  SL      W0,W0
0C6C:  RLC     W1,W1
0C6E:  BRA     C66
0C70:  MOV     #96E,W4
0C72:  ADD     W0,W4,W0
0C74:  MOV     W0,W4
0C76:  MOV     #0,W3
0C78:  MOV     [W4++],[W3++]
0C7A:  MOV     [W4++],[W3++]
0C7C:  MOV     1168,W4
0C7E:  CP      W4,W1
0C80:  BRA     GT,CA8
0C82:  BRA     LT,C8A
0C84:  MOV     1166,W4
0C86:  CP      W4,W0
0C88:  BRA     C,CA8
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0C8A:  MOV     #2,W4
0C8C:  CLR.B   9
0C8E:  MOV     12B4,W0
0C90:  MOV     12B6,W1
0C92:  INC     W4,W4
0C94:  DEC     W4,W4
0C96:  BRA     Z,C9E
0C98:  SL      W0,W0
0C9A:  RLC     W1,W1
0C9C:  BRA     C94
0C9E:  MOV     #96E,W4
0CA0:  ADD     W0,W4,W0
0CA2:  MOV     #1166,W4
0CA4:  MOV     [W0++],[W4++]
0CA6:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0CA8:  MOV     #1,W4
0CAA:  CLR.B   9
0CAC:  MOV     12B4,W0
0CAE:  MOV     12B6,W1
0CB0:  INC     W4,W4
0CB2:  DEC     W4,W4
0CB4:  BRA     Z,CBC
0CB6:  SL      W0,W0
0CB8:  RLC     W1,W1
0CBA:  BRA     CB2
0CBC:  MOV     #4000,W4
0CBE:  ADD     W0,W4,W0
0CC0:  MOV     W0,W4
0CC2:  MOV     [W4],W0
0CC4:  MOV     964,W4
0CC6:  CP      W4,W0
0CC8:  BRA     LEU,CE6
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0CCA:  MOV     #1,W4
0CCC:  CLR.B   9
0CCE:  MOV     12B4,W0
0CD0:  MOV     12B6,W1
0CD2:  INC     W4,W4
0CD4:  DEC     W4,W4
0CD6:  BRA     Z,CDE
0CD8:  SL      W0,W0
0CDA:  RLC     W1,W1
0CDC:  BRA     CD4
0CDE:  MOV     #4000,W4
0CE0:  ADD     W0,W4,W0
0CE2:  MOV     [W0],[W15++]
0CE4:  POP     964
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0CE6:  MOV     #2,W4
0CE8:  CLR.B   9
0CEA:  MOV     12B4,W0
0CEC:  MOV     12B6,W1
0CEE:  INC     W4,W4
0CF0:  DEC     W4,W4
0CF2:  BRA     Z,CFA
0CF4:  SL      W0,W0
0CF6:  RLC     W1,W1
0CF8:  BRA     CF0
0CFA:  MOV     #96E,W4
0CFC:  ADD     W0,W4,W0
0CFE:  MOV     W0,W4
0D00:  MOV     #0,W3
0D02:  MOV     [W4++],[W3++]
0D04:  MOV     [W4++],[W3++]
0D06:  CLR     W3
0D08:  BTSC    W1.F
0D0A:  SETM    W3
0D0C:  MOV     W3,W2
0D0E:  ADD     116E
0D10:  MOV     W1,W0
0D12:  ADDC    1170,W0
0D14:  MOV     W0,1170
0D16:  MOV     1172,W4
0D18:  ADDC    W2,W4,W0
0D1A:  MOV     W0,1172
0D1C:  MOV     1174,W4
0D1E:  ADDC    W3,W4,W0
0D20:  MOV     W0,1174
0D22:  INC     12B4
0D24:  BTSC.B  42.1
0D26:  INC     12B6
0D28:  BRA     C00
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0D2A:  MOV     1166,W4
0D2C:  MOV     116A,W3
0D2E:  SUB     W4,W3,W0
0D30:  MOV     1168,W4
0D32:  MOV     116C,W3
0D34:  SUBB    W4,W3,W1
0D36:  CALL    9C0
0D3A:  MOV     W0,11FE
0D3C:  MOV     W1,1200
....................       AverageMultiplier = (255.0/ AverageDivider); 
0D3E:  MOV     #0,W0
0D40:  MOV     #437F,W1
0D42:  MOV     11FE,W2
0D44:  MOV     1200,W3
0D46:  CALL    A0E
0D4A:  MOV     W0,1202
0D4C:  MOV     W1,1204
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0D4E:  BCLR.B  43.0
0D50:  MOV     116E,W0
0D52:  MOV     1170,W1
0D54:  MOV     1172,W2
0D56:  MOV     1174,W3
0D58:  MOV     #BF,W4
0D5A:  MOV     #0,W5
0D5C:  MOV     #0,W6
0D5E:  MOV     #0,W7
0D60:  CALL    AD8
0D64:  MOV     W0,116E
0D66:  MOV     W1,1170
0D68:  MOV     W2,1172
0D6A:  MOV     W3,1174
....................        
....................       TriggerValue = InitialTriggerValue; 
0D6C:  PUSH    964
0D6E:  POP     966
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0D70:  MOV     #96E,W1
0D72:  MOV     #0,W2
0D74:  REPEAT  #1FD
0D76:  CLR.B   [W1++]
....................    }   
0D78:  BRA     DE2
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0D7A:  PUSH    4080
0D7C:  POP     964
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0D7E:  MOV     #41,W4
0D80:  MOV     W4,12B8
0D82:  CLR     12BA
0D84:  MOV     12BA,W4
0D86:  CP      W4,#0
0D88:  BRA     GTU,DDA
0D8A:  BRA     NC,D94
0D8C:  MOV     12B8,W4
0D8E:  MOV     #FF,W3
0D90:  CP      W3,W4
0D92:  BRA     LEU,DDA
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0D94:  MOV     #1,W4
0D96:  CLR.B   9
0D98:  MOV     12B8,W0
0D9A:  MOV     12BA,W1
0D9C:  INC     W4,W4
0D9E:  DEC     W4,W4
0DA0:  BRA     Z,DA8
0DA2:  SL      W0,W0
0DA4:  RLC     W1,W1
0DA6:  BRA     D9E
0DA8:  MOV     #4000,W4
0DAA:  ADD     W0,W4,W0
0DAC:  MOV     W0,W4
0DAE:  MOV     [W4],W0
0DB0:  MOV     964,W4
0DB2:  CP      W4,W0
0DB4:  BRA     LEU,DD2
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0DB6:  MOV     #1,W4
0DB8:  CLR.B   9
0DBA:  MOV     12B8,W0
0DBC:  MOV     12BA,W1
0DBE:  INC     W4,W4
0DC0:  DEC     W4,W4
0DC2:  BRA     Z,DCA
0DC4:  SL      W0,W0
0DC6:  RLC     W1,W1
0DC8:  BRA     DC0
0DCA:  MOV     #4000,W4
0DCC:  ADD     W0,W4,W0
0DCE:  MOV     [W0],[W15++]
0DD0:  POP     964
....................         }              
0DD2:  INC     12B8
0DD4:  BTSC.B  42.1
0DD6:  INC     12BA
0DD8:  BRA     D84
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0DDA:  PUSH    964
0DDC:  POP     966
....................       ErrorCounter = 0;  
0DDE:  CLR     121A
0DE0:  CLR     121C
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0DE2:  CLR     121E
0DE4:  CLR     1220
....................    NormalizeFlag = 0; 
0DE6:  CLR.B   1223
....................    CurrentIndex = 0; 
0DE8:  CLR     1212
0DEA:  CLR     1214
0DEC:  MOV     [--W15],W7
0DEE:  MOV     [--W15],W6
0DF0:  MOV     [--W15],W5
0DF2:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
*
05D8:  MOV     W5,[W15++]
05DA:  MOV     W6,[W15++]
.................... { 
....................     InputSamples[CurrentIndex] = ADCValue; 
05DC:  MOV     #1,W4
05DE:  CLR.B   9
05E0:  MOV     1212,W0
05E2:  MOV     1214,W1
05E4:  INC     W4,W4
05E6:  DEC     W4,W4
05E8:  BRA     Z,5F0
05EA:  SL      W0,W0
05EC:  RLC     W1,W1
05EE:  BRA     5E6
05F0:  MOV     #1176,W4
05F2:  ADD     W0,W4,W5
05F4:  MOV     12DA,W4
05F6:  MOV     W4,[W5+#0]
....................     InputIndex = CurrentIndex; 
05F8:  PUSH    1212
05FA:  POP     120E
05FC:  PUSH    1214
05FE:  POP     1210
....................     CoefficentIndex = 0; 
0600:  CLR     120A
0602:  CLR     120C
....................     Accumulator = 0; 
0604:  CLR     96A
0606:  CLR     96C
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
0608:  MOV     120C,W4
060A:  CP      W4,#0
060C:  BRA     GTU,690
060E:  BRA     NC,618
0610:  MOV     120A,W4
0612:  MOV     #3F,W3
0614:  CP      W3,W4
0616:  BRA     LEU,690
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
0618:  MOV     #1,W4
061A:  CLR.B   9
061C:  MOV     120E,W0
061E:  MOV     1210,W1
0620:  INC     W4,W4
0622:  DEC     W4,W4
0624:  BRA     Z,62C
0626:  SL      W0,W0
0628:  RLC     W1,W1
062A:  BRA     622
062C:  MOV     #1176,W4
062E:  ADD     W0,W4,W0
0630:  MOV     W0,W4
0632:  MOV     [W4],W0
0634:  MOV     W0,W5
0636:  CLR     W6
0638:  BTSC    W5.F
063A:  SETM    W6
063C:  MOV     #1,W4
063E:  CLR.B   9
0640:  MOV     120A,W0
0642:  MOV     120C,W1
0644:  INC     W4,W4
0646:  DEC     W4,W4
0648:  BRA     Z,650
064A:  SL      W0,W0
064C:  RLC     W1,W1
064E:  BRA     646
0650:  MOV     #122A,W4
0652:  ADD     W0,W4,W0
0654:  MOV     W0,W4
0656:  MOV     [W4],W0
0658:  CLR     W1
065A:  BTSC    W0.F
065C:  SETM    W1
065E:  MOV     W0,W2
0660:  MOV     W1,W3
0662:  MOV     W5,W0
0664:  MOV     W6,W1
0666:  CALL    29A
066A:  ADD     96A
066C:  MOV     W1,W0
066E:  ADDC    96C,W0
0670:  MOV     W0,96C
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
0672:  MOV     120E,W4
0674:  XOR     #3F,W4
0676:  BRA     NZ,682
0678:  CP0     1210
067A:  BRA     NZ,682
....................          { 
....................             InputIndex = 0; 
067C:  CLR     120E
067E:  CLR     1210
....................          } 
0680:  BRA     688
....................          else 
....................          { 
....................             InputIndex++; 
0682:  INC     120E
0684:  BTSC.B  42.1
0686:  INC     1210
....................          } 
....................          CoefficentIndex++; 
0688:  INC     120A
068A:  BTSC.B  42.1
068C:  INC     120C
068E:  BRA     608
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
0690:  MOV     96A,W0
0692:  MOV     96C,W1
0694:  CLR     W3
0696:  BTSC    W1.F
0698:  SETM    W3
069A:  MOV     W3,W2
069C:  MOV     116E,W4
069E:  SUB     W0,W4,W0
06A0:  MOV     1170,W4
06A2:  SUBB    W1,W4,W1
06A4:  MOV     1172,W4
06A6:  SUBB    W2,W4,W2
06A8:  MOV     1174,W4
06AA:  SUBB    W3,W4,W3
06AC:  CALL    2DC
06B0:  MOV     W0,12DC
06B2:  MOV     W1,12DE
06B4:  MOV     12DC,W0
06B6:  MOV     12DE,W1
06B8:  MOV     1202,W2
06BA:  MOV     1204,W3
06BC:  CALL    33E
06C0:  MOV     W0,12E0
06C2:  MOV     W1,12E2
06C4:  BCLR.B  43.0
06C6:  MOV     12E0,W0
06C8:  MOV     12E2,W1
06CA:  MOV     #0,W2
06CC:  MOV     #42FE,W3
06CE:  CALL    402
06D2:  MOV     W0,12E4
06D4:  MOV     W1,12E6
06D6:  MOV     12E4,W0
06D8:  MOV     12E6,W1
06DA:  CALL    5AC
06DE:  MOV.B   W0L,12E8
....................      
....................     if (CurrentIndex == 0) 
06E0:  CP0     1212
06E2:  BRA     NZ,6F0
06E4:  CP0     1214
06E6:  BRA     NZ,6F0
....................     { 
....................       CurrentIndex = COEF_LENGTH - 1; 
06E8:  MOV     #3F,W4
06EA:  MOV     W4,1212
06EC:  CLR     1214
....................     } 
06EE:  BRA     6F6
....................     else 
....................     { 
....................       CurrentIndex--; 
06F0:  DEC     1212
06F2:  BTSS.B  42.0
06F4:  DEC     1214
....................     }  
....................        
....................     return ConversionValue;   
06F6:  MOV.B   12E8,W0L
06F8:  MOV.B   W0L,0
06FA:  MOV     [--W15],W6
06FC:  MOV     [--W15],W5
06FE:  RETURN  
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0E02:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0E04:  MOV.B   12B4,W0L
0E06:  CLR.B   1
0E08:  XOR     #2B,W0
0E0A:  BRA     Z,E26
0E0C:  XOR     #1,W0
0E0E:  BRA     Z,E2C
0E10:  XOR     #6E,W0
0E12:  BRA     Z,E30
0E14:  XOR     #8,W0
0E16:  BRA     Z,E42
0E18:  XOR     #68,W0
0E1A:  BRA     Z,F0C
0E1C:  XOR     #1,W0
0E1E:  BRA     Z,F6C
0E20:  XOR     #6,W0
0E22:  BRA     Z,FC4
0E24:  BRA     FE8
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0E26:  MOV.B   #1,W0L
0E28:  MOV.B   W0L,1225
....................          break; 
0E2A:  BRA     FE8
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0E2C:  BCLR.B  94.3
....................          break; 
0E2E:  BRA     FE8
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0E30:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0E32:  CLR     104
0E34:  PUSH    85E
0E36:  POP     102
0E38:  MOV     #8000,W4
0E3A:  MOV     W4,104
....................          HandshakeFlag = 1;   
0E3C:  MOV.B   #1,W0L
0E3E:  MOV.B   W0L,1225
....................          break;  
0E40:  BRA     FE8
....................                       
....................       case 'L': 
....................          DisableInterrupts(); 
0E42:  CALL    DF4
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0E46:  MOV     #122A,W1
0E48:  MOV     #0,W2
0E4A:  REPEAT  #7F
0E4C:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0E4E:  MOV     1206,W4
0E50:  XOR     #40,W4
0E52:  BRA     NZ,E58
0E54:  CP0     1208
0E56:  BRA     Z,ED4
....................          { 
....................             if (kbhit(SHARP)) 
0E58:  BTSS.B  232.0
0E5A:  BRA     ED2
0E5C:  PUSH    42
0E5E:  BCLR.B  81.7
0E60:  SETM.B  42
0E62:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0E64:  CALL    24E
0E68:  BCLR.B  81.7
0E6A:  POP     42
0E6C:  BSET.B  81.7
0E6E:  MOV.B   W0L,12B5
....................                 
....................                if ((CoefficentByte == 'L') && (CSharpCoefficentRecieved == 0)) 
0E70:  MOV     12B4,W4
0E72:  LSR     W4,#8,W4
0E74:  XOR.B   #4C,W4L
0E76:  BRA     NZ,E82
0E78:  CP0     1206
0E7A:  BRA     NZ,E82
0E7C:  CP0     1208
0E7E:  BRA     NZ,E82
....................                { 
....................                   ; // Do nothing 
....................                }               
0E80:  BRA     ED2
....................                else if (NumberCSharpByteRecieved == 0) 
0E82:  CP0     1216
0E84:  BRA     NZ,E96
0E86:  CP0     1218
0E88:  BRA     NZ,E96
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0E8A:  MOV.B   12B5,W0L
0E8C:  MOV.B   W0L,962
....................                   NumberCSharpByteRecieved = 1; 
0E8E:  MOV     #1,W4
0E90:  MOV     W4,1216
0E92:  CLR     1218
....................                }            
0E94:  BRA     ED2
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0E96:  MOV.B   12B5,W0L
0E98:  MOV.B   W0L,963
....................                   NumberCSharpByteRecieved = 0; 
0E9A:  CLR     1216
0E9C:  CLR     1218
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0E9E:  MOV.B   963,W0L
0EA0:  MOV.B   W0L,W5L
0EA2:  CLR.B   B
0EA4:  MOV.B   W5L,W0L
0EA6:  MOV.B   W0L,B
0EA8:  CLR.B   W5
0EAA:  MOV     W5,W0
0EAC:  IOR     962,W0
0EAE:  MOV     W0,968
....................                   fir_coef[CSharpCoefficentRecieved] = ByteConversionResult; 
0EB0:  MOV     #1,W4
0EB2:  CLR.B   9
0EB4:  MOV     1206,W0
0EB6:  MOV     1208,W1
0EB8:  INC     W4,W4
0EBA:  DEC     W4,W4
0EBC:  BRA     Z,EC4
0EBE:  SL      W0,W0
0EC0:  RLC     W1,W1
0EC2:  BRA     EBA
0EC4:  MOV     #122A,W4
0EC6:  ADD     W0,W4,W5
0EC8:  MOV     968,W4
0ECA:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0ECC:  INC     1206
0ECE:  BTSC.B  42.1
0ED0:  INC     1208
....................                } 
....................             } 
0ED2:  BRA     E4E
....................          } 
....................           
....................          switch (fir_coef[0]) 
0ED4:  MOV     122A,W0
0ED6:  XOR     #D2,W0
0ED8:  BRA     Z,EE4
0EDA:  XOR     #FA,W0
0EDC:  BRA     Z,EEA
0EDE:  XOR     #149,W0
0EE0:  BRA     Z,EF0
0EE2:  BRA     EF6
....................          { 
....................          case 210: //Todo:: Fall Through  
....................             TimerTicks = 53334; 
0EE4:  MOV     #D056,W4
0EE6:  MOV     W4,85E
....................             break; 
0EE8:  BRA     EFA
....................          case 40: 
....................             TimerTicks = 53334; 
0EEA:  MOV     #D056,W4
0EEC:  MOV     W4,85E
....................             break; 
0EEE:  BRA     EFA
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0EF0:  MOV     #1F40,W4
0EF2:  MOV     W4,85E
....................             break; 
0EF4:  BRA     EFA
....................          default:  
....................             TimerTicks = 8000; 
0EF6:  MOV     #1F40,W4
0EF8:  MOV     W4,85E
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0EFA:  CLR     1206
0EFC:  CLR     1208
....................          NormalizeFlag = 1; 
0EFE:  MOV.B   #1,W0L
0F00:  MOV.B   W0L,1223
....................          HandshakeFlag = 1; 
0F02:  MOV.B   #1,W0L
0F04:  MOV.B   W0L,1225
....................          EnableInterrupts(); 
0F06:  CALL    7CC
....................          break; 
0F0A:  BRA     FE8
....................          
....................       case '$': 
....................          DisableInterrupts(); 
0F0C:  CALL    DF4
....................          TriggerValue = 0; // reset trigger value 
0F10:  CLR     966
....................           
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0F12:  BTSS.B  232.0
0F14:  BRA     F56
0F16:  PUSH    42
0F18:  BCLR.B  81.7
0F1A:  SETM.B  42
0F1C:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0F1E:  CALL    24E
0F22:  BCLR.B  81.7
0F24:  POP     42
0F26:  BSET.B  81.7
0F28:  MOV.B   W0L,12B6
....................                 
....................                if (isdigit(DigitByte)) 
0F2A:  MOV     12B6,W4
0F2C:  MOV     #30,W3
0F2E:  CP.B    W3L,W4L
0F30:  BRA     GTU,F4C
0F32:  MOV     12B6,W4
0F34:  MOV     #39,W3
0F36:  CP.B    W3L,W4L
0F38:  BRA     NC,F4C
....................                { 
....................                   TriggerValue = TriggerValue * 10 + CharToInt(DigitByte); 
0F3A:  MOV     966,W4
0F3C:  MUL.UU  W4,#A,W0
0F3E:  MOV     W0,W5
0F40:  MOV.B   12B6,W0L
0F42:  SE      W0,W0
0F44:  SUB     #30,W0
0F46:  ADD     W0,W5,W0
0F48:  MOV     W0,966
....................                } 
0F4A:  BRA     F56
....................                else if (DigitByte == ')') 
0F4C:  MOV     12B6,W4
0F4E:  XOR.B   #29,W4L
0F50:  BRA     NZ,F56
....................                { 
....................                   break; 
0F52:  BRA     F58
....................                } 
0F54:  BRA     F56
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0F56:  BRA     F12
....................          } 
....................          TriggerValueFlag = 1; 
0F58:  MOV.B   #1,W0L
0F5A:  MOV.B   W0L,1228
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0F5C:  CLR     104
0F5E:  PUSH    85E
0F60:  POP     102
0F62:  MOV     #8000,W4
0F64:  MOV     W4,104
....................          EnableInterrupts(); 
0F66:  CALL    7CC
....................          break;  
0F6A:  BRA     FE8
....................           
....................       case '%': 
....................          DisableInterrupts();   
0F6C:  CALL    DF4
....................          TimerTicks = 0; // reset trigger value 
0F70:  CLR     85E
....................              
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0F72:  BTSS.B  232.0
0F74:  BRA     FBC
0F76:  PUSH    42
0F78:  BCLR.B  81.7
0F7A:  SETM.B  42
0F7C:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0F7E:  CALL    24E
0F82:  BCLR.B  81.7
0F84:  POP     42
0F86:  BSET.B  81.7
0F88:  MOV.B   W0L,12B7
....................                 
....................                if (isdigit(DigitByte)) 
0F8A:  MOV     12B6,W4
0F8C:  LSR     W4,#8,W4
0F8E:  MOV     #30,W3
0F90:  CP.B    W3L,W4L
0F92:  BRA     GTU,FB0
0F94:  MOV     12B6,W4
0F96:  LSR     W4,#8,W4
0F98:  MOV     #39,W3
0F9A:  CP.B    W3L,W4L
0F9C:  BRA     NC,FB0
....................                { 
....................                   TimerTicks = TimerTicks * 10 + CharToInt(DigitByte); 
0F9E:  MOV     85E,W4
0FA0:  MUL.UU  W4,#A,W0
0FA2:  MOV     W0,W5
0FA4:  MOV.B   12B7,W0L
0FA6:  SE      W0,W0
0FA8:  SUB     #30,W0
0FAA:  ADD     W0,W5,W0
0FAC:  MOV     W0,85E
....................                } 
0FAE:  BRA     FBC
....................                else if (DigitByte == ')') 
0FB0:  MOV     12B6,W4
0FB2:  LSR     W4,#8,W4
0FB4:  XOR.B   #29,W4L
0FB6:  BRA     NZ,FBC
....................                { 
....................                   break; 
0FB8:  BRA     FBE
....................                } 
0FBA:  BRA     FBC
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0FBC:  BRA     F72
....................          } 
....................          EnableInterrupts(); 
0FBE:  CALL    7CC
....................          break; 
0FC2:  BRA     FE8
....................             
....................       case '#': 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0FC4:  MOV     #4000,W1
0FC6:  MOV     #0,W2
0FC8:  REPEAT  #1FD
0FCA:  CLR.B   [W1++]
....................          dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0FCC:  BCLR.B  381.7
0FCE:  CLR.B   380
0FD0:  MOV     #4000,W4
0FD2:  MOV     W4,384
0FD4:  MOV     #FF,W4
0FD6:  MOV     W4,38A
0FD8:  BSET.B  381.7
....................          enable_interrupts(INT_DMA0); 
0FDA:  BSET.B  94.4
....................          DMAFlag = 0; 
0FDC:  CLR.B   1227
....................          TriggerFlag = 0; 
0FDE:  CLR.B   1226
....................          TriggerValueFlag = 0; 
0FE0:  CLR.B   1228
....................          HandshakeFlag = 1; 
0FE2:  MOV.B   #1,W0L
0FE4:  MOV.B   W0L,1225
....................          break; 
0FE6:  BRA     FE8
....................           
....................           
....................           
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0FE8:  CLR.B   12B4
....................    UARTRXFlag = 0; 
0FEA:  CLR.B   1224
0FEC:  MOV     [--W15],W5
0FEE:  RETURN  
.................... } 
....................  
.................... void DisableInterrupts(void) 
.................... { 
....................    disable_interrupts(INT_TIMER1); // disable timer 
*
0DF4:  BCLR.B  94.3
....................    disable_interrupts(INT_RDA2); 
0DF6:  BCLR.B  97.6
....................    disable_interrupts(GLOBAL);  
0DF8:  BCLR.B  81.7
0DFA:  MOV     #E0,W4
0DFC:  MOV     W4,42
0DFE:  BSET.B  81.7
0E00:  RETURN  
.................... } 
....................  
.................... void EnableInterrupts(void) 
.................... { 
....................    enable_interrupts(INT_RDA2); 
*
07CC:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
07CE:  BSET.B  94.3
....................    enable_interrupts(GLOBAL); 
07D0:  BCLR.B  81.7
07D2:  CLR     42
07D4:  BSET.B  81.7
07D6:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
