CCS PCD C Compiler, Version 5.008, 5967               01-Nov-22 21:26

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4238 bytes (10%)
                           Largest free fragment is 39794
               RAM used:   3720 (23%) at main() level
                           3769 (23%) worst case
               Stack used: 66 locations (50 in main + 16 for interrupts)
               Stack size: 30

*
0000:  GOTO    D5E
*
001A:  DATA    90,02,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    66,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
02BC:  MOV     W5,[W15++]
02BE:  MOV     #C,W5
02C0:  REPEAT  #3
02C2:  MOV     [W5++],[W15++]
02C4:  MUL.UU  W0,W2,W4
02C6:  BTSS    W3.F
02C8:  BRA     2CE
02CA:  MUL.SS  W0,W3,W6
02CC:  BRA     2D0
02CE:  MUL.UU  W0,W3,W6
02D0:  BCLR.B  42.0
02D2:  ADD     W6,W5,W5
02D4:  ADDC    W7,#0,W8
02D6:  BTSS    W1.F
02D8:  BRA     2DE
02DA:  MUL.SS  W1,W2,W6
02DC:  BRA     2E0
02DE:  MUL.UU  W1,W2,W6
02E0:  ADDC    W6,W5,W5
02E2:  ADDC    W7,W8,W8
02E4:  ADDC    #0,W9
02E6:  MUL.SS  W1,W3,W6
02E8:  ADDC    W6,W8,W8
02EA:  ADDC    W9,W7,W7
02EC:  MOV     W7,W3
02EE:  MOV     W8,W2
02F0:  MOV     W5,W1
02F2:  MOV     W4,W0
02F4:  MOV     #12,W5
02F6:  REPEAT  #3
02F8:  MOV     [--W15],[W5--]
02FA:  MOV     [--W15],W5
02FC:  RETURN  
02FE:  MOV     W5,[W15++]
0300:  MOV     #C,W5
0302:  REPEAT  #3
0304:  MOV     [W5++],[W15++]
0306:  MOV     W0,W4
0308:  MOV     W1,W5
030A:  MOV     W2,W6
030C:  MOV     W3,W7
030E:  CLR     W0
0310:  CLR     W1
0312:  CLR     W2
0314:  CLR     W3
0316:  BCLR    W8.0
0318:  BTSS    W7.F
031A:  BRA     326
031C:  BSET    W6.0
031E:  NEG     W4,W4
0320:  COM     W5,W5
0322:  COM     W6,W6
0324:  COM     W7,W7
0326:  XOR     W4,W5,W9
0328:  BRA     NZ,32E
032A:  XOR     W6,W7,W9
032C:  BRA     Z,356
032E:  MOV     #D6,W1
0330:  BTSC    W2.7
0332:  BRA     346
0334:  BCLR.B  42.0
0336:  RLC     W4,W4
0338:  RLC     W5,W5
033A:  RLC     W6,W6
033C:  RLC     W7,W7
033E:  RLC     W0,W0
0340:  RLC     W2,W2
0342:  DEC     W1,W1
0344:  BRA     NZ,330
0346:  SWAP    W1
0348:  BCLR.B  42.0
034A:  RRC     W1,W1
034C:  BCLR    W1.F
034E:  BCLR    W2.7
0350:  XOR.B   W2L,W1L,W1L
0352:  BTSC    W6.0
0354:  BSET    W1.F
0356:  MOV     #12,W5
0358:  REPEAT  #3
035A:  MOV     [--W15],[W5--]
035C:  MOV     [--W15],W5
035E:  RETURN  
0360:  MOV     W5,[W15++]
0362:  MOV     #C,W5
0364:  REPEAT  #4
0366:  MOV     [W5++],[W15++]
0368:  MOV     W0,W4
036A:  MOV     W1,W5
036C:  MOV     W3,W7
036E:  MOV     W2,W6
0370:  BCLR.B  42.0
0372:  BCLR.B  42.1
0374:  RLC     W1,W1
0376:  SWAP    W1
0378:  AND     #FF,W1
037A:  CP0     W1
037C:  BRA     Z,414
037E:  BCLR.B  42.0
0380:  BCLR.B  42.1
0382:  RLC     W3,W3
0384:  SWAP    W3
0386:  AND     #FF,W3
0388:  CP0     W3
038A:  BRA     Z,414
038C:  ZE      W0,W0
038E:  ADD.B   W3L,W1L,W0L
0390:  BRA     C,39A
0392:  SUB     #7F,W0
0394:  BRA     Z,414
0396:  BRA     NC,414
0398:  BRA     39E
039A:  ADD.B   #81,W0L
039C:  BRA     C,414
039E:  XOR     W5,W7,W10
03A0:  BCLR.B  42.0
03A2:  BCLR.B  42.1
03A4:  AND     #FF,W5
03A6:  BSET    W5.7
03A8:  BCLR.B  42.0
03AA:  AND     #FF,W7
03AC:  BSET    W7.7
03AE:  MUL.UU  W4,W6,W2
03B0:  MUL.UU  W5,W6,W8
03B2:  ADDC    W8,W3,W3
03B4:  MOV     W9,W1
03B6:  BTSC.B  42.0
03B8:  INC     W1,W1
03BA:  BCLR.B  42.0
03BC:  MUL.UU  W7,W4,W8
03BE:  ADDC    W8,W3,W3
03C0:  ADDC    W9,W1,W1
03C2:  MUL.UU  W5,W7,W8
03C4:  ADDC    W8,W1,W1
03C6:  INC     W0,W0
03C8:  CP0     W1
03CA:  BTSC.B  42.1
03CC:  BRA     3D0
03CE:  BRA     3D6
03D0:  CP0     W3
03D2:  BTSC.B  42.1
03D4:  BRA     3E0
03D6:  BTSC    W1.F
03D8:  BRA     3E0
03DA:  RLC     W3,W3
03DC:  RLC     W1,W1
03DE:  DEC     W0,W0
03E0:  MOV     W1,W2
03E2:  BCLR.B  42.0
03E4:  BTSS    W3.7
03E6:  BRA     3FA
03E8:  MOV     #FF00,W7
03EA:  AND     W3,W7,W3
03EC:  ADD     #100,W3
03EE:  ADDC    W2,#0,W2
03F0:  CP0     W2
03F2:  BRA     NZ,3FA
03F4:  CP0     W3
03F6:  BRA     NZ,3FA
03F8:  INC     W0,W0
03FA:  SWAP    W0
03FC:  BCLR.B  42.0
03FE:  BCLR.B  42.1
0400:  RRC     W0,W1
0402:  BTSC    W10.F
0404:  BSET    W1.F
0406:  BCLR    W2.F
0408:  SWAP    W2
040A:  XOR.B   W2L,W1L,W1L
040C:  SWAP    W3
040E:  MOV.B   W3L,W2L
0410:  MOV     W2,W0
0412:  BRA     41A
0414:  MOV     #0,W0
0416:  MOV     #0,W1
0418:  BRA     41A
041A:  MOV     #14,W5
041C:  REPEAT  #4
041E:  MOV     [--W15],[W5--]
0420:  MOV     [--W15],W5
0422:  RETURN  
0424:  MOV     W5,[W15++]
0426:  MOV     #C,W5
0428:  REPEAT  #3
042A:  MOV     [W5++],[W15++]
042C:  CLR     W9
042E:  MOV     #8000,W8
0430:  BTSC.B  43.0
0432:  XOR     W8,W3,W3
0434:  CP0     W0
0436:  BRA     NZ,43E
0438:  MOV     #7FFF,W10
043A:  AND     W1,W10,W10
043C:  BTSS.B  42.1
043E:  MOV     W1,W10
0440:  XOR     W3,W10,W11
0442:  MOV     W1,W6
0444:  MOV     W3,W7
0446:  MOV     W3,W12
0448:  BCLR.B  42.1
044A:  BCLR.B  42.0
044C:  RLC     W6,W6
044E:  SWAP    W6
0450:  AND     #FF,W6
0452:  CP0     W6
0454:  BRA     Z,598
0456:  BCLR.B  42.1
0458:  BCLR.B  42.0
045A:  RLC     W7,W7
045C:  SWAP    W7
045E:  AND     #FF,W7
0460:  CP0     W7
0462:  BRA     Z,5A2
0464:  BCLR.B  42.1
0466:  BCLR.B  42.0
0468:  CP      W7,W6
046A:  BRA     Z,5A4
046C:  BRA     N,5B4
046E:  BCLR    W9.0
0470:  BSET    W9.1
0472:  SUB     W7,W6,W8
0474:  MOV     W7,W6
0476:  AND     #FF,W1
0478:  BSET    W1.7
047A:  AND     #FF,W3
047C:  BSET    W3.7
047E:  MOV     #28,W7
0480:  CP      W7,W8
0482:  BRA     N,4A6
0484:  BCLR.B  42.1
0486:  BCLR.B  42.0
0488:  RRC     W1,W1
048A:  RRC     W0,W0
048C:  DEC     W8,W8
048E:  BRA     NZ,484
0490:  BRA     4AC
0492:  MOV     #28,W7
0494:  CP      W7,W8
0496:  BRA     N,4AA
0498:  BCLR.B  42.1
049A:  BCLR.B  42.0
049C:  RRC     W3,W3
049E:  RRC     W2,W2
04A0:  DEC     W8,W8
04A2:  BRA     NZ,498
04A4:  BRA     4C4
04A6:  MOV     W2,W0
04A8:  MOV     W3,W1
04AA:  BRA     532
04AC:  BTSS    W11.F
04AE:  BRA     4D2
04B0:  BTSC    W9.4
04B2:  MOV     W12,W11
04B4:  NEG     W0,W0
04B6:  BRA     Z,4BC
04B8:  COM.B   W1L,W1L
04BA:  BRA     4BE
04BC:  NEG     W1,W1
04BE:  BTSC    W9.4
04C0:  BRA     518
04C2:  BRA     4D2
04C4:  BTSS    W11.F
04C6:  BRA     4D2
04C8:  NEG     W2,W2
04CA:  BRA     Z,4D0
04CC:  COM.B   W3L,W3L
04CE:  BRA     4D2
04D0:  NEG     W3,W3
04D2:  AND     #FF,W5
04D4:  BCLR.B  42.1
04D6:  BCLR.B  42.0
04D8:  ADD     W0,W2,W0
04DA:  ADDC.B  W1L,W3L,W1L
04DC:  BTSC.B  42.0
04DE:  BSET    W9.3
04E0:  BTSC    W9.0
04E2:  BRA     4F6
04E4:  BTSC    W9.1
04E6:  BRA     4EA
04E8:  BRA     500
04EA:  BTSC    W11.F
04EC:  BRA     518
04EE:  BTSC    W9.3
04F0:  BRA     544
04F2:  BSET    W9.6
04F4:  BRA     532
04F6:  BTSC    W11.F
04F8:  BRA     518
04FA:  BTSC    W9.3
04FC:  BRA     544
04FE:  BRA     532
0500:  BCLR    W9.2
0502:  BTSC    W11.F
0504:  BRA     50E
0506:  MOV     W10,W11
0508:  BTSC    W9.3
050A:  BRA     544
050C:  BRA     57A
050E:  BSET    W9.4
0510:  XOR.B   #80,W1L
0512:  BTSC    W1.7
0514:  BRA     4B0
0516:  MOV     W10,W11
0518:  AND     #FF,W1
051A:  IOR      W0,  W1,W7
051C:  BRA     Z,532
051E:  BTSC    W1.7
0520:  BRA     532
0522:  BCLR.B  42.1
0524:  BCLR.B  42.0
0526:  RLC     W0,W0
0528:  RLC     W1,W1
052A:  DEC     W6,W6
052C:  BTSC.B  42.1
052E:  BRA     592
0530:  BRA     51E
0532:  BTSC    W9.0
0534:  MOV     W10,W11
0536:  BTSC    W9.1
0538:  MOV     W12,W11
053A:  BTSS    W9.5
053C:  BRA     572
053E:  BTSC    W10.F
0540:  BSET    W0.8
0542:  BRA     57A
0544:  BSET.B  42.0
0546:  RRC.B   W1L,W1L
0548:  RRC     W0,W0
054A:  BTSC.B  42.0
054C:  BSET    W9.5
054E:  INC     W6,W6
0550:  BRA     Z,592
0552:  BTSS    W9.5
0554:  BRA     566
0556:  INC     W0,W0
0558:  BRA     NZ,566
055A:  INC.B   W1L,W1L
055C:  BRA     NZ,566
055E:  RRC.B   W1L,W1L
0560:  RRC     W0,W0
0562:  INC     W6,W6
0564:  BRA     Z,592
0566:  BTSC    W9.0
0568:  MOV     W10,W11
056A:  BTSC    W9.1
056C:  MOV     W12,W11
056E:  BTSC.B  42.1
0570:  BRA     592
0572:  BTSC    W9.6
0574:  MOV     W10,W11
0576:  BTSC    W9.7
0578:  MOV     W12,W11
057A:  IOR      W0,  W1,W2
057C:  BRA     Z,5C4
057E:  BCLR    W1.7
0580:  SWAP    W6
0582:  BCLR.B  42.1
0584:  BCLR.B  42.0
0586:  RRC     W6,W6
0588:  XOR     W6,W1,W1
058A:  BSET    W1.F
058C:  BTSS    W11.F
058E:  BCLR    W1.F
0590:  BRA     5C4
0592:  MOV     #0,W0
0594:  MOV     #0,W1
0596:  BRA     5C4
0598:  BTSC    W10.F
059A:  XOR     W8,W3,W3
059C:  MOV     W2,W0
059E:  MOV     W3,W1
05A0:  BRA     5C4
05A2:  BRA     5C4
05A4:  AND     #FF,W3
05A6:  BSET    W3.7
05A8:  AND     #FF,W1
05AA:  BSET    W1.7
05AC:  BTSC    W11.F
05AE:  BCLR    W3.7
05B0:  BSET    W9.2
05B2:  BRA     4C4
05B4:  SUB     W6,W7,W8
05B6:  AND     #FF,W1
05B8:  BSET    W1.7
05BA:  AND     #FF,W3
05BC:  BSET    W3.7
05BE:  BCLR    W9.1
05C0:  BSET    W9.0
05C2:  BRA     492
05C4:  MOV     #12,W5
05C6:  REPEAT  #3
05C8:  MOV     [--W15],[W5--]
05CA:  MOV     [--W15],W5
05CC:  RETURN  
05CE:  MOV     W0,W2
05D0:  MOV     W1,W3
05D2:  MOV.B   W1L,W0L
05D4:  SWAP    W0
05D6:  BSET    W0.F
05D8:  RLC     W1,W1
05DA:  SWAP    W1
05DC:  ZE      W1,W1
05DE:  MOV     #8E,W4
05E0:  SUB.B   W4L,W1L,W1L
05E2:  BRA     Z,5F0
05E4:  CP0     W0
05E6:  BRA     Z,5F0
05E8:  BCLR.B  42.0
05EA:  RRC     W0,W0
05EC:  DEC     W1,W1
05EE:  BRA     NZ,5E4
05F0:  BTSS    W3.F
05F2:  BRA     5F8
05F4:  NEG     W0,W0
05F6:  BRA     5F8
05F8:  RETURN  
*
0856:  MOV     W5,[W15++]
0858:  MOV     W6,[W15++]
085A:  MOV     W0,W4
085C:  MOV     W1,W5
085E:  CLR     W0
0860:  CLR     W1
0862:  BCLR    W6.0
0864:  BTSS    W5.F
0866:  BRA     874
0868:  BSET    W6.0
086A:  NEG     W4,W4
086C:  BRA     Z,872
086E:  COM     W5,W5
0870:  BRA     874
0872:  NEG     W5,W5
0874:  IOR      W4,  W5,W3
0876:  BRA     Z,89E
0878:  CLR     W2
087A:  MOV     #B6,W1
087C:  BTSC    W2.7
087E:  BRA     88E
0880:  BCLR.B  42.0
0882:  RLC     W4,W4
0884:  RLC     W5,W5
0886:  RLC     W0,W0
0888:  RLC     W2,W2
088A:  DEC     W1,W1
088C:  BRA     NZ,87C
088E:  SWAP    W1
0890:  BCLR.B  42.0
0892:  RRC     W1,W1
0894:  BCLR    W1.F
0896:  BCLR    W2.7
0898:  XOR.B   W2L,W1L,W1L
089A:  BTSC    W6.0
089C:  BSET    W1.F
089E:  MOV     [--W15],W6
08A0:  MOV     [--W15],W5
08A2:  RETURN  
08A4:  MOV     W5,[W15++]
08A6:  MOV     #C,W5
08A8:  REPEAT  #4
08AA:  MOV     [W5++],[W15++]
08AC:  CLR     W9
08AE:  XOR     W1,W3,W9
08B0:  MOV     W1,W6
08B2:  MOV     W0,W5
08B4:  MOV     W3,W8
08B6:  MOV     W2,W7
08B8:  RLC     W1,W1
08BA:  SWAP    W1
08BC:  ZE      W1,W1
08BE:  CP0     W1
08C0:  BRA     Z,95E
08C2:  RLC     W3,W3
08C4:  SWAP    W3
08C6:  ZE      W3,W3
08C8:  CP0     W3
08CA:  BRA     Z,95E
08CC:  CLR     W0
08CE:  SUB.B   W1L,W3L,W0L
08D0:  BRA     NC,8D8
08D2:  ADD.B   #7F,W0L
08D4:  BRA     C,95E
08D6:  BRA     8DE
08D8:  SUB.B   #81,W0L
08DA:  BRA     NC,95E
08DC:  BRA     Z,95E
08DE:  MOV     W5,W1
08E0:  MOV     W6,W2
08E2:  BSET    W2.7
08E4:  AND     #FF,W2
08E6:  AND     #FF,W8
08E8:  BSET    W8.7
08EA:  MOV     #19,W10
08EC:  CLR     W3
08EE:  CLR     W4
08F0:  SUB     W1,W7,W1
08F2:  SUBB    W2,W8,W2
08F4:  BRA     N,8FA
08F6:  BRA     C,900
08F8:  BRA     NZ,902
08FA:  ADD     W1,W7,W1
08FC:  ADDC    W2,W8,W2
08FE:  BRA     902
0900:  BSET    W4.0
0902:  DEC     W10,W10
0904:  BRA     Z,914
0906:  BCLR.B  42.0
0908:  RLC     W1,W1
090A:  RLC     W2,W2
090C:  BCLR.B  42.0
090E:  RLC     W4,W4
0910:  RLC     W3,W3
0912:  BRA     8F0
0914:  CLR     W10
0916:  BTSC    W3.8
0918:  BRA     91C
091A:  BRA     928
091C:  BCLR.B  42.0
091E:  RRC     W3,W3
0920:  BCLR    W3.7
0922:  RRC     W4,W4
0924:  RLC     W10,W10
0926:  BRA     92C
0928:  DEC     W0,W0
092A:  BRA     Z,95E
092C:  BTSC    W10.F
092E:  BRA     NC,93A
0930:  RLC     W1,W1
0932:  RLC     W2,W2
0934:  SUB     W1,W7,W1
0936:  SUBB    W2,W8,W2
0938:  BRA     NC,94C
093A:  INC     W4,W4
093C:  BRA     NZ,94C
093E:  INC     W3,W3
0940:  BRA     NZ,94C
0942:  INC     W0,W0
0944:  BRA     Z,95E
0946:  BRA     94C
0948:  DEC     W0,W0
094A:  BRA     Z,95E
094C:  SWAP    W0
094E:  RRC     W0,W1
0950:  BSET    W1.F
0952:  BTSS    W9.F
0954:  BCLR    W1.F
0956:  BCLR    W3.7
0958:  XOR.B   W3L,W1L,W1L
095A:  MOV     W4,W0
095C:  BRA     964
095E:  MOV     #0,W0
0960:  MOV     #0,W1
0962:  BRA     964
0964:  MOV     #14,W5
0966:  REPEAT  #4
0968:  MOV     [--W15],[W5--]
096A:  MOV     [--W15],W5
096C:  RETURN  
096E:  MOV     W8,[W15++]
0970:  MOV     #12,W8
0972:  REPEAT  #4
0974:  MOV     [W8++],[W15++]
0976:  MOV     #0,W9
0978:  BTSC.B  43.0
097A:  MOV     #1,W9
097C:  MOV     W9,[W15++]
097E:  CLR     W8
0980:  CLR     W9
0982:  CLR     W10
0984:  CLR     W11
0986:  CLR     W12
0988:  CLR     W13
098A:  MOV     #E,W8
098C:  MOV     #0,W9
098E:  LNK     #10
0990:  MOV     W12,[W14+W8]
0992:  DEC2    W8,W8
0994:  BRA     NN,990
0996:  XOR     W4,W5,W8
0998:  BRA     NZ,99E
099A:  XOR     W6,W7,W8
099C:  BRA     Z,A2E
099E:  CLR     W8
09A0:  CLR     W13
09A2:  MOV     W13,[W15++]
09A4:  BTSS    W3.F
09A6:  BRA     9BC
09A8:  MOV     [--W15],W13
09AA:  BSET    W13.F
09AC:  MOV     W13,[W15++]
09AE:  COM     W3,W3
09B0:  COM     W2,W2
09B2:  COM     W1,W1
09B4:  NEG     W0,W0
09B6:  ADDC    W1,#0,W1
09B8:  ADDC    W2,#0,W2
09BA:  ADDC    W3,#0,W3
09BC:  BTSS    W7.F
09BE:  BRA     9D4
09C0:  MOV     [--W15],W13
09C2:  BTG     W13.F
09C4:  MOV     W13,[W15++]
09C6:  COM     W7,W7
09C8:  COM     W6,W6
09CA:  COM     W5,W5
09CC:  NEG     W4,W4
09CE:  ADDC    W5,#0,W5
09D0:  ADDC    W6,#0,W6
09D2:  ADDC    W7,#0,W7
09D4:  MOV     #40,W13
09D6:  BCLR.B  42.0
09D8:  RLC     W0,W0
09DA:  RLC     W1,W1
09DC:  RLC     W2,W2
09DE:  RLC     W3,W3
09E0:  RLC     W8,W8
09E2:  RLC     W9,W9
09E4:  RLC     W10,W10
09E6:  RLC     W11,W11
09E8:  CP      W11,W7
09EA:  BRA     NZ,9F6
09EC:  CPB     W10,W6
09EE:  BRA     NZ,9F6
09F0:  CPB     W9,W5
09F2:  BRA     NZ,9F6
09F4:  CPB     W8,W4
09F6:  BRA     NC,A02
09F8:  SUB     W8,W4,W8
09FA:  SUBB    W9,W5,W9
09FC:  SUBB    W10,W6,W10
09FE:  SUBB    W11,W7,W11
0A00:  BSET.B  42.0
0A02:  MOV     W8,[W14]
0A04:  MOV     W9,[W14+#2]
0A06:  MOV     W10,[W14+#4]
0A08:  MOV     W11,[W14+#6]
0A0A:  MOV     [W14+#8],W8
0A0C:  MOV     [W14+#A],W9
0A0E:  MOV     [W14+#C],W10
0A10:  MOV     [W14+#E],W11
0A12:  RLC     W8,W8
0A14:  RLC     W9,W9
0A16:  RLC     W10,W10
0A18:  RLC     W11,W11
0A1A:  MOV     W8,[W14+#8]
0A1C:  MOV     W9,[W14+#A]
0A1E:  MOV     W10,[W14+#C]
0A20:  MOV     W11,[W14+#E]
0A22:  MOV     [W14],W8
0A24:  MOV     [W14+#2],W9
0A26:  MOV     [W14+#4],W10
0A28:  MOV     [W14+#6],W11
0A2A:  DEC     W13,W13
0A2C:  BRA     NZ,9D6
0A2E:  MOV     [W14+#8],W0
0A30:  MOV     [W14+#A],W1
0A32:  MOV     [W14+#C],W2
0A34:  MOV     [W14+#E],W3
0A36:  MOV     [--W15],W13
0A38:  BTSS    W13.F
0A3A:  BRA     A4A
0A3C:  COM     W3,W3
0A3E:  COM     W2,W2
0A40:  COM     W1,W1
0A42:  NEG     W0,W0
0A44:  ADDC    W1,#0,W1
0A46:  ADDC    W2,#0,W2
0A48:  ADDC    W3,#0,W3
0A4A:  ULNK    
0A4C:  BRA     A4E
0A4E:  MOV     [--W15],W9
0A50:  CP0     W9
0A52:  BRA     Z,A5C
0A54:  MOV     W8,W0
0A56:  MOV     W9,W1
0A58:  MOV     W10,W2
0A5A:  MOV     W11,W3
0A5C:  MOV     #1A,W8
0A5E:  REPEAT  #4
0A60:  MOV     [--W15],[W8--]
0A62:  MOV     [--W15],W8
0A64:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
0244:  MOV     W5,[W15++]
0246:  MOV     #4B00,W5
0248:  REPEAT  #19E
024A:  NOP     
024C:  DEC     W5,W5
024E:  BRA     NZ,256
0250:  CLR     85A
0252:  MOV     #0,W0
0254:  BRA     262
0256:  BTSS.B  232.0
0258:  BRA     248
025A:  PUSH    232
025C:  POP     85A
025E:  MOV     236,W0
0260:  BCLR.B  232.1
0262:  MOV     [--W15],W5
0264:  RETURN  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 256 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14    
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
.................... const unsigned int8 UART_TX_DMA_CHANNEL = 1; 
.................... const IndexType NumberOfDigitizationRequired = BUFFER_SIZE / COEF_LENGTH; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType UARTTXFlag = 0;       // flag to send data out 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... signed int16 fir_coef[COEF_LENGTH] = 
.................... {   
.................... 210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... -246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... 368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... 1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... 1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... 368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... -246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... 210 
.................... }; 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,12D6
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0266:  PUSH    42
0268:  PUSH    36
026A:  PUSH    32
026C:  MOV     W0,[W15++]
026E:  MOV     #2,W0
0270:  REPEAT  #C
0272:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
0274:  CALL    244
0278:  MOV.B   W0L,911
....................    UARTRXFlag = 1; 
027A:  MOV.B   #1,W0L
027C:  MOV.B   W0L,12D8
.................... } 
....................  
027E:  BCLR.B  87.6
0280:  MOV     #1A,W0
0282:  REPEAT  #C
0284:  MOV     [--W15],[W0--]
0286:  MOV     [--W15],W0
0288:  POP     32
028A:  POP     36
028C:  POP     42
028E:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
0290:  PUSH    42
0292:  PUSH    36
0294:  PUSH    32
0296:  MOV     W0,[W15++]
0298:  MOV     #2,W0
029A:  REPEAT  #C
029C:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN);  
029E:  BCLR.B  2C9.6
02A0:  BTG.B   2CD.6
....................    read_adc(); 
02A2:  BCLR.B  320.0
02A4:  BSET.B  320.1
02A6:  BTSS.B  320.0
02A8:  BRA     2A6
.................... //!   if(NormalizeFlag == 1) 
.................... //!   { 
.................... //!      read_adc(); 
.................... //!      NormalizeDataCounter++; 
.................... //!   } 
.................... //!   else 
.................... //!   { 
.................... //!      unsigned int16 ADCValue = 0; 
.................... //!       
.................... //!      if (TriggerFlag != 2) 
.................... //!      { 
.................... //!          ADCValue = QuickDigitize(read_adc()); 
.................... //!      } 
.................... //!       
.................... //!      if (DMAFlag == 0) 
.................... //!      { 
.................... //!         disable_interrupts(INT_DMA0); 
.................... //!         memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!         DMAFlag = 1; 
.................... //!      } 
.................... //!       
.................... //!      if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
.................... //!      { 
.................... //!         DMA_ADC_BUFFER[0] = ADCValue; 
.................... //!         TriggerFlag = 1; 
.................... //!      } 
.................... //!      else if(DMA_ADC_BUFFER[1] > ADCValue) 
.................... //!      { 
.................... //!         DMA_ADC_BUFFER[1] = ADCValue; 
.................... //!         TriggerFlag = 2; 
.................... //!      } 
.................... //!      else if(TriggerFlag == 2) 
.................... //!      { 
.................... //!         if(DMAFlag == 1) 
.................... //!         { 
.................... //!            //memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!            dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
.................... //!            enable_interrupts(INT_DMA0); 
.................... //!            DMAFlag = 2; 
.................... //!         } 
.................... //!          
.................... //!         read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
.................... //!      }   
.................... //!      else 
.................... //!      { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
.................... //!          
.................... //!         TriggerFlag = 0; 
.................... //!      } 
.................... //!   } 
02AA:  BCLR.B  84.3
02AC:  MOV     #1A,W0
02AE:  REPEAT  #C
02B0:  MOV     [--W15],[W0--]
02B2:  MOV     [--W15],W0
02B4:  POP     32
02B6:  POP     36
02B8:  POP     42
02BA:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0D5E:  MOV     #4444,W0
0D60:  MOV     W0,A4
0D62:  BSET.B  81.7
0D64:  MOV     #46,W0
0D66:  MOV.B   W0L,742
0D68:  MOV     #57,W0
0D6A:  MOV.B   W0L,742
0D6C:  BCLR.B  742.6
0D6E:  MOV     #3F07,W0
0D70:  MOV     W0,6A6
0D72:  MOV     #5,W0
0D74:  MOV     W0,6C6
0D76:  MOV     #46,W0
0D78:  MOV.B   W0L,742
0D7A:  MOV     #57,W0
0D7C:  MOV.B   W0L,742
0D7E:  BSET.B  742.6
0D80:  MOV     #41,W4
0D82:  MOV     W4,744
0D84:  MOV     #32,W4
0D86:  MOV     W4,746
0D88:  CLR     85A
0D8A:  MOV     #8000,W4
0D8C:  MOV     W4,230
0D8E:  MOV     #400,W4
0D90:  MOV     W4,232
0D92:  BSET.B  230.3
0D94:  MOV     #22,W4
0D96:  MOV     W4,238
0D98:  CLR     90E
0D9A:  CLR     A14
0D9C:  CLR     A16
0D9E:  CLR     A18
0DA0:  CLR     A1A
0DA2:  CLR     A1C
0DA4:  CLR     121E
0DA6:  CLR     1220
0DA8:  CLR     1222
0DAA:  CLR     1224
0DAC:  CLR     1226
0DAE:  CLR     1228
0DB0:  CLR     122A
0DB2:  CLR     122C
0DB4:  CLR     12B2
0DB6:  CLR     12B4
0DB8:  CLR     12B6
0DBA:  CLR     12B8
0DBC:  CLR.B   911
0DBE:  CLR     12BA
0DC0:  CLR     12BC
0DC2:  CLR     12BE
0DC4:  CLR     12C0
0DC6:  CLR     12C2
0DC8:  CLR     12C4
0DCA:  CLR     12C6
0DCC:  CLR     12C8
0DCE:  CLR     12CA
0DD0:  CLR     12CC
0DD2:  CLR     12CE
0DD4:  CLR     12D0
0DD6:  CLR     12D2
0DD8:  CLR     12D4
0DDA:  CLR.B   12D6
0DDC:  CLR.B   12D7
0DDE:  CLR.B   12D8
0DE0:  CLR.B   12D9
0DE2:  CLR.B   12DA
0DE4:  CLR.B   12DB
0DE6:  CLR.B   12DC
0DE8:  MOV     #41,W4
0DEA:  MOV     W4,744
0DEC:  MOV     #32,W4
0DEE:  MOV     W4,746
0DF0:  DISI    #E
0DF2:  MOV     #101,W0
0DF4:  MOV     #743,W1
0DF6:  MOV     #78,W2
0DF8:  MOV     #9A,W3
0DFA:  MOV.B   W2L,[W1]
0DFC:  MOV.B   W3L,[W1]
0DFE:  MOV.B   W0L,743
0E00:  LSR     W0,#8,W0
0E02:  MOV     #742,W1
0E04:  MOV     #46,W2
0E06:  MOV     #57,W3
0E08:  MOV.B   W2L,[W1]
0E0A:  MOV.B   W3L,[W1]
0E0C:  MOV.B   W0L,[W1]
0E0E:  SETM    32C
0E10:  MOV     #3F80,W15
0E12:  MOV     #3FFF,W0
0E14:  MOV     W0,20
0E16:  NOP     
0E18:  BRA     F08
0E1A:  DATA    C0,06,08
0E1C:  DATA    5C,00,00
0E1E:  DATA    4B,F0,3F
0E20:  DATA    5C,0A,58
0E22:  DATA    F6,3B,8F
0E24:  DATA    00,C0,3C
0E26:  DATA    8B,28,AC
0E28:  DATA    3C,BE,F6
0E2A:  DATA    3F,D2,D5
0E2C:  DATA    44,16,8C
0E2E:  DATA    15,D7,BF
0E30:  DATA    69,00,5A
0E32:  DATA    2E,1B,87
0E34:  DATA    99,3F,9A
0E36:  DATA    5F,AD,4B
0E38:  DATA    91,E4,01
0E3A:  DATA    C0,5D,11
0E3C:  DATA    2F,92,E4
0E3E:  DATA    81,FB,3F
0E40:  DATA    38,DA,91
0E42:  DATA    80,9D,C5
0E44:  DATA    E0,BF,6F
0E46:  DATA    12,C0,B4
0E48:  DATA    C3,09,AB
0E4A:  DATA    3F,6B,C1
0E4C:  DATA    03,4E,C1
0E4E:  DATA    B5,45,BF
0E50:  DATA    F7,40,05
0E52:  DATA    FF,00,5C
0E54:  DATA    EF,3F,F3
0E56:  DATA    A3,E2,F7
0E58:  DATA    D7,FF,01
0E5A:  DATA    40,C0,B4
0E5C:  DATA    FF,05,3C
0E5E:  DATA    58,FC,3F
0E60:  DATA    3B,D3,C0
0E62:  DATA    B5,BA,8C
0E64:  DATA    E2,3F,39
0E66:  DATA    D3,C7,3D
0E68:  DATA    41,79,B2
0E6A:  DATA    3F,87,0D
0E6C:  DATA    3C,50,D0
0E6E:  DATA    AF,62,3F
0E70:  DATA    30,4B,8D
0E72:  DATA    A2,82,AA
0E74:  DATA    04,40,09
0E76:  DATA    A0,40,4A
0E78:  DATA    05,76,03
0E7A:  DATA    40,EC,9E
0E7C:  DATA    37,88,A6
0E7E:  DATA    44,F0,3F
0E80:  DATA    8F,12,8D
0E82:  DATA    29,9A,5B
0E84:  DATA    C7,3F,0E
0E86:  DATA    E0,80,7C
0E88:  DATA    A1,D8,86
0E8A:  DATA    3F,29,4B
0E8C:  DATA    FB,95,C2
0E8E:  DATA    37,1A,3F
0E90:  DATA    00,00,80
0E92:  DATA    80,12,DE
0E94:  DATA    D2,00,59
0E96:  DATA    FF,6A,FF
0E98:  DATA    65,FF,55
0E9A:  DATA    FF,40,FF
0E9C:  DATA    2B,FF,19
0E9E:  DATA    FF,0D,FF
0EA0:  DATA    0A,FF,11
0EA2:  DATA    FF,26,FF
0EA4:  DATA    49,FF,7B
0EA6:  DATA    FF,BF,FF
0EA8:  DATA    13,00,78
0EAA:  DATA    00,ED,00
0EAC:  DATA    70,01,FF
0EAE:  DATA    01,98,02
0EB0:  DATA    37,03,D8
0EB2:  DATA    03,79,04
0EB4:  DATA    16,05,A9
0EB6:  DATA    05,30,06
0EB8:  DATA    A7,06,0A
0EBA:  DATA    07,57,07
0EBC:  DATA    8B,07,A6
0EBE:  DATA    07,A6,07
0EC0:  DATA    8B,07,57
0EC2:  DATA    07,0A,07
0EC4:  DATA    A7,06,30
0EC6:  DATA    06,A9,05
0EC8:  DATA    16,05,79
0ECA:  DATA    04,D8,03
0ECC:  DATA    37,03,98
0ECE:  DATA    02,FF,01
0ED0:  DATA    70,01,ED
0ED2:  DATA    00,78,00
0ED4:  DATA    13,00,BF
0ED6:  DATA    FF,7B,FF
0ED8:  DATA    49,FF,26
0EDA:  DATA    FF,11,FF
0EDC:  DATA    0A,FF,0D
0EDE:  DATA    FF,19,FF
0EE0:  DATA    2B,FF,40
0EE2:  DATA    FF,55,FF
0EE4:  DATA    65,FF,6A
0EE6:  DATA    FF,59,FF
0EE8:  DATA    D2,00,00
0EEA:  DATA    00,00,00
0EEC:  INC     W2,W2
0EEE:  CP      W2,#1
0EF0:  BRA     NZ,EFA
0EF2:  TBLRDL  [W1],W3
0EF4:  TBLRDH  [W1++],W4
0EF6:  MOV.B   6,W0L
0EF8:  RETURN  
0EFA:  CP      W2,#2
0EFC:  BRA     NZ,F02
0EFE:  MOV.B   7,W0L
0F00:  RETURN  
0F02:  MOV.B   8,W0L
0F04:  CLR     W2
0F06:  RETURN  
0F08:  MOV     #0,W6
0F0A:  MOV     #0,W0
0F0C:  MOV     W0,32
0F0E:  MOV     #E1A,W0
0F10:  MOV     W0,W1
0F12:  CLR     W2
0F14:  CALL    EEC
0F18:  MOV.B   W0L,B
0F1A:  CALL    EEC
0F1E:  MOV.B   W0L,A
0F20:  CP0     W5
0F22:  BRA     Z,F56
0F24:  BTSS    W5.F
0F26:  BRA     F36
0F28:  CALL    EEC
0F2C:  MOV.B   W0L,D
0F2E:  CALL    EEC
0F32:  MOV.B   W0L,C
0F34:  BCLR    W5.F
0F36:  BTSS    W5.E
0F38:  BRA     F4A
0F3A:  BCLR    W5.E
0F3C:  DEC     W5,W5
0F3E:  CALL    EEC
0F42:  MOV.B   W0L,W7L
0F44:  REPEAT  W5
0F46:  MOV.B   W7L,[W6++]
0F48:  BRA     F14
0F4A:  CALL    EEC
0F4E:  MOV.B   W0L,[W6++]
0F50:  DEC     W5,W5
0F52:  BRA     NZ,F4A
0F54:  BRA     F14
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0F56:  MOV     #4000,W1
0F58:  MOV     #0,W2
0F5A:  REPEAT  #FF
0F5C:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0F5E:  MOV     #4200,W1
0F60:  MOV     #61,W2
0F62:  MOV.B   #61,W2L
0F64:  REPEAT  #FF
0F66:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0F68:  CLR.B   381
0F6A:  MOV.B   #D,W0L
0F6C:  MOV.B   W0L,382
0F6E:  MOV     #300,W4
0F70:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0F72:  BCLR.B  381.7
0F74:  CLR.B   380
0F76:  MOV     #4000,W4
0F78:  MOV     W4,384
0F7A:  MOV     #100,W4
0F7C:  MOV     W4,38A
0F7E:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
0F80:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0F82:  MOV     #9F00,W4
0F84:  MOV     W4,324
0F86:  MOV     #84E0,W4
0F88:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0F8A:  MOV     #FFFE,W4
0F8C:  MOV     W4,32C
0F8E:  CLR     322
....................     
....................    read_adc(); 
0F90:  BCLR.B  320.0
0F92:  BSET.B  320.1
0F94:  BTSS.B  320.0
0F96:  BRA     F94
....................     
....................    TimerTicks = 53334; 
0F98:  MOV     #D056,W4
0F9A:  MOV     W4,90E
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0F9C:  CLR     104
0F9E:  PUSH    90E
0FA0:  POP     102
0FA2:  MOV     #8000,W4
0FA4:  MOV     W4,104
....................    enable_interrupts(INT_RDA2); 
0FA6:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
0FA8:  BSET.B  94.3
....................    enable_interrupts(INTR_GLOBAL); 
0FAA:  BCLR.B  81.7
0FAC:  CLR     42
0FAE:  BSET.B  81.7
....................     
....................    NormalizeFlag = 1; 
0FB0:  MOV.B   #1,W0L
0FB2:  MOV.B   W0L,12D7
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
0FB4:  CP0.B   12D6
0FB6:  BRA     NZ,FC2
0FB8:  MOV     12D2,W4
0FBA:  XOR     #100,W4
0FBC:  BRA     NZ,107E
0FBE:  CP0     12D4
0FC0:  BRA     NZ,107E
....................       { 
....................          disable_interrupts(INT_DMA0); 
0FC2:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < NumberOfDigitizationRequired; Index++) 
0FC4:  CLR     135E
0FC6:  CLR     1360
0FC8:  MOV     1360,W4
0FCA:  CP      W4,#0
0FCC:  BRA     GTU,FEA
0FCE:  BRA     NC,FD6
0FD0:  MOV     135E,W4
0FD2:  CP      W4,#4
0FD4:  BRA     C,FEA
....................          { 
....................             AccumulateAnalogData(Index); 
0FD6:  PUSH    135E
0FD8:  POP     1368
0FDA:  PUSH    1360
0FDC:  POP     136A
0FDE:  CALL    5FA
0FE2:  INC     135E
0FE4:  BTSC.B  42.1
0FE6:  INC     1360
0FE8:  BRA     FC8
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
0FEA:  MOV     12D6,W4
0FEC:  LSR     W4,#8,W4
0FEE:  CP.B    W4L,#1
0FF0:  BRA     NZ,FF8
....................          { 
....................             NormalizeData(); 
0FF2:  CALL    A66
....................          } 
0FF6:  BRA     FF8
....................          else 
....................          { 
....................           
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
0FF8:  MOV     12DA,W4
0FFA:  CP.B    W4L,#1
0FFC:  BRA     NZ,1070
....................          { 
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0FFE:  CLR     1362
1000:  CLR     1364
1002:  MOV     1364,W4
1004:  CP      W4,#0
1006:  BRA     GTU,102C
1008:  BRA     NC,1012
100A:  MOV     1362,W4
100C:  MOV     #100,W3
100E:  CP      W3,W4
1010:  BRA     LEU,102C
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
1012:  MOV     #912,W4
1014:  MOV     1362,W3
1016:  ADD     W3,W4,W0
1018:  MOV.B   [W0],W5L
101A:  BTSC.B  233.1
101C:  BRA     101A
101E:  PUSH    234
1020:  MOV.B   W5L,[W15-#2]
1022:  POP     234
1024:  INC     1362
1026:  BTSC.B  42.1
1028:  INC     1364
102A:  BRA     1002
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
102C:  CLR     1362
102E:  CLR     1364
1030:  MOV     1364,W4
1032:  CP      W4,#0
1034:  BRA     GTU,1070
1036:  BRA     NC,1040
1038:  MOV     1362,W4
103A:  MOV     #100,W3
103C:  CP      W3,W4
103E:  BRA     LEU,1070
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
1040:  MOV     #2,W4
1042:  CLR.B   9
1044:  MOV     1362,W0
1046:  MOV     1364,W1
1048:  INC     W4,W4
104A:  DEC     W4,W4
104C:  BRA     Z,1054
104E:  SL      W0,W0
1050:  RLC     W1,W1
1052:  BRA     104A
1054:  MOV     #A1E,W4
1056:  ADD     W0,W4,W0
1058:  MOV     #A,W4
105A:  MOV     [W0++],[W4++]
105C:  MOV     [W0++],[W4++]
105E:  BTSC.B  233.1
1060:  BRA     105E
1062:  PUSH    234
1064:  MOV.B   W5L,[W15-#2]
1066:  POP     234
1068:  INC     1362
106A:  BTSC.B  42.1
106C:  INC     1364
106E:  BRA     1030
....................             } 
....................          } 
....................          HandShakeFlag = 0;    
1070:  CLR.B   12DA
....................          CurrentIndex = 0; 
1072:  CLR     12C6
1074:  CLR     12C8
....................          enable_interrupts(INT_DMA0); 
1076:  BSET.B  94.4
....................          DMADoneFlag = 0; 
1078:  CLR.B   12D6
....................          DMAFlag = 0; 
107A:  CLR.B   12DC
....................          TriggerFlag = 0; 
107C:  CLR.B   12DB
....................       }   
....................        
....................       if (UARTRXFlag) 
107E:  CP0.B   12D8
1080:  BRA     Z,108A
....................       { 
....................          CommHandler(UARTRX); 
1082:  MOV.B   911,W0L
1084:  MOV.B   W0L,1368
1086:  CALL    C8A
....................       }   
108A:  BRA     FB4
....................    } 
.................... } 
....................  
108C:  BRA     108C
.................... void AccumulateAnalogData(IndexType NumberOfDigitizationRequired) 
*
05FA:  MOV     W5,[W15++]
05FC:  MOV     W6,[W15++]
05FE:  MOV     W7,[W15++]
0600:  MOV     W8,[W15++]
0602:  MOV     #6,W4
0604:  CLR.B   9
0606:  PUSH    1368
0608:  POP     136C
060A:  PUSH    136A
060C:  POP     136E
060E:  INC     W4,W4
0610:  DEC     W4,W4
0612:  BRA     Z,61A
0614:  SL      136C
0616:  RLC     136E
0618:  BRA     610
.................... { 
....................    IndexType DMAADCIndex = (NumberOfDigitizationRequired * COEF_LENGTH); 
....................    IndexType Index; 
....................    memset(InputSamples, 0, COEF_LENGTH * 2); 
061A:  MOV     #122E,W1
061C:  MOV     #0,W2
061E:  REPEAT  #7F
0620:  CLR.B   [W1++]
....................     
....................    for (Index = 0; Index < COEF_LENGTH; Index++) //Todo:: Replace with MemCpy()  
0622:  CLR     1370
0624:  CLR     1372
0626:  MOV     1372,W4
0628:  CP      W4,#0
062A:  BRA     GTU,67A
062C:  BRA     NC,636
062E:  MOV     1370,W4
0630:  MOV     #40,W3
0632:  CP      W3,W4
0634:  BRA     LEU,67A
....................    { 
....................       InputSamples[Index] = DMA_ADC_BUFFER[DMAADCIndex++]; // >> 4; 
0636:  MOV     #1,W4
0638:  CLR.B   9
063A:  MOV     1370,W0
063C:  MOV     1372,W1
063E:  INC     W4,W4
0640:  DEC     W4,W4
0642:  BRA     Z,64A
0644:  SL      W0,W0
0646:  RLC     W1,W1
0648:  BRA     640
064A:  MOV     #122E,W4
064C:  ADD     W0,W4,W5
064E:  MOV     136E,W1
0650:  MOV     136C,W0
0652:  INC     136C
0654:  BTSC.B  42.1
0656:  INC     136E
0658:  MOV.D   W0,W6
065A:  MOV     #1,W4
065C:  CLR.B   9
065E:  MOV.D   W6,W0
0660:  INC     W4,W4
0662:  DEC     W4,W4
0664:  BRA     Z,66C
0666:  SL      W0,W0
0668:  RLC     W1,W1
066A:  BRA     662
066C:  MOV     #4000,W4
066E:  ADD     W0,W4,W0
0670:  MOV     [W0],[W5]
0672:  INC     1370
0674:  BTSC.B  42.1
0676:  INC     1372
0678:  BRA     626
....................    } 
....................     
....................    DMAADCIndex = (NumberOfDigitizationRequired * COEF_LENGTH);   
067A:  MOV     #6,W4
067C:  CLR.B   9
067E:  PUSH    1368
0680:  POP     136C
0682:  PUSH    136A
0684:  POP     136E
0686:  INC     W4,W4
0688:  DEC     W4,W4
068A:  BRA     Z,692
068C:  SL      136C
068E:  RLC     136E
0690:  BRA     688
....................     
....................    for (Index = 0; Index < COEF_LENGTH; Index++) 
0692:  CLR     1370
0694:  CLR     1372
0696:  MOV     1372,W4
0698:  CP      W4,#0
069A:  BRA     GTU,84C
069C:  BRA     NC,6A6
069E:  MOV     1370,W4
06A0:  MOV     #40,W3
06A2:  CP      W3,W4
06A4:  BRA     LEU,84C
....................    { 
....................       InputIndex = CurrentIndex;  
06A6:  PUSH    12C6
06A8:  POP     12C2
06AA:  PUSH    12C8
06AC:  POP     12C4
....................       Accumulator = 0; 
06AE:  CLR     A1A
06B0:  CLR     A1C
....................       CoefficentIndex = 0; 
06B2:  CLR     12BE
06B4:  CLR     12C0
....................        
....................       while (CoefficentIndex < COEF_LENGTH - 1) 
06B6:  MOV     12C0,W4
06B8:  CP      W4,#0
06BA:  BRA     GTU,73E
06BC:  BRA     NC,6C6
06BE:  MOV     12BE,W4
06C0:  MOV     #3F,W3
06C2:  CP      W3,W4
06C4:  BRA     LEU,73E
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
06C6:  MOV     #1,W4
06C8:  CLR.B   9
06CA:  MOV     12C2,W0
06CC:  MOV     12C4,W1
06CE:  INC     W4,W4
06D0:  DEC     W4,W4
06D2:  BRA     Z,6DA
06D4:  SL      W0,W0
06D6:  RLC     W1,W1
06D8:  BRA     6D0
06DA:  MOV     #122E,W4
06DC:  ADD     W0,W4,W0
06DE:  MOV     W0,W4
06E0:  MOV     [W4],W0
06E2:  MOV     W0,W5
06E4:  CLR     W6
06E6:  BTSC    W5.F
06E8:  SETM    W6
06EA:  MOV     #1,W4
06EC:  CLR.B   9
06EE:  MOV     12BE,W0
06F0:  MOV     12C0,W1
06F2:  INC     W4,W4
06F4:  DEC     W4,W4
06F6:  BRA     Z,6FE
06F8:  SL      W0,W0
06FA:  RLC     W1,W1
06FC:  BRA     6F4
06FE:  MOV     #12DE,W4
0700:  ADD     W0,W4,W0
0702:  MOV     W0,W4
0704:  MOV     [W4],W0
0706:  CLR     W1
0708:  BTSC    W0.F
070A:  SETM    W1
070C:  MOV     W0,W2
070E:  MOV     W1,W3
0710:  MOV     W5,W0
0712:  MOV     W6,W1
0714:  CALL    2BC
0718:  ADD     A1A
071A:  MOV     W1,W0
071C:  ADDC    A1C,W0
071E:  MOV     W0,A1C
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
0720:  MOV     12C2,W4
0722:  XOR     #3F,W4
0724:  BRA     NZ,730
0726:  CP0     12C4
0728:  BRA     NZ,730
....................          { 
....................             InputIndex = 0; 
072A:  CLR     12C2
072C:  CLR     12C4
....................          } 
072E:  BRA     736
....................          else 
....................          { 
....................             InputIndex++; 
0730:  INC     12C2
0732:  BTSC.B  42.1
0734:  INC     12C4
....................          } 
....................          CoefficentIndex++; 
0736:  INC     12BE
0738:  BTSC.B  42.1
073A:  INC     12C0
073C:  BRA     6B6
....................       } 
....................        
....................       AnalogData[DMAADCIndex++] =  InputSamples[Index] >> 4; 
073E:  MOV     136E,W1
0740:  MOV     136C,W0
0742:  INC     136C
0744:  BTSC.B  42.1
0746:  INC     136E
0748:  MOV     W0,W5
074A:  MOV     W1,W6
074C:  MOV     #912,W4
074E:  ADD     W5,W4,W7
0750:  MOV     #1,W4
0752:  CLR.B   9
0754:  MOV     1370,W0
0756:  MOV     1372,W1
0758:  INC     W4,W4
075A:  DEC     W4,W4
075C:  BRA     Z,764
075E:  SL      W0,W0
0760:  RLC     W1,W1
0762:  BRA     75A
0764:  MOV     #122E,W4
0766:  ADD     W0,W4,W0
0768:  MOV     [W0],W8
076A:  LSR     W8,#4,W0
076C:  MOV.B   W0L,[W7]
076E:  MOV.B   W0L,[W7]
....................        
....................       if (NormalizeFlag == 1) 
0770:  MOV     12D6,W4
0772:  LSR     W4,#8,W4
0774:  CP.B    W4L,#1
0776:  BRA     NZ,798
....................       { 
....................          DigitizedData[DMAADCIndex] = Accumulator; 
0778:  MOV     #2,W4
077A:  CLR.B   9
077C:  MOV     136C,W0
077E:  MOV     136E,W1
0780:  INC     W4,W4
0782:  DEC     W4,W4
0784:  BRA     Z,78C
0786:  SL      W0,W0
0788:  RLC     W1,W1
078A:  BRA     782
078C:  MOV     #A1E,W4
078E:  ADD     W0,W4,W5
0790:  MOV     #A1A,W4
0792:  MOV     [W4++],[W5++]
0794:  MOV     [W4++],[W5++]
....................       } 
0796:  BRA     82E
....................       else 
....................       { 
....................          float StepOne = Accumulator - AverageAnalogValue; 
....................          float StepTwo = StepOne * AverageMultiplier; 
....................          float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
0798:  MOV     A1A,W0
079A:  MOV     A1C,W1
079C:  CLR     W3
079E:  BTSC    W1.F
07A0:  SETM    W3
07A2:  MOV     W3,W2
07A4:  MOV     1226,W4
07A6:  SUB     W0,W4,W0
07A8:  MOV     1228,W4
07AA:  SUBB    W1,W4,W1
07AC:  MOV     122A,W4
07AE:  SUBB    W2,W4,W2
07B0:  MOV     122C,W4
07B2:  SUBB    W3,W4,W3
07B4:  CALL    2FE
07B8:  MOV     W0,1374
07BA:  MOV     W1,1376
07BC:  MOV     1374,W0
07BE:  MOV     1376,W1
07C0:  MOV     12B6,W2
07C2:  MOV     12B8,W3
07C4:  CALL    360
07C8:  MOV     W0,1378
07CA:  MOV     W1,137A
07CC:  BCLR.B  43.0
07CE:  MOV     1378,W0
07D0:  MOV     137A,W1
07D2:  MOV     #0,W2
07D4:  MOV     #42FE,W3
07D6:  CALL    424
07DA:  MOV     W0,137C
07DC:  MOV     W1,137E
....................          //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................          //ConversionValue = (unsigned int8)OutputValue; 
....................          ConversionValue = (unsigned int8)StepThree; 
07DE:  MOV     137C,W0
07E0:  MOV     137E,W1
07E2:  CALL    5CE
07E6:  MOV.B   W0L,910
....................          DebugAccumulator[DMAADCIndex] = Accumulator; 
07E8:  MOV     #2,W4
07EA:  CLR.B   9
07EC:  MOV     136C,W0
07EE:  MOV     136E,W1
07F0:  INC     W4,W4
07F2:  DEC     W4,W4
07F4:  BRA     Z,7FC
07F6:  SL      W0,W0
07F8:  RLC     W1,W1
07FA:  BRA     7F2
07FC:  MOV     #E1E,W4
07FE:  ADD     W0,W4,W5
0800:  MOV     #A1A,W4
0802:  MOV     [W4++],[W5++]
0804:  MOV     [W4++],[W5++]
....................          DigitizedData[DMAADCIndex] = ConversionValue; 
0806:  MOV     #2,W4
0808:  CLR.B   9
080A:  MOV     136C,W0
080C:  MOV     136E,W1
080E:  INC     W4,W4
0810:  DEC     W4,W4
0812:  BRA     Z,81A
0814:  SL      W0,W0
0816:  RLC     W1,W1
0818:  BRA     810
081A:  MOV     #A1E,W4
081C:  ADD     W0,W4,W5
081E:  MOV     910,W0
0820:  MOV.B   W0L,[W5+#0]
0822:  MOV.B   #0,W0L
0824:  MOV.B   W0L,[W5+#1]
0826:  MOV.B   #0,W0L
0828:  MOV.B   W0L,[W5+#2]
082A:  MOV.B   #0,W0L
082C:  MOV.B   W0L,[W5+#3]
....................       } 
....................        
....................       if (CurrentIndex == 0) 
082E:  CP0     12C6
0830:  BRA     NZ,83E
0832:  CP0     12C8
0834:  BRA     NZ,83E
....................       { 
....................         CurrentIndex = COEF_LENGTH - 1; 
0836:  MOV     #3F,W4
0838:  MOV     W4,12C6
083A:  CLR     12C8
....................       } 
083C:  BRA     844
....................       else 
....................       { 
....................         CurrentIndex--; 
083E:  DEC     12C6
0840:  BTSS.B  42.0
0842:  DEC     12C8
....................       } 
0844:  INC     1370
0846:  BTSC.B  42.1
0848:  INC     1372
084A:  BRA     696
....................    } 
084C:  MOV     [--W15],W8
084E:  MOV     [--W15],W7
0850:  MOV     [--W15],W6
0852:  MOV     [--W15],W5
0854:  RETURN  
....................    
.................... } 
....................  
.................... void NormalizeData(void) 
*
0A66:  MOV     W5,[W15++]
0A68:  MOV     W6,[W15++]
0A6A:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0A6C:  MOV     12D0,W4
0A6E:  CP      W4,#0
0A70:  BRA     GTU,C10
0A72:  BRA     NC,A7C
0A74:  MOV     12CE,W4
0A76:  MOV     #BB8,W3
0A78:  CP      W3,W4
0A7A:  BRA     LEU,C10
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A7C:  PUSH    B1E
0A7E:  POP     121E
0A80:  PUSH    B20
0A82:  POP     1220
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A84:  PUSH    B1E
0A86:  POP     1222
0A88:  PUSH    B20
0A8A:  POP     1224
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0A8C:  PUSH    4080
0A8E:  POP     A14
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A90:  MOV     #41,W4
0A92:  MOV     W4,1368
0A94:  CLR     136A
0A96:  MOV     136A,W4
0A98:  CP      W4,#0
0A9A:  BRA     GTU,BC0
0A9C:  BRA     NC,AA6
0A9E:  MOV     1368,W4
0AA0:  MOV     #100,W3
0AA2:  CP      W3,W4
0AA4:  BRA     LEU,BC0
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0AA6:  MOV     #2,W4
0AA8:  CLR.B   9
0AAA:  MOV     1368,W0
0AAC:  MOV     136A,W1
0AAE:  INC     W4,W4
0AB0:  DEC     W4,W4
0AB2:  BRA     Z,ABA
0AB4:  SL      W0,W0
0AB6:  RLC     W1,W1
0AB8:  BRA     AB0
0ABA:  MOV     #A1E,W4
0ABC:  ADD     W0,W4,W0
0ABE:  MOV     W0,W4
0AC0:  MOV     #0,W3
0AC2:  MOV     [W4++],[W3++]
0AC4:  MOV     [W4++],[W3++]
0AC6:  MOV     1224,W4
0AC8:  CP      W4,W1
0ACA:  BRA     LT,AF2
0ACC:  BRA     GT,AD4
0ACE:  MOV     1222,W4
0AD0:  CP      W4,W0
0AD2:  BRA     LEU,AF2
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0AD4:  MOV     #2,W4
0AD6:  CLR.B   9
0AD8:  MOV     1368,W0
0ADA:  MOV     136A,W1
0ADC:  INC     W4,W4
0ADE:  DEC     W4,W4
0AE0:  BRA     Z,AE8
0AE2:  SL      W0,W0
0AE4:  RLC     W1,W1
0AE6:  BRA     ADE
0AE8:  MOV     #A1E,W4
0AEA:  ADD     W0,W4,W0
0AEC:  MOV     #1222,W4
0AEE:  MOV     [W0++],[W4++]
0AF0:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0AF2:  MOV     #2,W4
0AF4:  CLR.B   9
0AF6:  MOV     1368,W0
0AF8:  MOV     136A,W1
0AFA:  INC     W4,W4
0AFC:  DEC     W4,W4
0AFE:  BRA     Z,B06
0B00:  SL      W0,W0
0B02:  RLC     W1,W1
0B04:  BRA     AFC
0B06:  MOV     #A1E,W4
0B08:  ADD     W0,W4,W0
0B0A:  MOV     W0,W4
0B0C:  MOV     #0,W3
0B0E:  MOV     [W4++],[W3++]
0B10:  MOV     [W4++],[W3++]
0B12:  MOV     1220,W4
0B14:  CP      W4,W1
0B16:  BRA     GT,B3E
0B18:  BRA     LT,B20
0B1A:  MOV     121E,W4
0B1C:  CP      W4,W0
0B1E:  BRA     C,B3E
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0B20:  MOV     #2,W4
0B22:  CLR.B   9
0B24:  MOV     1368,W0
0B26:  MOV     136A,W1
0B28:  INC     W4,W4
0B2A:  DEC     W4,W4
0B2C:  BRA     Z,B34
0B2E:  SL      W0,W0
0B30:  RLC     W1,W1
0B32:  BRA     B2A
0B34:  MOV     #A1E,W4
0B36:  ADD     W0,W4,W0
0B38:  MOV     #121E,W4
0B3A:  MOV     [W0++],[W4++]
0B3C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0B3E:  MOV     #1,W4
0B40:  CLR.B   9
0B42:  MOV     1368,W0
0B44:  MOV     136A,W1
0B46:  INC     W4,W4
0B48:  DEC     W4,W4
0B4A:  BRA     Z,B52
0B4C:  SL      W0,W0
0B4E:  RLC     W1,W1
0B50:  BRA     B48
0B52:  MOV     #4000,W4
0B54:  ADD     W0,W4,W0
0B56:  MOV     W0,W4
0B58:  MOV     [W4],W0
0B5A:  MOV     A14,W4
0B5C:  CP      W4,W0
0B5E:  BRA     LEU,B7C
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0B60:  MOV     #1,W4
0B62:  CLR.B   9
0B64:  MOV     1368,W0
0B66:  MOV     136A,W1
0B68:  INC     W4,W4
0B6A:  DEC     W4,W4
0B6C:  BRA     Z,B74
0B6E:  SL      W0,W0
0B70:  RLC     W1,W1
0B72:  BRA     B6A
0B74:  MOV     #4000,W4
0B76:  ADD     W0,W4,W0
0B78:  MOV     [W0],[W15++]
0B7A:  POP     A14
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0B7C:  MOV     #2,W4
0B7E:  CLR.B   9
0B80:  MOV     1368,W0
0B82:  MOV     136A,W1
0B84:  INC     W4,W4
0B86:  DEC     W4,W4
0B88:  BRA     Z,B90
0B8A:  SL      W0,W0
0B8C:  RLC     W1,W1
0B8E:  BRA     B86
0B90:  MOV     #A1E,W4
0B92:  ADD     W0,W4,W0
0B94:  MOV     W0,W4
0B96:  MOV     #0,W3
0B98:  MOV     [W4++],[W3++]
0B9A:  MOV     [W4++],[W3++]
0B9C:  CLR     W3
0B9E:  BTSC    W1.F
0BA0:  SETM    W3
0BA2:  MOV     W3,W2
0BA4:  ADD     1226
0BA6:  MOV     W1,W0
0BA8:  ADDC    1228,W0
0BAA:  MOV     W0,1228
0BAC:  MOV     122A,W4
0BAE:  ADDC    W2,W4,W0
0BB0:  MOV     W0,122A
0BB2:  MOV     122C,W4
0BB4:  ADDC    W3,W4,W0
0BB6:  MOV     W0,122C
0BB8:  INC     1368
0BBA:  BTSC.B  42.1
0BBC:  INC     136A
0BBE:  BRA     A96
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0BC0:  MOV     121E,W4
0BC2:  MOV     1222,W3
0BC4:  SUB     W4,W3,W0
0BC6:  MOV     1220,W4
0BC8:  MOV     1224,W3
0BCA:  SUBB    W4,W3,W1
0BCC:  CALL    856
0BD0:  MOV     W0,12B2
0BD2:  MOV     W1,12B4
....................       AverageMultiplier = ((float)ADC_MAX_DATA_VALUE / AverageDivider); 
0BD4:  MOV     #0,W0
0BD6:  MOV     #437F,W1
0BD8:  MOV     12B2,W2
0BDA:  MOV     12B4,W3
0BDC:  CALL    8A4
0BE0:  MOV     W0,12B6
0BE2:  MOV     W1,12B8
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0BE4:  BCLR.B  43.0
0BE6:  MOV     1226,W0
0BE8:  MOV     1228,W1
0BEA:  MOV     122A,W2
0BEC:  MOV     122C,W3
0BEE:  MOV     #C0,W4
0BF0:  MOV     #0,W5
0BF2:  MOV     #0,W6
0BF4:  MOV     #0,W7
0BF6:  CALL    96E
0BFA:  MOV     W0,1226
0BFC:  MOV     W1,1228
0BFE:  MOV     W2,122A
0C00:  MOV     W3,122C
....................        
....................       TriggerValue = InitialTriggerValue; 
0C02:  PUSH    A14
0C04:  POP     A16
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0C06:  MOV     #A1E,W1
0C08:  MOV     #0,W2
0C0A:  REPEAT  #1FF
0C0C:  CLR.B   [W1++]
....................    }   
0C0E:  BRA     C78
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0C10:  PUSH    4080
0C12:  POP     A14
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0C14:  MOV     #41,W4
0C16:  MOV     W4,136C
0C18:  CLR     136E
0C1A:  MOV     136E,W4
0C1C:  CP      W4,#0
0C1E:  BRA     GTU,C70
0C20:  BRA     NC,C2A
0C22:  MOV     136C,W4
0C24:  MOV     #100,W3
0C26:  CP      W3,W4
0C28:  BRA     LEU,C70
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0C2A:  MOV     #1,W4
0C2C:  CLR.B   9
0C2E:  MOV     136C,W0
0C30:  MOV     136E,W1
0C32:  INC     W4,W4
0C34:  DEC     W4,W4
0C36:  BRA     Z,C3E
0C38:  SL      W0,W0
0C3A:  RLC     W1,W1
0C3C:  BRA     C34
0C3E:  MOV     #4000,W4
0C40:  ADD     W0,W4,W0
0C42:  MOV     W0,W4
0C44:  MOV     [W4],W0
0C46:  MOV     A14,W4
0C48:  CP      W4,W0
0C4A:  BRA     LEU,C68
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0C4C:  MOV     #1,W4
0C4E:  CLR.B   9
0C50:  MOV     136C,W0
0C52:  MOV     136E,W1
0C54:  INC     W4,W4
0C56:  DEC     W4,W4
0C58:  BRA     Z,C60
0C5A:  SL      W0,W0
0C5C:  RLC     W1,W1
0C5E:  BRA     C56
0C60:  MOV     #4000,W4
0C62:  ADD     W0,W4,W0
0C64:  MOV     [W0],[W15++]
0C66:  POP     A14
....................         }              
0C68:  INC     136C
0C6A:  BTSC.B  42.1
0C6C:  INC     136E
0C6E:  BRA     C1A
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0C70:  PUSH    A14
0C72:  POP     A16
....................       ErrorCounter = 0;  
0C74:  CLR     12CE
0C76:  CLR     12D0
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0C78:  CLR     12D2
0C7A:  CLR     12D4
....................    NormalizeFlag = 0; 
0C7C:  CLR.B   12D7
....................    CurrentIndex = 0; 
0C7E:  CLR     12C6
0C80:  CLR     12C8
0C82:  MOV     [--W15],W7
0C84:  MOV     [--W15],W6
0C86:  MOV     [--W15],W5
0C88:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
.................... { 
....................     IndexType InputIndex = CurrentIndex; 
....................     IndexType CoefficentIndex = 0; 
....................     unsigned int Accumulator = 0; 
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
....................          { 
....................             InputIndex = 0; 
....................          } 
....................          else 
....................          { 
....................             InputIndex++; 
....................          } 
....................          CoefficentIndex++; 
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
....................        
....................     return ConversionValue;   
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
0C8A:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0C8C:  MOV.B   1368,W0L
0C8E:  CLR.B   1
0C90:  XOR     #2B,W0
0C92:  BRA     Z,CA2
0C94:  XOR     #1,W0
0C96:  BRA     Z,CA8
0C98:  XOR     #6E,W0
0C9A:  BRA     Z,CAC
0C9C:  XOR     #8,W0
0C9E:  BRA     Z,CBE
0CA0:  BRA     D54
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0CA2:  MOV.B   #1,W0L
0CA4:  MOV.B   W0L,12DA
....................          break; 
0CA6:  BRA     D54
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0CA8:  BCLR.B  94.3
....................          break; 
0CAA:  BRA     D54
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0CAC:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0CAE:  CLR     104
0CB0:  PUSH    90E
0CB2:  POP     102
0CB4:  MOV     #8000,W4
0CB6:  MOV     W4,104
....................          HandshakeFlag = 1;   
0CB8:  MOV.B   #1,W0L
0CBA:  MOV.B   W0L,12DA
....................          break;   
0CBC:  BRA     D54
....................           
....................       case 'L': 
....................          disable_interrupts(INT_TIMER1); 
0CBE:  BCLR.B  94.3
....................          disable_interrupts(INT_RDA2); 
0CC0:  BCLR.B  97.6
....................          disable_interrupts(GLOBAL);  
0CC2:  BCLR.B  81.7
0CC4:  MOV     #E0,W4
0CC6:  MOV     W4,42
0CC8:  BSET.B  81.7
....................           
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0CCA:  MOV     12BA,W4
0CCC:  XOR     #40,W4
0CCE:  BRA     NZ,CD4
0CD0:  CP0     12BC
0CD2:  BRA     Z,D40
....................          { 
....................             if (kbhit(SHARP)) 
0CD4:  BTSS.B  232.0
0CD6:  BRA     D3E
0CD8:  PUSH    42
0CDA:  BCLR.B  81.7
0CDC:  SETM.B  42
0CDE:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0CE0:  CALL    244
0CE4:  BCLR.B  81.7
0CE6:  POP     42
0CE8:  BSET.B  81.7
0CEA:  MOV.B   W0L,1369
....................                 
....................                if (CoefficentByte == 'L') 
0CEC:  MOV     1368,W4
0CEE:  LSR     W4,#8,W4
0CF0:  XOR.B   #4C,W4L
0CF2:  BRA     NZ,CF6
....................                { 
....................                   ; // Do nothing 
....................                }               
0CF4:  BRA     D3E
....................                else if (NumberCSharpByteRecieved == 0) 
0CF6:  CP0     12CA
0CF8:  BRA     NZ,D0A
0CFA:  CP0     12CC
0CFC:  BRA     NZ,D0A
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0CFE:  MOV.B   1369,W0L
0D00:  MOV.B   W0L,A12
....................                   NumberCSharpByteRecieved++; 
0D02:  INC     12CA
0D04:  BTSC.B  42.1
0D06:  INC     12CC
....................                }            
0D08:  BRA     D3E
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0D0A:  MOV.B   1369,W0L
0D0C:  MOV.B   W0L,A13
....................                   NumberCSharpByteRecieved = 0; 
0D0E:  CLR     12CA
0D10:  CLR     12CC
....................                   ByteConversionResult = (CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0D12:  CLR.B   W6
0D14:  CLR.B   W5
0D16:  MOV     W5,W0
0D18:  IOR     A12,W0
0D1A:  MOV     W0,A18
....................                   fir_coef[CSharpCoefficentRecieved] = ByteConversionResult; 
0D1C:  MOV     #1,W4
0D1E:  CLR.B   9
0D20:  MOV     12BA,W0
0D22:  MOV     12BC,W1
0D24:  INC     W4,W4
0D26:  DEC     W4,W4
0D28:  BRA     Z,D30
0D2A:  SL      W0,W0
0D2C:  RLC     W1,W1
0D2E:  BRA     D26
0D30:  MOV     #12DE,W4
0D32:  ADD     W0,W4,W5
0D34:  MOV     A18,W4
0D36:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0D38:  INC     12BA
0D3A:  BTSC.B  42.1
0D3C:  INC     12BC
....................                } 
....................             } 
0D3E:  BRA     CCA
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0D40:  CLR     12BA
0D42:  CLR     12BC
....................          HandshakeFlag = 1; 
0D44:  MOV.B   #1,W0L
0D46:  MOV.B   W0L,12DA
....................          enable_interrupts(INT_RDA2); 
0D48:  BSET.B  97.6
....................          enable_interrupts(INT_TIMER1); 
0D4A:  BSET.B  94.3
....................          enable_interrupts(GLOBAL); 
0D4C:  BCLR.B  81.7
0D4E:  CLR     42
0D50:  BSET.B  81.7
....................          break; 
0D52:  BRA     D54
....................           
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\n'; 
0D54:  MOV.B   #A,W0L
0D56:  MOV.B   W0L,1368
....................    UARTRXFlag = 0; 
0D58:  CLR.B   12D8
0D5A:  MOV     [--W15],W5
0D5C:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
