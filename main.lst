CCS PCD C Compiler, Version 5.008, 5967               27-Oct-22 20:32

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4176 bytes (9%)
                           Largest free fragment is 39856
               RAM used:   3716 (23%) at main() level
                           3764 (23%) worst case
               Stack used: 66 locations (50 in main + 16 for interrupts)
               Stack size: 30

*
0000:  GOTO    D3E
*
001A:  DATA    44,02,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    50,03,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
037A:  MOV     W5,[W15++]
037C:  MOV     #C,W5
037E:  REPEAT  #3
0380:  MOV     [W5++],[W15++]
0382:  MUL.UU  W0,W2,W4
0384:  BTSS    W3.F
0386:  BRA     38C
0388:  MUL.SS  W0,W3,W6
038A:  BRA     38E
038C:  MUL.UU  W0,W3,W6
038E:  BCLR.B  42.0
0390:  ADD     W6,W5,W5
0392:  ADDC    W7,#0,W8
0394:  BTSS    W1.F
0396:  BRA     39C
0398:  MUL.SS  W1,W2,W6
039A:  BRA     39E
039C:  MUL.UU  W1,W2,W6
039E:  ADDC    W6,W5,W5
03A0:  ADDC    W7,W8,W8
03A2:  ADDC    #0,W9
03A4:  MUL.SS  W1,W3,W6
03A6:  ADDC    W6,W8,W8
03A8:  ADDC    W9,W7,W7
03AA:  MOV     W7,W3
03AC:  MOV     W8,W2
03AE:  MOV     W5,W1
03B0:  MOV     W4,W0
03B2:  MOV     #12,W5
03B4:  REPEAT  #3
03B6:  MOV     [--W15],[W5--]
03B8:  MOV     [--W15],W5
03BA:  RETURN  
03BC:  MOV     W5,[W15++]
03BE:  MOV     #C,W5
03C0:  REPEAT  #3
03C2:  MOV     [W5++],[W15++]
03C4:  MOV     W0,W4
03C6:  MOV     W1,W5
03C8:  MOV     W2,W6
03CA:  MOV     W3,W7
03CC:  CLR     W0
03CE:  CLR     W1
03D0:  CLR     W2
03D2:  CLR     W3
03D4:  BCLR    W8.0
03D6:  BTSS    W7.F
03D8:  BRA     3E4
03DA:  BSET    W6.0
03DC:  NEG     W4,W4
03DE:  COM     W5,W5
03E0:  COM     W6,W6
03E2:  COM     W7,W7
03E4:  XOR     W4,W5,W9
03E6:  BRA     NZ,3EC
03E8:  XOR     W6,W7,W9
03EA:  BRA     Z,414
03EC:  MOV     #D6,W1
03EE:  BTSC    W2.7
03F0:  BRA     404
03F2:  BCLR.B  42.0
03F4:  RLC     W4,W4
03F6:  RLC     W5,W5
03F8:  RLC     W6,W6
03FA:  RLC     W7,W7
03FC:  RLC     W0,W0
03FE:  RLC     W2,W2
0400:  DEC     W1,W1
0402:  BRA     NZ,3EE
0404:  SWAP    W1
0406:  BCLR.B  42.0
0408:  RRC     W1,W1
040A:  BCLR    W1.F
040C:  BCLR    W2.7
040E:  XOR.B   W2L,W1L,W1L
0410:  BTSC    W6.0
0412:  BSET    W1.F
0414:  MOV     #12,W5
0416:  REPEAT  #3
0418:  MOV     [--W15],[W5--]
041A:  MOV     [--W15],W5
041C:  RETURN  
041E:  MOV     W5,[W15++]
0420:  MOV     #C,W5
0422:  REPEAT  #4
0424:  MOV     [W5++],[W15++]
0426:  MOV     W0,W4
0428:  MOV     W1,W5
042A:  MOV     W3,W7
042C:  MOV     W2,W6
042E:  BCLR.B  42.0
0430:  BCLR.B  42.1
0432:  RLC     W1,W1
0434:  SWAP    W1
0436:  AND     #FF,W1
0438:  CP0     W1
043A:  BRA     Z,4D2
043C:  BCLR.B  42.0
043E:  BCLR.B  42.1
0440:  RLC     W3,W3
0442:  SWAP    W3
0444:  AND     #FF,W3
0446:  CP0     W3
0448:  BRA     Z,4D2
044A:  ZE      W0,W0
044C:  ADD.B   W3L,W1L,W0L
044E:  BRA     C,458
0450:  SUB     #7F,W0
0452:  BRA     Z,4D2
0454:  BRA     NC,4D2
0456:  BRA     45C
0458:  ADD.B   #81,W0L
045A:  BRA     C,4D2
045C:  XOR     W5,W7,W10
045E:  BCLR.B  42.0
0460:  BCLR.B  42.1
0462:  AND     #FF,W5
0464:  BSET    W5.7
0466:  BCLR.B  42.0
0468:  AND     #FF,W7
046A:  BSET    W7.7
046C:  MUL.UU  W4,W6,W2
046E:  MUL.UU  W5,W6,W8
0470:  ADDC    W8,W3,W3
0472:  MOV     W9,W1
0474:  BTSC.B  42.0
0476:  INC     W1,W1
0478:  BCLR.B  42.0
047A:  MUL.UU  W7,W4,W8
047C:  ADDC    W8,W3,W3
047E:  ADDC    W9,W1,W1
0480:  MUL.UU  W5,W7,W8
0482:  ADDC    W8,W1,W1
0484:  INC     W0,W0
0486:  CP0     W1
0488:  BTSC.B  42.1
048A:  BRA     48E
048C:  BRA     494
048E:  CP0     W3
0490:  BTSC.B  42.1
0492:  BRA     49E
0494:  BTSC    W1.F
0496:  BRA     49E
0498:  RLC     W3,W3
049A:  RLC     W1,W1
049C:  DEC     W0,W0
049E:  MOV     W1,W2
04A0:  BCLR.B  42.0
04A2:  BTSS    W3.7
04A4:  BRA     4B8
04A6:  MOV     #FF00,W7
04A8:  AND     W3,W7,W3
04AA:  ADD     #100,W3
04AC:  ADDC    W2,#0,W2
04AE:  CP0     W2
04B0:  BRA     NZ,4B8
04B2:  CP0     W3
04B4:  BRA     NZ,4B8
04B6:  INC     W0,W0
04B8:  SWAP    W0
04BA:  BCLR.B  42.0
04BC:  BCLR.B  42.1
04BE:  RRC     W0,W1
04C0:  BTSC    W10.F
04C2:  BSET    W1.F
04C4:  BCLR    W2.F
04C6:  SWAP    W2
04C8:  XOR.B   W2L,W1L,W1L
04CA:  SWAP    W3
04CC:  MOV.B   W3L,W2L
04CE:  MOV     W2,W0
04D0:  BRA     4D8
04D2:  MOV     #0,W0
04D4:  MOV     #0,W1
04D6:  BRA     4D8
04D8:  MOV     #14,W5
04DA:  REPEAT  #4
04DC:  MOV     [--W15],[W5--]
04DE:  MOV     [--W15],W5
04E0:  RETURN  
04E2:  MOV     W5,[W15++]
04E4:  MOV     #C,W5
04E6:  REPEAT  #3
04E8:  MOV     [W5++],[W15++]
04EA:  CLR     W9
04EC:  MOV     #8000,W8
04EE:  BTSC.B  43.0
04F0:  XOR     W8,W3,W3
04F2:  CP0     W0
04F4:  BRA     NZ,4FC
04F6:  MOV     #7FFF,W10
04F8:  AND     W1,W10,W10
04FA:  BTSS.B  42.1
04FC:  MOV     W1,W10
04FE:  XOR     W3,W10,W11
0500:  MOV     W1,W6
0502:  MOV     W3,W7
0504:  MOV     W3,W12
0506:  BCLR.B  42.1
0508:  BCLR.B  42.0
050A:  RLC     W6,W6
050C:  SWAP    W6
050E:  AND     #FF,W6
0510:  CP0     W6
0512:  BRA     Z,656
0514:  BCLR.B  42.1
0516:  BCLR.B  42.0
0518:  RLC     W7,W7
051A:  SWAP    W7
051C:  AND     #FF,W7
051E:  CP0     W7
0520:  BRA     Z,660
0522:  BCLR.B  42.1
0524:  BCLR.B  42.0
0526:  CP      W7,W6
0528:  BRA     Z,662
052A:  BRA     N,672
052C:  BCLR    W9.0
052E:  BSET    W9.1
0530:  SUB     W7,W6,W8
0532:  MOV     W7,W6
0534:  AND     #FF,W1
0536:  BSET    W1.7
0538:  AND     #FF,W3
053A:  BSET    W3.7
053C:  MOV     #28,W7
053E:  CP      W7,W8
0540:  BRA     N,564
0542:  BCLR.B  42.1
0544:  BCLR.B  42.0
0546:  RRC     W1,W1
0548:  RRC     W0,W0
054A:  DEC     W8,W8
054C:  BRA     NZ,542
054E:  BRA     56A
0550:  MOV     #28,W7
0552:  CP      W7,W8
0554:  BRA     N,568
0556:  BCLR.B  42.1
0558:  BCLR.B  42.0
055A:  RRC     W3,W3
055C:  RRC     W2,W2
055E:  DEC     W8,W8
0560:  BRA     NZ,556
0562:  BRA     582
0564:  MOV     W2,W0
0566:  MOV     W3,W1
0568:  BRA     5F0
056A:  BTSS    W11.F
056C:  BRA     590
056E:  BTSC    W9.4
0570:  MOV     W12,W11
0572:  NEG     W0,W0
0574:  BRA     Z,57A
0576:  COM.B   W1L,W1L
0578:  BRA     57C
057A:  NEG     W1,W1
057C:  BTSC    W9.4
057E:  BRA     5D6
0580:  BRA     590
0582:  BTSS    W11.F
0584:  BRA     590
0586:  NEG     W2,W2
0588:  BRA     Z,58E
058A:  COM.B   W3L,W3L
058C:  BRA     590
058E:  NEG     W3,W3
0590:  AND     #FF,W5
0592:  BCLR.B  42.1
0594:  BCLR.B  42.0
0596:  ADD     W0,W2,W0
0598:  ADDC.B  W1L,W3L,W1L
059A:  BTSC.B  42.0
059C:  BSET    W9.3
059E:  BTSC    W9.0
05A0:  BRA     5B4
05A2:  BTSC    W9.1
05A4:  BRA     5A8
05A6:  BRA     5BE
05A8:  BTSC    W11.F
05AA:  BRA     5D6
05AC:  BTSC    W9.3
05AE:  BRA     602
05B0:  BSET    W9.6
05B2:  BRA     5F0
05B4:  BTSC    W11.F
05B6:  BRA     5D6
05B8:  BTSC    W9.3
05BA:  BRA     602
05BC:  BRA     5F0
05BE:  BCLR    W9.2
05C0:  BTSC    W11.F
05C2:  BRA     5CC
05C4:  MOV     W10,W11
05C6:  BTSC    W9.3
05C8:  BRA     602
05CA:  BRA     638
05CC:  BSET    W9.4
05CE:  XOR.B   #80,W1L
05D0:  BTSC    W1.7
05D2:  BRA     56E
05D4:  MOV     W10,W11
05D6:  AND     #FF,W1
05D8:  IOR      W0,  W1,W7
05DA:  BRA     Z,5F0
05DC:  BTSC    W1.7
05DE:  BRA     5F0
05E0:  BCLR.B  42.1
05E2:  BCLR.B  42.0
05E4:  RLC     W0,W0
05E6:  RLC     W1,W1
05E8:  DEC     W6,W6
05EA:  BTSC.B  42.1
05EC:  BRA     650
05EE:  BRA     5DC
05F0:  BTSC    W9.0
05F2:  MOV     W10,W11
05F4:  BTSC    W9.1
05F6:  MOV     W12,W11
05F8:  BTSS    W9.5
05FA:  BRA     630
05FC:  BTSC    W10.F
05FE:  BSET    W0.8
0600:  BRA     638
0602:  BSET.B  42.0
0604:  RRC.B   W1L,W1L
0606:  RRC     W0,W0
0608:  BTSC.B  42.0
060A:  BSET    W9.5
060C:  INC     W6,W6
060E:  BRA     Z,650
0610:  BTSS    W9.5
0612:  BRA     624
0614:  INC     W0,W0
0616:  BRA     NZ,624
0618:  INC.B   W1L,W1L
061A:  BRA     NZ,624
061C:  RRC.B   W1L,W1L
061E:  RRC     W0,W0
0620:  INC     W6,W6
0622:  BRA     Z,650
0624:  BTSC    W9.0
0626:  MOV     W10,W11
0628:  BTSC    W9.1
062A:  MOV     W12,W11
062C:  BTSC.B  42.1
062E:  BRA     650
0630:  BTSC    W9.6
0632:  MOV     W10,W11
0634:  BTSC    W9.7
0636:  MOV     W12,W11
0638:  IOR      W0,  W1,W2
063A:  BRA     Z,682
063C:  BCLR    W1.7
063E:  SWAP    W6
0640:  BCLR.B  42.1
0642:  BCLR.B  42.0
0644:  RRC     W6,W6
0646:  XOR     W6,W1,W1
0648:  BSET    W1.F
064A:  BTSS    W11.F
064C:  BCLR    W1.F
064E:  BRA     682
0650:  MOV     #0,W0
0652:  MOV     #0,W1
0654:  BRA     682
0656:  BTSC    W10.F
0658:  XOR     W8,W3,W3
065A:  MOV     W2,W0
065C:  MOV     W3,W1
065E:  BRA     682
0660:  BRA     682
0662:  AND     #FF,W3
0664:  BSET    W3.7
0666:  AND     #FF,W1
0668:  BSET    W1.7
066A:  BTSC    W11.F
066C:  BCLR    W3.7
066E:  BSET    W9.2
0670:  BRA     582
0672:  SUB     W6,W7,W8
0674:  AND     #FF,W1
0676:  BSET    W1.7
0678:  AND     #FF,W3
067A:  BSET    W3.7
067C:  BCLR    W9.1
067E:  BSET    W9.0
0680:  BRA     550
0682:  MOV     #12,W5
0684:  REPEAT  #3
0686:  MOV     [--W15],[W5--]
0688:  MOV     [--W15],W5
068A:  RETURN  
068C:  MOV     W0,W2
068E:  MOV     W1,W3
0690:  MOV.B   W1L,W0L
0692:  SWAP    W0
0694:  BSET    W0.F
0696:  RLC     W1,W1
0698:  SWAP    W1
069A:  ZE      W1,W1
069C:  MOV     #8E,W4
069E:  SUB.B   W4L,W1L,W1L
06A0:  BRA     Z,6AE
06A2:  CP0     W0
06A4:  BRA     Z,6AE
06A6:  BCLR.B  42.0
06A8:  RRC     W0,W0
06AA:  DEC     W1,W1
06AC:  BRA     NZ,6A2
06AE:  BTSS    W3.F
06B0:  BRA     6B6
06B2:  NEG     W0,W0
06B4:  BRA     6B6
06B6:  RETURN  
*
090E:  MOV     W5,[W15++]
0910:  MOV     W6,[W15++]
0912:  MOV     W0,W4
0914:  MOV     W1,W5
0916:  CLR     W0
0918:  CLR     W1
091A:  BCLR    W6.0
091C:  BTSS    W5.F
091E:  BRA     92C
0920:  BSET    W6.0
0922:  NEG     W4,W4
0924:  BRA     Z,92A
0926:  COM     W5,W5
0928:  BRA     92C
092A:  NEG     W5,W5
092C:  IOR      W4,  W5,W3
092E:  BRA     Z,956
0930:  CLR     W2
0932:  MOV     #B6,W1
0934:  BTSC    W2.7
0936:  BRA     946
0938:  BCLR.B  42.0
093A:  RLC     W4,W4
093C:  RLC     W5,W5
093E:  RLC     W0,W0
0940:  RLC     W2,W2
0942:  DEC     W1,W1
0944:  BRA     NZ,934
0946:  SWAP    W1
0948:  BCLR.B  42.0
094A:  RRC     W1,W1
094C:  BCLR    W1.F
094E:  BCLR    W2.7
0950:  XOR.B   W2L,W1L,W1L
0952:  BTSC    W6.0
0954:  BSET    W1.F
0956:  MOV     [--W15],W6
0958:  MOV     [--W15],W5
095A:  RETURN  
095C:  MOV     W5,[W15++]
095E:  MOV     #C,W5
0960:  REPEAT  #4
0962:  MOV     [W5++],[W15++]
0964:  CLR     W9
0966:  XOR     W1,W3,W9
0968:  MOV     W1,W6
096A:  MOV     W0,W5
096C:  MOV     W3,W8
096E:  MOV     W2,W7
0970:  RLC     W1,W1
0972:  SWAP    W1
0974:  ZE      W1,W1
0976:  CP0     W1
0978:  BRA     Z,A16
097A:  RLC     W3,W3
097C:  SWAP    W3
097E:  ZE      W3,W3
0980:  CP0     W3
0982:  BRA     Z,A16
0984:  CLR     W0
0986:  SUB.B   W1L,W3L,W0L
0988:  BRA     NC,990
098A:  ADD.B   #7F,W0L
098C:  BRA     C,A16
098E:  BRA     996
0990:  SUB.B   #81,W0L
0992:  BRA     NC,A16
0994:  BRA     Z,A16
0996:  MOV     W5,W1
0998:  MOV     W6,W2
099A:  BSET    W2.7
099C:  AND     #FF,W2
099E:  AND     #FF,W8
09A0:  BSET    W8.7
09A2:  MOV     #19,W10
09A4:  CLR     W3
09A6:  CLR     W4
09A8:  SUB     W1,W7,W1
09AA:  SUBB    W2,W8,W2
09AC:  BRA     N,9B2
09AE:  BRA     C,9B8
09B0:  BRA     NZ,9BA
09B2:  ADD     W1,W7,W1
09B4:  ADDC    W2,W8,W2
09B6:  BRA     9BA
09B8:  BSET    W4.0
09BA:  DEC     W10,W10
09BC:  BRA     Z,9CC
09BE:  BCLR.B  42.0
09C0:  RLC     W1,W1
09C2:  RLC     W2,W2
09C4:  BCLR.B  42.0
09C6:  RLC     W4,W4
09C8:  RLC     W3,W3
09CA:  BRA     9A8
09CC:  CLR     W10
09CE:  BTSC    W3.8
09D0:  BRA     9D4
09D2:  BRA     9E0
09D4:  BCLR.B  42.0
09D6:  RRC     W3,W3
09D8:  BCLR    W3.7
09DA:  RRC     W4,W4
09DC:  RLC     W10,W10
09DE:  BRA     9E4
09E0:  DEC     W0,W0
09E2:  BRA     Z,A16
09E4:  BTSC    W10.F
09E6:  BRA     NC,9F2
09E8:  RLC     W1,W1
09EA:  RLC     W2,W2
09EC:  SUB     W1,W7,W1
09EE:  SUBB    W2,W8,W2
09F0:  BRA     NC,A04
09F2:  INC     W4,W4
09F4:  BRA     NZ,A04
09F6:  INC     W3,W3
09F8:  BRA     NZ,A04
09FA:  INC     W0,W0
09FC:  BRA     Z,A16
09FE:  BRA     A04
0A00:  DEC     W0,W0
0A02:  BRA     Z,A16
0A04:  SWAP    W0
0A06:  RRC     W0,W1
0A08:  BSET    W1.F
0A0A:  BTSS    W9.F
0A0C:  BCLR    W1.F
0A0E:  BCLR    W3.7
0A10:  XOR.B   W3L,W1L,W1L
0A12:  MOV     W4,W0
0A14:  BRA     A1C
0A16:  MOV     #0,W0
0A18:  MOV     #0,W1
0A1A:  BRA     A1C
0A1C:  MOV     #14,W5
0A1E:  REPEAT  #4
0A20:  MOV     [--W15],[W5--]
0A22:  MOV     [--W15],W5
0A24:  RETURN  
0A26:  MOV     W8,[W15++]
0A28:  MOV     #12,W8
0A2A:  REPEAT  #4
0A2C:  MOV     [W8++],[W15++]
0A2E:  MOV     #0,W9
0A30:  BTSC.B  43.0
0A32:  MOV     #1,W9
0A34:  MOV     W9,[W15++]
0A36:  CLR     W8
0A38:  CLR     W9
0A3A:  CLR     W10
0A3C:  CLR     W11
0A3E:  CLR     W12
0A40:  CLR     W13
0A42:  MOV     #E,W8
0A44:  MOV     #0,W9
0A46:  LNK     #10
0A48:  MOV     W12,[W14+W8]
0A4A:  DEC2    W8,W8
0A4C:  BRA     NN,A48
0A4E:  XOR     W4,W5,W8
0A50:  BRA     NZ,A56
0A52:  XOR     W6,W7,W8
0A54:  BRA     Z,AE6
0A56:  CLR     W8
0A58:  CLR     W13
0A5A:  MOV     W13,[W15++]
0A5C:  BTSS    W3.F
0A5E:  BRA     A74
0A60:  MOV     [--W15],W13
0A62:  BSET    W13.F
0A64:  MOV     W13,[W15++]
0A66:  COM     W3,W3
0A68:  COM     W2,W2
0A6A:  COM     W1,W1
0A6C:  NEG     W0,W0
0A6E:  ADDC    W1,#0,W1
0A70:  ADDC    W2,#0,W2
0A72:  ADDC    W3,#0,W3
0A74:  BTSS    W7.F
0A76:  BRA     A8C
0A78:  MOV     [--W15],W13
0A7A:  BTG     W13.F
0A7C:  MOV     W13,[W15++]
0A7E:  COM     W7,W7
0A80:  COM     W6,W6
0A82:  COM     W5,W5
0A84:  NEG     W4,W4
0A86:  ADDC    W5,#0,W5
0A88:  ADDC    W6,#0,W6
0A8A:  ADDC    W7,#0,W7
0A8C:  MOV     #40,W13
0A8E:  BCLR.B  42.0
0A90:  RLC     W0,W0
0A92:  RLC     W1,W1
0A94:  RLC     W2,W2
0A96:  RLC     W3,W3
0A98:  RLC     W8,W8
0A9A:  RLC     W9,W9
0A9C:  RLC     W10,W10
0A9E:  RLC     W11,W11
0AA0:  CP      W11,W7
0AA2:  BRA     NZ,AAE
0AA4:  CPB     W10,W6
0AA6:  BRA     NZ,AAE
0AA8:  CPB     W9,W5
0AAA:  BRA     NZ,AAE
0AAC:  CPB     W8,W4
0AAE:  BRA     NC,ABA
0AB0:  SUB     W8,W4,W8
0AB2:  SUBB    W9,W5,W9
0AB4:  SUBB    W10,W6,W10
0AB6:  SUBB    W11,W7,W11
0AB8:  BSET.B  42.0
0ABA:  MOV     W8,[W14]
0ABC:  MOV     W9,[W14+#2]
0ABE:  MOV     W10,[W14+#4]
0AC0:  MOV     W11,[W14+#6]
0AC2:  MOV     [W14+#8],W8
0AC4:  MOV     [W14+#A],W9
0AC6:  MOV     [W14+#C],W10
0AC8:  MOV     [W14+#E],W11
0ACA:  RLC     W8,W8
0ACC:  RLC     W9,W9
0ACE:  RLC     W10,W10
0AD0:  RLC     W11,W11
0AD2:  MOV     W8,[W14+#8]
0AD4:  MOV     W9,[W14+#A]
0AD6:  MOV     W10,[W14+#C]
0AD8:  MOV     W11,[W14+#E]
0ADA:  MOV     [W14],W8
0ADC:  MOV     [W14+#2],W9
0ADE:  MOV     [W14+#4],W10
0AE0:  MOV     [W14+#6],W11
0AE2:  DEC     W13,W13
0AE4:  BRA     NZ,A8E
0AE6:  MOV     [W14+#8],W0
0AE8:  MOV     [W14+#A],W1
0AEA:  MOV     [W14+#C],W2
0AEC:  MOV     [W14+#E],W3
0AEE:  MOV     [--W15],W13
0AF0:  BTSS    W13.F
0AF2:  BRA     B02
0AF4:  COM     W3,W3
0AF6:  COM     W2,W2
0AF8:  COM     W1,W1
0AFA:  NEG     W0,W0
0AFC:  ADDC    W1,#0,W1
0AFE:  ADDC    W2,#0,W2
0B00:  ADDC    W3,#0,W3
0B02:  ULNK    
0B04:  BRA     B06
0B06:  MOV     [--W15],W9
0B08:  CP0     W9
0B0A:  BRA     Z,B14
0B0C:  MOV     W8,W0
0B0E:  MOV     W9,W1
0B10:  MOV     W10,W2
0B12:  MOV     W11,W3
0B14:  MOV     #1A,W8
0B16:  REPEAT  #4
0B18:  MOV     [--W15],[W8--]
0B1A:  MOV     [--W15],W8
0B1C:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP)) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
032E:  MOV     W5,[W15++]
0330:  MOV     #4B00,W5
0332:  REPEAT  #19E
0334:  NOP     
0336:  DEC     W5,W5
0338:  BRA     NZ,340
033A:  CLR     85A
033C:  MOV     #0,W0
033E:  BRA     34C
0340:  BTSS.B  232.0
0342:  BRA     332
0344:  PUSH    232
0346:  POP     85A
0348:  MOV     236,W0
034A:  BCLR.B  232.1
034C:  MOV     [--W15],W5
034E:  RETURN  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 256 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14    
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
.................... const unsigned int8 UART_TX_DMA_CHANNEL = 1; 
.................... const IndexType NumberOfDigitizationRequired = BUFFER_SIZE / COEF_LENGTH; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType UARTTXFlag = 0;       // flag to send data out 
.................... FlagType HandShakeFlag = 1;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
....................  
.................... signed int16 fir_coef[COEF_LENGTH] = 
.................... {   
.................... 210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... -246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... 368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... 1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... 1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... 368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... -246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... 210 
.................... }; 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,12D2
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
0244:  PUSH    42
0246:  PUSH    36
0248:  PUSH    32
024A:  MOV     W0,[W15++]
024C:  MOV     #2,W0
024E:  REPEAT  #C
0250:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN);    
0252:  BCLR.B  2C9.6
0254:  BTG.B   2CD.6
....................    if(NormalizeFlag == 1) 
0256:  MOV     12D2,W4
0258:  LSR     W4,#8,W4
025A:  CP.B    W4L,#1
025C:  BRA     NZ,268
....................    { 
....................       read_adc(); 
025E:  BCLR.B  320.0
0260:  BSET.B  320.1
0262:  BTSS.B  320.0
0264:  BRA     262
....................    } 
0266:  BRA     31C
....................    else 
....................    { 
....................       unsigned int8 ADCValue = 0; 
0268:  CLR.B   138E
....................        
....................       if (TriggerFlag != 2) 
026A:  MOV     12D6,W4
026C:  LSR     W4,#8,W4
026E:  CP.B    W4L,#2
0270:  BRA     Z,27E
....................       { 
....................           ADCValue = read_adc(); 
0272:  BCLR.B  320.0
0274:  BSET.B  320.1
0276:  BTSS.B  320.0
0278:  BRA     276
027A:  MOV.B   300,W0L
027C:  MOV.B   W0L,138E
....................       } 
....................        
....................       if (DMAFlag == 0) 
027E:  CP0.B   12D8
0280:  BRA     NZ,290
....................       { 
....................          disable_interrupts(INT_DMA0); 
0282:  BCLR.B  94.4
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0284:  MOV     #4000,W1
0286:  MOV     #0,W2
0288:  REPEAT  #FF
028A:  CLR.B   [W1++]
....................          DMAFlag = 1; 
028C:  MOV.B   #1,W0L
028E:  MOV.B   W0L,12D8
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
0290:  MOV.B   138E,W0L
0292:  CP      A16
0294:  BRA     NZ,2AE
0296:  CP0.B   12D7
0298:  BRA     NZ,2AE
....................       { 
....................          DMA_ADC_BUFFER[0] = ADCValue; 
029A:  MOV.B   138E,W0L
029C:  PUSH    4000
029E:  MOV.B   W0L,[W15-#2]
02A0:  POP     4000
02A2:  MOV     4000,W0
02A4:  CLR.B   1
02A6:  MOV     W0,4000
....................          TriggerFlag = 1; 
02A8:  MOV.B   #1,W0L
02AA:  MOV.B   W0L,12D7
....................       } 
02AC:  BRA     31C
....................       else if( DMA_ADC_BUFFER[1] > ADCValue) 
02AE:  MOV     4002,W0
02B0:  MOV     138E,W4
02B2:  CLR.B   9
02B4:  CP      W4,W0
02B6:  BRA     C,2CC
....................       { 
....................          DMA_ADC_BUFFER[1] = ADCValue; 
02B8:  MOV.B   138E,W0L
02BA:  PUSH    4002
02BC:  MOV.B   W0L,[W15-#2]
02BE:  POP     4002
02C0:  MOV     4002,W0
02C2:  CLR.B   1
02C4:  MOV     W0,4002
....................          TriggerFlag = 2; 
02C6:  MOV.B   #2,W0L
02C8:  MOV.B   W0L,12D7
....................       } 
02CA:  BRA     31C
....................       else if(TriggerFlag == 2) 
02CC:  MOV     12D6,W4
02CE:  LSR     W4,#8,W4
02D0:  CP.B    W4L,#2
02D2:  BRA     NZ,300
....................       { 
....................          if(DMAFlag == 1) 
02D4:  MOV     12D8,W4
02D6:  CP.B    W4L,#1
02D8:  BRA     NZ,2F6
....................          { 
....................             memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
02DA:  MOV     #4000,W1
02DC:  MOV     #0,W2
02DE:  REPEAT  #FF
02E0:  CLR.B   [W1++]
....................             dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
02E2:  BCLR.B  381.7
02E4:  CLR.B   380
02E6:  MOV     #4000,W4
02E8:  MOV     W4,384
02EA:  MOV     #100,W4
02EC:  MOV     W4,38A
02EE:  BSET.B  381.7
....................             enable_interrupts(INT_DMA0); 
02F0:  BSET.B  94.4
....................             DMAFlag = 2; 
02F2:  MOV.B   #2,W0L
02F4:  MOV.B   W0L,12D8
....................          } 
....................           
....................          read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
02F6:  BCLR.B  320.0
02F8:  BSET.B  320.1
02FA:  BTSS.B  320.0
02FC:  BRA     2FA
....................       }   
02FE:  BRA     31C
....................       else 
....................       { 
....................          ErrorCounter++; 
0300:  INC     12CE
0302:  BTSC.B  42.1
0304:  INC     12D0
....................           
....................          if (ErrorCounter >= 3000) 
0306:  MOV     12D0,W4
0308:  CP      W4,#0
030A:  BRA     NC,31A
030C:  BRA     GTU,316
030E:  MOV     12CE,W4
0310:  MOV     #BB8,W3
0312:  CP      W3,W4
0314:  BRA     GTU,31A
....................          { 
....................             NormalizeFlag = 1; 
0316:  MOV.B   #1,W0L
0318:  MOV.B   W0L,12D3
....................          } 
....................           
....................          TriggerFlag = 0; 
031A:  CLR.B   12D7
....................       } 
....................    } 
....................     
.................... } 
....................  
031C:  BCLR.B  84.3
031E:  MOV     #1A,W0
0320:  REPEAT  #C
0322:  MOV     [--W15],[W0--]
0324:  MOV     [--W15],W0
0326:  POP     32
0328:  POP     36
032A:  POP     42
032C:  RETFIE  
.................... #INT_RDA2      // interrupt handler for the uart RS232 communication 
.................... void ISR_UART2() 
*
0350:  PUSH    42
0352:  PUSH    36
0354:  PUSH    32
0356:  MOV     W0,[W15++]
0358:  MOV     #2,W0
035A:  REPEAT  #C
035C:  MOV     [W0++],[W15++]
.................... { 
....................     UARTRX = fgetc(SHARP); // recieve data 
035E:  CALL    32E
0362:  MOV.B   W0L,911
....................     UARTRXFlag = 1;         // serial flag turned high 
0364:  MOV.B   #1,W0L
0366:  MOV.B   W0L,12D4
0368:  BCLR.B  87.6
036A:  MOV     #1A,W0
036C:  REPEAT  #C
036E:  MOV     [--W15],[W0--]
0370:  MOV     [--W15],W0
0372:  POP     32
0374:  POP     36
0376:  POP     42
0378:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0D3E:  MOV     #4444,W0
0D40:  MOV     W0,A4
0D42:  BSET.B  81.7
0D44:  MOV     #46,W0
0D46:  MOV.B   W0L,742
0D48:  MOV     #57,W0
0D4A:  MOV.B   W0L,742
0D4C:  BCLR.B  742.6
0D4E:  MOV     #3F07,W0
0D50:  MOV     W0,6A6
0D52:  MOV     #5,W0
0D54:  MOV     W0,6C6
0D56:  MOV     #46,W0
0D58:  MOV.B   W0L,742
0D5A:  MOV     #57,W0
0D5C:  MOV.B   W0L,742
0D5E:  BSET.B  742.6
0D60:  MOV     #41,W4
0D62:  MOV     W4,744
0D64:  MOV     #32,W4
0D66:  MOV     W4,746
0D68:  CLR     85A
0D6A:  MOV     #8000,W4
0D6C:  MOV     W4,230
0D6E:  MOV     #400,W4
0D70:  MOV     W4,232
0D72:  BSET.B  230.3
0D74:  MOV     #22,W4
0D76:  MOV     W4,238
0D78:  CLR     90E
0D7A:  CLR     A14
0D7C:  CLR     A16
0D7E:  CLR     A18
0D80:  CLR     A1A
0D82:  CLR     A1C
0D84:  CLR     121E
0D86:  CLR     1220
0D88:  CLR     1222
0D8A:  CLR     1224
0D8C:  CLR     1226
0D8E:  CLR     1228
0D90:  CLR     122A
0D92:  CLR     122C
0D94:  CLR     12B2
0D96:  CLR     12B4
0D98:  CLR     12B6
0D9A:  CLR     12B8
0D9C:  CLR     12BA
0D9E:  CLR     12BC
0DA0:  CLR     12BE
0DA2:  CLR     12C0
0DA4:  CLR     12C2
0DA6:  CLR     12C4
0DA8:  CLR     12C6
0DAA:  CLR     12C8
0DAC:  CLR     12CA
0DAE:  CLR     12CC
0DB0:  CLR     12CE
0DB2:  CLR     12D0
0DB4:  CLR.B   12D2
0DB6:  CLR.B   12D3
0DB8:  CLR.B   12D4
0DBA:  CLR.B   12D5
0DBC:  MOV.B   #1,W0L
0DBE:  MOV.B   W0L,12D6
0DC0:  CLR.B   12D7
0DC2:  CLR.B   12D8
0DC4:  MOV     #41,W4
0DC6:  MOV     W4,744
0DC8:  MOV     #32,W4
0DCA:  MOV     W4,746
0DCC:  DISI    #E
0DCE:  MOV     #101,W0
0DD0:  MOV     #743,W1
0DD2:  MOV     #78,W2
0DD4:  MOV     #9A,W3
0DD6:  MOV.B   W2L,[W1]
0DD8:  MOV.B   W3L,[W1]
0DDA:  MOV.B   W0L,743
0DDC:  LSR     W0,#8,W0
0DDE:  MOV     #742,W1
0DE0:  MOV     #46,W2
0DE2:  MOV     #57,W3
0DE4:  MOV.B   W2L,[W1]
0DE6:  MOV.B   W3L,[W1]
0DE8:  MOV.B   W0L,[W1]
0DEA:  SETM    32C
0DEC:  MOV     #3F80,W15
0DEE:  MOV     #3FFF,W0
0DF0:  MOV     W0,20
0DF2:  NOP     
0DF4:  BRA     EE4
0DF6:  DATA    C0,06,08
0DF8:  DATA    5C,00,00
0DFA:  DATA    4B,F0,3F
0DFC:  DATA    5C,0A,58
0DFE:  DATA    F6,3B,8F
0E00:  DATA    00,C0,3C
0E02:  DATA    8B,28,AC
0E04:  DATA    3C,BE,F6
0E06:  DATA    3F,D2,D5
0E08:  DATA    44,16,8C
0E0A:  DATA    15,D7,BF
0E0C:  DATA    69,00,5A
0E0E:  DATA    2E,1B,87
0E10:  DATA    99,3F,9A
0E12:  DATA    5F,AD,4B
0E14:  DATA    91,E4,01
0E16:  DATA    C0,5D,11
0E18:  DATA    2F,92,E4
0E1A:  DATA    81,FB,3F
0E1C:  DATA    38,DA,91
0E1E:  DATA    80,9D,C5
0E20:  DATA    E0,BF,6F
0E22:  DATA    12,C0,B4
0E24:  DATA    C3,09,AB
0E26:  DATA    3F,6B,C1
0E28:  DATA    03,4E,C1
0E2A:  DATA    B5,45,BF
0E2C:  DATA    F7,40,05
0E2E:  DATA    FF,00,5C
0E30:  DATA    EF,3F,F3
0E32:  DATA    A3,E2,F7
0E34:  DATA    D7,FF,01
0E36:  DATA    40,C0,B4
0E38:  DATA    FF,05,3C
0E3A:  DATA    58,FC,3F
0E3C:  DATA    3B,D3,C0
0E3E:  DATA    B5,BA,8C
0E40:  DATA    E2,3F,39
0E42:  DATA    D3,C7,3D
0E44:  DATA    41,79,B2
0E46:  DATA    3F,87,0D
0E48:  DATA    3C,50,D0
0E4A:  DATA    AF,62,3F
0E4C:  DATA    30,4B,8D
0E4E:  DATA    A2,82,AA
0E50:  DATA    04,40,09
0E52:  DATA    A0,40,4A
0E54:  DATA    05,76,03
0E56:  DATA    40,EC,9E
0E58:  DATA    37,88,A6
0E5A:  DATA    44,F0,3F
0E5C:  DATA    8F,12,8D
0E5E:  DATA    29,9A,5B
0E60:  DATA    C7,3F,0E
0E62:  DATA    E0,80,7C
0E64:  DATA    A1,D8,86
0E66:  DATA    3F,29,4B
0E68:  DATA    FB,95,C2
0E6A:  DATA    37,1A,3F
0E6C:  DATA    00,00,80
0E6E:  DATA    80,12,DA
0E70:  DATA    D2,00,59
0E72:  DATA    FF,6A,FF
0E74:  DATA    65,FF,55
0E76:  DATA    FF,40,FF
0E78:  DATA    2B,FF,19
0E7A:  DATA    FF,0D,FF
0E7C:  DATA    0A,FF,11
0E7E:  DATA    FF,26,FF
0E80:  DATA    49,FF,7B
0E82:  DATA    FF,BF,FF
0E84:  DATA    13,00,78
0E86:  DATA    00,ED,00
0E88:  DATA    70,01,FF
0E8A:  DATA    01,98,02
0E8C:  DATA    37,03,D8
0E8E:  DATA    03,79,04
0E90:  DATA    16,05,A9
0E92:  DATA    05,30,06
0E94:  DATA    A7,06,0A
0E96:  DATA    07,57,07
0E98:  DATA    8B,07,A6
0E9A:  DATA    07,A6,07
0E9C:  DATA    8B,07,57
0E9E:  DATA    07,0A,07
0EA0:  DATA    A7,06,30
0EA2:  DATA    06,A9,05
0EA4:  DATA    16,05,79
0EA6:  DATA    04,D8,03
0EA8:  DATA    37,03,98
0EAA:  DATA    02,FF,01
0EAC:  DATA    70,01,ED
0EAE:  DATA    00,78,00
0EB0:  DATA    13,00,BF
0EB2:  DATA    FF,7B,FF
0EB4:  DATA    49,FF,26
0EB6:  DATA    FF,11,FF
0EB8:  DATA    0A,FF,0D
0EBA:  DATA    FF,19,FF
0EBC:  DATA    2B,FF,40
0EBE:  DATA    FF,55,FF
0EC0:  DATA    65,FF,6A
0EC2:  DATA    FF,59,FF
0EC4:  DATA    D2,00,00
0EC6:  DATA    00,00,00
0EC8:  INC     W2,W2
0ECA:  CP      W2,#1
0ECC:  BRA     NZ,ED6
0ECE:  TBLRDL  [W1],W3
0ED0:  TBLRDH  [W1++],W4
0ED2:  MOV.B   6,W0L
0ED4:  RETURN  
0ED6:  CP      W2,#2
0ED8:  BRA     NZ,EDE
0EDA:  MOV.B   7,W0L
0EDC:  RETURN  
0EDE:  MOV.B   8,W0L
0EE0:  CLR     W2
0EE2:  RETURN  
0EE4:  MOV     #0,W6
0EE6:  MOV     #0,W0
0EE8:  MOV     W0,32
0EEA:  MOV     #DF6,W0
0EEC:  MOV     W0,W1
0EEE:  CLR     W2
0EF0:  CALL    EC8
0EF4:  MOV.B   W0L,B
0EF6:  CALL    EC8
0EFA:  MOV.B   W0L,A
0EFC:  CP0     W5
0EFE:  BRA     Z,F32
0F00:  BTSS    W5.F
0F02:  BRA     F12
0F04:  CALL    EC8
0F08:  MOV.B   W0L,D
0F0A:  CALL    EC8
0F0E:  MOV.B   W0L,C
0F10:  BCLR    W5.F
0F12:  BTSS    W5.E
0F14:  BRA     F26
0F16:  BCLR    W5.E
0F18:  DEC     W5,W5
0F1A:  CALL    EC8
0F1E:  MOV.B   W0L,W7L
0F20:  REPEAT  W5
0F22:  MOV.B   W7L,[W6++]
0F24:  BRA     EF0
0F26:  CALL    EC8
0F2A:  MOV.B   W0L,[W6++]
0F2C:  DEC     W5,W5
0F2E:  BRA     NZ,F26
0F30:  BRA     EF0
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0F32:  MOV     #4000,W1
0F34:  MOV     #0,W2
0F36:  REPEAT  #FF
0F38:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0F3A:  MOV     #4200,W1
0F3C:  MOV     #61,W2
0F3E:  MOV.B   #61,W2L
0F40:  REPEAT  #FF
0F42:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0F44:  CLR.B   381
0F46:  MOV.B   #D,W0L
0F48:  MOV.B   W0L,382
0F4A:  MOV     #300,W4
0F4C:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0F4E:  BCLR.B  381.7
0F50:  CLR.B   380
0F52:  MOV     #4000,W4
0F54:  MOV     W4,384
0F56:  MOV     #100,W4
0F58:  MOV     W4,38A
0F5A:  BSET.B  381.7
....................     
....................    setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
0F5C:  MOV.B   #60,W0L
0F5E:  MOV.B   W0L,38D
0F60:  MOV.B   #1F,W0L
0F62:  MOV.B   W0L,38E
0F64:  MOV     #234,W4
0F66:  MOV     W4,394
....................  
....................    enable_interrupts(INT_DMA0); 
0F68:  BSET.B  94.4
....................    enable_interrupts(INT_DMA1); 
0F6A:  BSET.B  95.6
....................     
.................... //!   setup_adc_ports(sAN0, VSS_VDD); 
.................... //!   setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................    setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
0F6C:  MOV     #401,W4
0F6E:  MOV     W4,324
0F70:  MOV     #84E0,W4
0F72:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0F74:  MOV     #FFFE,W4
0F76:  MOV     W4,32C
0F78:  CLR     322
....................     
....................    read_adc(); 
0F7A:  BCLR.B  320.0
0F7C:  BSET.B  320.1
0F7E:  BTSS.B  320.0
0F80:  BRA     F7E
....................     
....................    TimerTicks = 53334; 
0F82:  MOV     #D056,W4
0F84:  MOV     W4,90E
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0F86:  CLR     104
0F88:  PUSH    90E
0F8A:  POP     102
0F8C:  MOV     #8000,W4
0F8E:  MOV     W4,104
....................    enable_interrupts(INT_TIMER1); 
0F90:  BSET.B  94.3
....................    enable_interrupts(INTR_GLOBAL); 
0F92:  BCLR.B  81.7
0F94:  CLR     42
0F96:  BSET.B  81.7
....................     
....................    NormalizeFlag = 1; 
0F98:  MOV.B   #1,W0L
0F9A:  MOV.B   W0L,12D3
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if(DMADoneFlag) 
0F9C:  CP0.B   12D2
0F9E:  BRA     Z,104C
....................       { 
....................          disable_interrupts(INT_DMA0); 
0FA0:  BCLR.B  94.4
.................... //!         for(unsigned int16 i=0; i< BUFFER_SIZE; i++) 
.................... //!         { 
.................... //!               printf("\n\r ADC Val: %c", DMA_ADC_BUFFER[i]); 
.................... //!         } 
....................          for (IndexType Index = 0; Index < NumberOfDigitizationRequired; Index++) 
0FA2:  CLR     135A
0FA4:  CLR     135C
0FA6:  MOV     135C,W4
0FA8:  CP      W4,#0
0FAA:  BRA     GTU,FC8
0FAC:  BRA     NC,FB4
0FAE:  MOV     135A,W4
0FB0:  CP      W4,#4
0FB2:  BRA     C,FC8
....................          { 
....................             AccumulateAnalogData(Index); 
0FB4:  PUSH    135A
0FB6:  POP     1364
0FB8:  PUSH    135C
0FBA:  POP     1366
0FBC:  CALL    6B8
0FC0:  INC     135A
0FC2:  BTSC.B  42.1
0FC4:  INC     135C
0FC6:  BRA     FA6
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
0FC8:  MOV     12D2,W4
0FCA:  LSR     W4,#8,W4
0FCC:  CP.B    W4L,#1
0FCE:  BRA     NZ,FD6
....................          { 
....................             NormalizeData(); 
0FD0:  CALL    B1E
....................          } 
0FD4:  BRA     FD6
....................          else 
....................          { 
....................           
....................          } 
....................           
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DMA_ADC_BUFFER[0], BUFFER_SIZE);     
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
....................          //DMA THE ANALOG DATA ARRAY ALSO  
....................           
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0FD6:  CLR     135E
0FD8:  CLR     1360
0FDA:  MOV     1360,W4
0FDC:  CP      W4,#0
0FDE:  BRA     GTU,1004
0FE0:  BRA     NC,FEA
0FE2:  MOV     135E,W4
0FE4:  MOV     #100,W3
0FE6:  CP      W3,W4
0FE8:  BRA     LEU,1004
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
0FEA:  MOV     #912,W4
0FEC:  MOV     135E,W3
0FEE:  ADD     W3,W4,W0
0FF0:  MOV.B   [W0],W5L
0FF2:  BTSC.B  233.1
0FF4:  BRA     FF2
0FF6:  PUSH    234
0FF8:  MOV.B   W5L,[W15-#2]
0FFA:  POP     234
0FFC:  INC     135E
0FFE:  BTSC.B  42.1
1000:  INC     1360
1002:  BRA     FDA
....................             } 
....................  
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
1004:  CLR     135E
1006:  CLR     1360
1008:  MOV     1360,W4
100A:  CP      W4,#0
100C:  BRA     GTU,1048
100E:  BRA     NC,1018
1010:  MOV     135E,W4
1012:  MOV     #100,W3
1014:  CP      W3,W4
1016:  BRA     LEU,1048
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
1018:  MOV     #2,W4
101A:  CLR.B   9
101C:  MOV     135E,W0
101E:  MOV     1360,W1
1020:  INC     W4,W4
1022:  DEC     W4,W4
1024:  BRA     Z,102C
1026:  SL      W0,W0
1028:  RLC     W1,W1
102A:  BRA     1022
102C:  MOV     #A1E,W4
102E:  ADD     W0,W4,W0
1030:  MOV     #A,W4
1032:  MOV     [W0++],[W4++]
1034:  MOV     [W0++],[W4++]
1036:  BTSC.B  233.1
1038:  BRA     1036
103A:  PUSH    234
103C:  MOV.B   W5L,[W15-#2]
103E:  POP     234
1040:  INC     135E
1042:  BTSC.B  42.1
1044:  INC     1360
1046:  BRA     1008
....................             } 
....................          enable_interrupts(INT_DMA0); 
1048:  BSET.B  94.4
....................          DMADoneFlag = 0; 
104A:  CLR.B   12D2
....................          //DMAFlag = 0; 
....................          //TriggerFlag = 0; 
....................       }       
104C:  BRA     F9C
....................    } 
.................... } 
....................  
104E:  BRA     104E
.................... void AccumulateAnalogData(IndexType NumberOfDigitizationRequired) 
*
06B8:  MOV     W5,[W15++]
06BA:  MOV     W6,[W15++]
06BC:  MOV     W7,[W15++]
06BE:  MOV     #6,W4
06C0:  CLR.B   9
06C2:  PUSH    1364
06C4:  POP     1368
06C6:  PUSH    1366
06C8:  POP     136A
06CA:  INC     W4,W4
06CC:  DEC     W4,W4
06CE:  BRA     Z,6D6
06D0:  SL      1368
06D2:  RLC     136A
06D4:  BRA     6CC
.................... { 
....................    IndexType DMAADCIndex = (NumberOfDigitizationRequired * COEF_LENGTH); 
....................    IndexType Index; 
....................    memset(InputSamples, 0, COEF_LENGTH); 
06D6:  MOV     #122E,W1
06D8:  MOV     #0,W2
06DA:  REPEAT  #3F
06DC:  CLR.B   [W1++]
....................     
....................    for (Index = 0; Index < COEF_LENGTH; Index++) //Todo:: Replace with MemCpy()  
06DE:  CLR     136C
06E0:  CLR     136E
06E2:  MOV     136E,W4
06E4:  CP      W4,#0
06E6:  BRA     GTU,73A
06E8:  BRA     NC,6F2
06EA:  MOV     136C,W4
06EC:  MOV     #40,W3
06EE:  CP      W3,W4
06F0:  BRA     LEU,73A
....................    { 
....................       InputSamples[Index] = DMA_ADC_BUFFER[DMAADCIndex++] >> 4; 
06F2:  MOV     #1,W4
06F4:  CLR.B   9
06F6:  MOV     136C,W0
06F8:  MOV     136E,W1
06FA:  INC     W4,W4
06FC:  DEC     W4,W4
06FE:  BRA     Z,706
0700:  SL      W0,W0
0702:  RLC     W1,W1
0704:  BRA     6FC
0706:  MOV     #122E,W4
0708:  ADD     W0,W4,W5
070A:  MOV     136A,W1
070C:  MOV     1368,W0
070E:  INC     1368
0710:  BTSC.B  42.1
0712:  INC     136A
0714:  MOV.D   W0,W6
0716:  MOV     #1,W4
0718:  CLR.B   9
071A:  MOV.D   W6,W0
071C:  INC     W4,W4
071E:  DEC     W4,W4
0720:  BRA     Z,728
0722:  SL      W0,W0
0724:  RLC     W1,W1
0726:  BRA     71E
0728:  MOV     #4000,W4
072A:  ADD     W0,W4,W0
072C:  MOV     [W0],W6
072E:  LSR     W6,#4,W0
0730:  MOV     W0,[W5]
0732:  INC     136C
0734:  BTSC.B  42.1
0736:  INC     136E
0738:  BRA     6E2
....................    } 
....................     
....................    DMAADCIndex = (NumberOfDigitizationRequired * COEF_LENGTH);   
073A:  MOV     #6,W4
073C:  CLR.B   9
073E:  PUSH    1364
0740:  POP     1368
0742:  PUSH    1366
0744:  POP     136A
0746:  INC     W4,W4
0748:  DEC     W4,W4
074A:  BRA     Z,752
074C:  SL      1368
074E:  RLC     136A
0750:  BRA     748
....................     
....................    for (Index = 0; Index < COEF_LENGTH; Index++) 
0752:  CLR     136C
0754:  CLR     136E
0756:  MOV     136E,W4
0758:  CP      W4,#0
075A:  BRA     GTU,906
075C:  BRA     NC,766
075E:  MOV     136C,W4
0760:  MOV     #40,W3
0762:  CP      W3,W4
0764:  BRA     LEU,906
....................    { 
....................       InputIndex = CurrentIndex;  
0766:  PUSH    12C6
0768:  POP     12C2
076A:  PUSH    12C8
076C:  POP     12C4
....................       Accumulator = 0; 
076E:  CLR     A1A
0770:  CLR     A1C
....................       CoefficentIndex = 0; 
0772:  CLR     12BE
0774:  CLR     12C0
....................        
....................       while (CoefficentIndex < COEF_LENGTH - 1) 
0776:  MOV     12C0,W4
0778:  CP      W4,#0
077A:  BRA     GTU,7FE
077C:  BRA     NC,786
077E:  MOV     12BE,W4
0780:  MOV     #3F,W3
0782:  CP      W3,W4
0784:  BRA     LEU,7FE
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
0786:  MOV     #1,W4
0788:  CLR.B   9
078A:  MOV     12C2,W0
078C:  MOV     12C4,W1
078E:  INC     W4,W4
0790:  DEC     W4,W4
0792:  BRA     Z,79A
0794:  SL      W0,W0
0796:  RLC     W1,W1
0798:  BRA     790
079A:  MOV     #122E,W4
079C:  ADD     W0,W4,W0
079E:  MOV     W0,W4
07A0:  MOV     [W4],W0
07A2:  MOV     W0,W5
07A4:  CLR     W6
07A6:  BTSC    W5.F
07A8:  SETM    W6
07AA:  MOV     #1,W4
07AC:  CLR.B   9
07AE:  MOV     12BE,W0
07B0:  MOV     12C0,W1
07B2:  INC     W4,W4
07B4:  DEC     W4,W4
07B6:  BRA     Z,7BE
07B8:  SL      W0,W0
07BA:  RLC     W1,W1
07BC:  BRA     7B4
07BE:  MOV     #12DA,W4
07C0:  ADD     W0,W4,W0
07C2:  MOV     W0,W4
07C4:  MOV     [W4],W0
07C6:  CLR     W1
07C8:  BTSC    W0.F
07CA:  SETM    W1
07CC:  MOV     W0,W2
07CE:  MOV     W1,W3
07D0:  MOV     W5,W0
07D2:  MOV     W6,W1
07D4:  CALL    37A
07D8:  ADD     A1A
07DA:  MOV     W1,W0
07DC:  ADDC    A1C,W0
07DE:  MOV     W0,A1C
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
07E0:  MOV     12C2,W4
07E2:  XOR     #3F,W4
07E4:  BRA     NZ,7F0
07E6:  CP0     12C4
07E8:  BRA     NZ,7F0
....................          { 
....................             InputIndex = 0; 
07EA:  CLR     12C2
07EC:  CLR     12C4
....................          } 
07EE:  BRA     7F6
....................          else 
....................          { 
....................             InputIndex++; 
07F0:  INC     12C2
07F2:  BTSC.B  42.1
07F4:  INC     12C4
....................          } 
....................          CoefficentIndex++; 
07F6:  INC     12BE
07F8:  BTSC.B  42.1
07FA:  INC     12C0
07FC:  BRA     776
....................       } 
....................        
....................       AnalogData[DMAADCIndex++] = InputSamples[Index]; 
07FE:  MOV     136A,W1
0800:  MOV     1368,W0
0802:  INC     1368
0804:  BTSC.B  42.1
0806:  INC     136A
0808:  MOV     W0,W5
080A:  MOV     W1,W6
080C:  MOV     #912,W4
080E:  ADD     W5,W4,W7
0810:  MOV     #1,W4
0812:  CLR.B   9
0814:  MOV     136C,W0
0816:  MOV     136E,W1
0818:  INC     W4,W4
081A:  DEC     W4,W4
081C:  BRA     Z,824
081E:  SL      W0,W0
0820:  RLC     W1,W1
0822:  BRA     81A
0824:  MOV     #122E,W4
0826:  ADD     W0,W4,W0
0828:  MOV.B   [W0],[W7]
....................        
....................       if (NormalizeFlag == 1) 
082A:  MOV     12D2,W4
082C:  LSR     W4,#8,W4
082E:  CP.B    W4L,#1
0830:  BRA     NZ,852
....................       { 
....................          DigitizedData[DMAADCIndex] = Accumulator; 
0832:  MOV     #2,W4
0834:  CLR.B   9
0836:  MOV     1368,W0
0838:  MOV     136A,W1
083A:  INC     W4,W4
083C:  DEC     W4,W4
083E:  BRA     Z,846
0840:  SL      W0,W0
0842:  RLC     W1,W1
0844:  BRA     83C
0846:  MOV     #A1E,W4
0848:  ADD     W0,W4,W5
084A:  MOV     #A1A,W4
084C:  MOV     [W4++],[W5++]
084E:  MOV     [W4++],[W5++]
....................       } 
0850:  BRA     8E8
....................       else 
....................       { 
....................          float StepOne = Accumulator - AverageAnalogValue; 
....................          float StepTwo = StepOne * AverageMultiplier; 
....................          float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
0852:  MOV     A1A,W0
0854:  MOV     A1C,W1
0856:  CLR     W3
0858:  BTSC    W1.F
085A:  SETM    W3
085C:  MOV     W3,W2
085E:  MOV     1226,W4
0860:  SUB     W0,W4,W0
0862:  MOV     1228,W4
0864:  SUBB    W1,W4,W1
0866:  MOV     122A,W4
0868:  SUBB    W2,W4,W2
086A:  MOV     122C,W4
086C:  SUBB    W3,W4,W3
086E:  CALL    3BC
0872:  MOV     W0,1370
0874:  MOV     W1,1372
0876:  MOV     1370,W0
0878:  MOV     1372,W1
087A:  MOV     12B6,W2
087C:  MOV     12B8,W3
087E:  CALL    41E
0882:  MOV     W0,1374
0884:  MOV     W1,1376
0886:  BCLR.B  43.0
0888:  MOV     1374,W0
088A:  MOV     1376,W1
088C:  MOV     #0,W2
088E:  MOV     #42FE,W3
0890:  CALL    4E2
0894:  MOV     W0,1378
0896:  MOV     W1,137A
....................          //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................          //ConversionValue = (unsigned int8)OutputValue; 
....................          ConversionValue = (unsigned int8)StepThree; 
0898:  MOV     1378,W0
089A:  MOV     137A,W1
089C:  CALL    68C
08A0:  MOV.B   W0L,910
....................          DebugAccumulator[DMAADCIndex] = Accumulator; 
08A2:  MOV     #2,W4
08A4:  CLR.B   9
08A6:  MOV     1368,W0
08A8:  MOV     136A,W1
08AA:  INC     W4,W4
08AC:  DEC     W4,W4
08AE:  BRA     Z,8B6
08B0:  SL      W0,W0
08B2:  RLC     W1,W1
08B4:  BRA     8AC
08B6:  MOV     #E1E,W4
08B8:  ADD     W0,W4,W5
08BA:  MOV     #A1A,W4
08BC:  MOV     [W4++],[W5++]
08BE:  MOV     [W4++],[W5++]
....................          DigitizedData[DMAADCIndex] = ConversionValue; 
08C0:  MOV     #2,W4
08C2:  CLR.B   9
08C4:  MOV     1368,W0
08C6:  MOV     136A,W1
08C8:  INC     W4,W4
08CA:  DEC     W4,W4
08CC:  BRA     Z,8D4
08CE:  SL      W0,W0
08D0:  RLC     W1,W1
08D2:  BRA     8CA
08D4:  MOV     #A1E,W4
08D6:  ADD     W0,W4,W5
08D8:  MOV     910,W0
08DA:  MOV.B   W0L,[W5+#0]
08DC:  MOV.B   #0,W0L
08DE:  MOV.B   W0L,[W5+#1]
08E0:  MOV.B   #0,W0L
08E2:  MOV.B   W0L,[W5+#2]
08E4:  MOV.B   #0,W0L
08E6:  MOV.B   W0L,[W5+#3]
....................       } 
....................        
....................       if (CurrentIndex == 0) 
08E8:  CP0     12C6
08EA:  BRA     NZ,8F8
08EC:  CP0     12C8
08EE:  BRA     NZ,8F8
....................       { 
....................         CurrentIndex = COEF_LENGTH - 1; 
08F0:  MOV     #3F,W4
08F2:  MOV     W4,12C6
08F4:  CLR     12C8
....................       } 
08F6:  BRA     8FE
....................       else 
....................       { 
....................         CurrentIndex--; 
08F8:  DEC     12C6
08FA:  BTSS.B  42.0
08FC:  DEC     12C8
....................       } 
08FE:  INC     136C
0900:  BTSC.B  42.1
0902:  INC     136E
0904:  BRA     756
....................    } 
0906:  MOV     [--W15],W7
0908:  MOV     [--W15],W6
090A:  MOV     [--W15],W5
090C:  RETURN  
....................    
.................... } 
....................  
.................... void NormalizeData() 
*
0B1E:  MOV     W5,[W15++]
0B20:  MOV     W6,[W15++]
0B22:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0B24:  MOV     12D0,W4
0B26:  CP      W4,#0
0B28:  BRA     GTU,CC8
0B2A:  BRA     NC,B34
0B2C:  MOV     12CE,W4
0B2E:  MOV     #BB8,W3
0B30:  CP      W3,W4
0B32:  BRA     LEU,CC8
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0B34:  PUSH    B1E
0B36:  POP     121E
0B38:  PUSH    B20
0B3A:  POP     1220
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0B3C:  PUSH    B1E
0B3E:  POP     1222
0B40:  PUSH    B20
0B42:  POP     1224
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0B44:  PUSH    4080
0B46:  POP     A14
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0B48:  MOV     #41,W4
0B4A:  MOV     W4,1364
0B4C:  CLR     1366
0B4E:  MOV     1366,W4
0B50:  CP      W4,#0
0B52:  BRA     GTU,C78
0B54:  BRA     NC,B5E
0B56:  MOV     1364,W4
0B58:  MOV     #100,W3
0B5A:  CP      W3,W4
0B5C:  BRA     LEU,C78
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0B5E:  MOV     #2,W4
0B60:  CLR.B   9
0B62:  MOV     1364,W0
0B64:  MOV     1366,W1
0B66:  INC     W4,W4
0B68:  DEC     W4,W4
0B6A:  BRA     Z,B72
0B6C:  SL      W0,W0
0B6E:  RLC     W1,W1
0B70:  BRA     B68
0B72:  MOV     #A1E,W4
0B74:  ADD     W0,W4,W0
0B76:  MOV     W0,W4
0B78:  MOV     #0,W3
0B7A:  MOV     [W4++],[W3++]
0B7C:  MOV     [W4++],[W3++]
0B7E:  MOV     1224,W4
0B80:  CP      W4,W1
0B82:  BRA     LT,BAA
0B84:  BRA     GT,B8C
0B86:  MOV     1222,W4
0B88:  CP      W4,W0
0B8A:  BRA     LEU,BAA
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0B8C:  MOV     #2,W4
0B8E:  CLR.B   9
0B90:  MOV     1364,W0
0B92:  MOV     1366,W1
0B94:  INC     W4,W4
0B96:  DEC     W4,W4
0B98:  BRA     Z,BA0
0B9A:  SL      W0,W0
0B9C:  RLC     W1,W1
0B9E:  BRA     B96
0BA0:  MOV     #A1E,W4
0BA2:  ADD     W0,W4,W0
0BA4:  MOV     #1222,W4
0BA6:  MOV     [W0++],[W4++]
0BA8:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0BAA:  MOV     #2,W4
0BAC:  CLR.B   9
0BAE:  MOV     1364,W0
0BB0:  MOV     1366,W1
0BB2:  INC     W4,W4
0BB4:  DEC     W4,W4
0BB6:  BRA     Z,BBE
0BB8:  SL      W0,W0
0BBA:  RLC     W1,W1
0BBC:  BRA     BB4
0BBE:  MOV     #A1E,W4
0BC0:  ADD     W0,W4,W0
0BC2:  MOV     W0,W4
0BC4:  MOV     #0,W3
0BC6:  MOV     [W4++],[W3++]
0BC8:  MOV     [W4++],[W3++]
0BCA:  MOV     1220,W4
0BCC:  CP      W4,W1
0BCE:  BRA     GT,BF6
0BD0:  BRA     LT,BD8
0BD2:  MOV     121E,W4
0BD4:  CP      W4,W0
0BD6:  BRA     C,BF6
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0BD8:  MOV     #2,W4
0BDA:  CLR.B   9
0BDC:  MOV     1364,W0
0BDE:  MOV     1366,W1
0BE0:  INC     W4,W4
0BE2:  DEC     W4,W4
0BE4:  BRA     Z,BEC
0BE6:  SL      W0,W0
0BE8:  RLC     W1,W1
0BEA:  BRA     BE2
0BEC:  MOV     #A1E,W4
0BEE:  ADD     W0,W4,W0
0BF0:  MOV     #121E,W4
0BF2:  MOV     [W0++],[W4++]
0BF4:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0BF6:  MOV     #1,W4
0BF8:  CLR.B   9
0BFA:  MOV     1364,W0
0BFC:  MOV     1366,W1
0BFE:  INC     W4,W4
0C00:  DEC     W4,W4
0C02:  BRA     Z,C0A
0C04:  SL      W0,W0
0C06:  RLC     W1,W1
0C08:  BRA     C00
0C0A:  MOV     #4000,W4
0C0C:  ADD     W0,W4,W0
0C0E:  MOV     W0,W4
0C10:  MOV     [W4],W0
0C12:  MOV     A14,W4
0C14:  CP      W4,W0
0C16:  BRA     LEU,C34
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0C18:  MOV     #1,W4
0C1A:  CLR.B   9
0C1C:  MOV     1364,W0
0C1E:  MOV     1366,W1
0C20:  INC     W4,W4
0C22:  DEC     W4,W4
0C24:  BRA     Z,C2C
0C26:  SL      W0,W0
0C28:  RLC     W1,W1
0C2A:  BRA     C22
0C2C:  MOV     #4000,W4
0C2E:  ADD     W0,W4,W0
0C30:  MOV     [W0],[W15++]
0C32:  POP     A14
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0C34:  MOV     #2,W4
0C36:  CLR.B   9
0C38:  MOV     1364,W0
0C3A:  MOV     1366,W1
0C3C:  INC     W4,W4
0C3E:  DEC     W4,W4
0C40:  BRA     Z,C48
0C42:  SL      W0,W0
0C44:  RLC     W1,W1
0C46:  BRA     C3E
0C48:  MOV     #A1E,W4
0C4A:  ADD     W0,W4,W0
0C4C:  MOV     W0,W4
0C4E:  MOV     #0,W3
0C50:  MOV     [W4++],[W3++]
0C52:  MOV     [W4++],[W3++]
0C54:  CLR     W3
0C56:  BTSC    W1.F
0C58:  SETM    W3
0C5A:  MOV     W3,W2
0C5C:  ADD     1226
0C5E:  MOV     W1,W0
0C60:  ADDC    1228,W0
0C62:  MOV     W0,1228
0C64:  MOV     122A,W4
0C66:  ADDC    W2,W4,W0
0C68:  MOV     W0,122A
0C6A:  MOV     122C,W4
0C6C:  ADDC    W3,W4,W0
0C6E:  MOV     W0,122C
0C70:  INC     1364
0C72:  BTSC.B  42.1
0C74:  INC     1366
0C76:  BRA     B4E
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0C78:  MOV     121E,W4
0C7A:  MOV     1222,W3
0C7C:  SUB     W4,W3,W0
0C7E:  MOV     1220,W4
0C80:  MOV     1224,W3
0C82:  SUBB    W4,W3,W1
0C84:  CALL    90E
0C88:  MOV     W0,12B2
0C8A:  MOV     W1,12B4
....................       AverageMultiplier = ((float)ADC_MAX_DATA_VALUE / AverageDivider); 
0C8C:  MOV     #0,W0
0C8E:  MOV     #437F,W1
0C90:  MOV     12B2,W2
0C92:  MOV     12B4,W3
0C94:  CALL    95C
0C98:  MOV     W0,12B6
0C9A:  MOV     W1,12B8
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0C9C:  BCLR.B  43.0
0C9E:  MOV     1226,W0
0CA0:  MOV     1228,W1
0CA2:  MOV     122A,W2
0CA4:  MOV     122C,W3
0CA6:  MOV     #C0,W4
0CA8:  MOV     #0,W5
0CAA:  MOV     #0,W6
0CAC:  MOV     #0,W7
0CAE:  CALL    A26
0CB2:  MOV     W0,1226
0CB4:  MOV     W1,1228
0CB6:  MOV     W2,122A
0CB8:  MOV     W3,122C
....................        
....................       TriggerValue = InitialTriggerValue; 
0CBA:  PUSH    A14
0CBC:  POP     A16
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE);           
0CBE:  MOV     #A1E,W1
0CC0:  MOV     #0,W2
0CC2:  REPEAT  #FF
0CC4:  CLR.B   [W1++]
....................    }   
0CC6:  BRA     D30
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0CC8:  PUSH    4080
0CCA:  POP     A14
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0CCC:  MOV     #41,W4
0CCE:  MOV     W4,1368
0CD0:  CLR     136A
0CD2:  MOV     136A,W4
0CD4:  CP      W4,#0
0CD6:  BRA     GTU,D28
0CD8:  BRA     NC,CE2
0CDA:  MOV     1368,W4
0CDC:  MOV     #100,W3
0CDE:  CP      W3,W4
0CE0:  BRA     LEU,D28
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0CE2:  MOV     #1,W4
0CE4:  CLR.B   9
0CE6:  MOV     1368,W0
0CE8:  MOV     136A,W1
0CEA:  INC     W4,W4
0CEC:  DEC     W4,W4
0CEE:  BRA     Z,CF6
0CF0:  SL      W0,W0
0CF2:  RLC     W1,W1
0CF4:  BRA     CEC
0CF6:  MOV     #4000,W4
0CF8:  ADD     W0,W4,W0
0CFA:  MOV     W0,W4
0CFC:  MOV     [W4],W0
0CFE:  MOV     A14,W4
0D00:  CP      W4,W0
0D02:  BRA     LEU,D20
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0D04:  MOV     #1,W4
0D06:  CLR.B   9
0D08:  MOV     1368,W0
0D0A:  MOV     136A,W1
0D0C:  INC     W4,W4
0D0E:  DEC     W4,W4
0D10:  BRA     Z,D18
0D12:  SL      W0,W0
0D14:  RLC     W1,W1
0D16:  BRA     D0E
0D18:  MOV     #4000,W4
0D1A:  ADD     W0,W4,W0
0D1C:  MOV     [W0],[W15++]
0D1E:  POP     A14
....................         }              
0D20:  INC     1368
0D22:  BTSC.B  42.1
0D24:  INC     136A
0D26:  BRA     CD2
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0D28:  PUSH    A14
0D2A:  POP     A16
....................       ErrorCounter = 0;  
0D2C:  CLR     12CE
0D2E:  CLR     12D0
....................    } 
....................     
....................    NormalizeFlag = 0; 
0D30:  CLR.B   12D3
....................    CurrentIndex = 0; 
0D32:  CLR     12C6
0D34:  CLR     12C8
0D36:  MOV     [--W15],W7
0D38:  MOV     [--W15],W6
0D3A:  MOV     [--W15],W5
0D3C:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
