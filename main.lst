CCS PCD C Compiler, Version 5.008, 5967               22-Nov-22 21:24

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4224 bytes (10%)
                           Largest free fragment is 39808
               RAM used:   3537 (22%) at main() level
                           3576 (22%) worst case
               Stack used: 68 locations (52 in main + 16 for interrupts)
               Stack size: 30

*
0000:  GOTO    E86
*
001A:  DATA    9A,02,00
001C:  DATA    00,02,00
*
0030:  DATA    2E,02,00
*
0050:  DATA    70,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
0368:  MOV     W5,[W15++]
036A:  MOV     #C,W5
036C:  REPEAT  #3
036E:  MOV     [W5++],[W15++]
0370:  MUL.UU  W0,W2,W4
0372:  BTSS    W3.F
0374:  BRA     37A
0376:  MUL.SS  W0,W3,W6
0378:  BRA     37C
037A:  MUL.UU  W0,W3,W6
037C:  BCLR.B  42.0
037E:  ADD     W6,W5,W5
0380:  ADDC    W7,#0,W8
0382:  BTSS    W1.F
0384:  BRA     38A
0386:  MUL.SS  W1,W2,W6
0388:  BRA     38C
038A:  MUL.UU  W1,W2,W6
038C:  ADDC    W6,W5,W5
038E:  ADDC    W7,W8,W8
0390:  ADDC    #0,W9
0392:  MUL.SS  W1,W3,W6
0394:  ADDC    W6,W8,W8
0396:  ADDC    W9,W7,W7
0398:  MOV     W7,W3
039A:  MOV     W8,W2
039C:  MOV     W5,W1
039E:  MOV     W4,W0
03A0:  MOV     #12,W5
03A2:  REPEAT  #3
03A4:  MOV     [--W15],[W5--]
03A6:  MOV     [--W15],W5
03A8:  RETURN  
03AA:  MOV     W5,[W15++]
03AC:  MOV     #C,W5
03AE:  REPEAT  #3
03B0:  MOV     [W5++],[W15++]
03B2:  MOV     W0,W4
03B4:  MOV     W1,W5
03B6:  MOV     W2,W6
03B8:  MOV     W3,W7
03BA:  CLR     W0
03BC:  CLR     W1
03BE:  CLR     W2
03C0:  CLR     W3
03C2:  BCLR    W8.0
03C4:  BTSS    W7.F
03C6:  BRA     3D2
03C8:  BSET    W6.0
03CA:  NEG     W4,W4
03CC:  COM     W5,W5
03CE:  COM     W6,W6
03D0:  COM     W7,W7
03D2:  XOR     W4,W5,W9
03D4:  BRA     NZ,3DA
03D6:  XOR     W6,W7,W9
03D8:  BRA     Z,402
03DA:  MOV     #D6,W1
03DC:  BTSC    W2.7
03DE:  BRA     3F2
03E0:  BCLR.B  42.0
03E2:  RLC     W4,W4
03E4:  RLC     W5,W5
03E6:  RLC     W6,W6
03E8:  RLC     W7,W7
03EA:  RLC     W0,W0
03EC:  RLC     W2,W2
03EE:  DEC     W1,W1
03F0:  BRA     NZ,3DC
03F2:  SWAP    W1
03F4:  BCLR.B  42.0
03F6:  RRC     W1,W1
03F8:  BCLR    W1.F
03FA:  BCLR    W2.7
03FC:  XOR.B   W2L,W1L,W1L
03FE:  BTSC    W6.0
0400:  BSET    W1.F
0402:  MOV     #12,W5
0404:  REPEAT  #3
0406:  MOV     [--W15],[W5--]
0408:  MOV     [--W15],W5
040A:  RETURN  
040C:  MOV     W5,[W15++]
040E:  MOV     #C,W5
0410:  REPEAT  #4
0412:  MOV     [W5++],[W15++]
0414:  MOV     W0,W4
0416:  MOV     W1,W5
0418:  MOV     W3,W7
041A:  MOV     W2,W6
041C:  BCLR.B  42.0
041E:  BCLR.B  42.1
0420:  RLC     W1,W1
0422:  SWAP    W1
0424:  AND     #FF,W1
0426:  CP0     W1
0428:  BRA     Z,4C0
042A:  BCLR.B  42.0
042C:  BCLR.B  42.1
042E:  RLC     W3,W3
0430:  SWAP    W3
0432:  AND     #FF,W3
0434:  CP0     W3
0436:  BRA     Z,4C0
0438:  ZE      W0,W0
043A:  ADD.B   W3L,W1L,W0L
043C:  BRA     C,446
043E:  SUB     #7F,W0
0440:  BRA     Z,4C0
0442:  BRA     NC,4C0
0444:  BRA     44A
0446:  ADD.B   #81,W0L
0448:  BRA     C,4C0
044A:  XOR     W5,W7,W10
044C:  BCLR.B  42.0
044E:  BCLR.B  42.1
0450:  AND     #FF,W5
0452:  BSET    W5.7
0454:  BCLR.B  42.0
0456:  AND     #FF,W7
0458:  BSET    W7.7
045A:  MUL.UU  W4,W6,W2
045C:  MUL.UU  W5,W6,W8
045E:  ADDC    W8,W3,W3
0460:  MOV     W9,W1
0462:  BTSC.B  42.0
0464:  INC     W1,W1
0466:  BCLR.B  42.0
0468:  MUL.UU  W7,W4,W8
046A:  ADDC    W8,W3,W3
046C:  ADDC    W9,W1,W1
046E:  MUL.UU  W5,W7,W8
0470:  ADDC    W8,W1,W1
0472:  INC     W0,W0
0474:  CP0     W1
0476:  BTSC.B  42.1
0478:  BRA     47C
047A:  BRA     482
047C:  CP0     W3
047E:  BTSC.B  42.1
0480:  BRA     48C
0482:  BTSC    W1.F
0484:  BRA     48C
0486:  RLC     W3,W3
0488:  RLC     W1,W1
048A:  DEC     W0,W0
048C:  MOV     W1,W2
048E:  BCLR.B  42.0
0490:  BTSS    W3.7
0492:  BRA     4A6
0494:  MOV     #FF00,W7
0496:  AND     W3,W7,W3
0498:  ADD     #100,W3
049A:  ADDC    W2,#0,W2
049C:  CP0     W2
049E:  BRA     NZ,4A6
04A0:  CP0     W3
04A2:  BRA     NZ,4A6
04A4:  INC     W0,W0
04A6:  SWAP    W0
04A8:  BCLR.B  42.0
04AA:  BCLR.B  42.1
04AC:  RRC     W0,W1
04AE:  BTSC    W10.F
04B0:  BSET    W1.F
04B2:  BCLR    W2.F
04B4:  SWAP    W2
04B6:  XOR.B   W2L,W1L,W1L
04B8:  SWAP    W3
04BA:  MOV.B   W3L,W2L
04BC:  MOV     W2,W0
04BE:  BRA     4C6
04C0:  MOV     #0,W0
04C2:  MOV     #0,W1
04C4:  BRA     4C6
04C6:  MOV     #14,W5
04C8:  REPEAT  #4
04CA:  MOV     [--W15],[W5--]
04CC:  MOV     [--W15],W5
04CE:  RETURN  
04D0:  MOV     W5,[W15++]
04D2:  MOV     #C,W5
04D4:  REPEAT  #3
04D6:  MOV     [W5++],[W15++]
04D8:  CLR     W9
04DA:  MOV     #8000,W8
04DC:  BTSC.B  43.0
04DE:  XOR     W8,W3,W3
04E0:  CP0     W0
04E2:  BRA     NZ,4EA
04E4:  MOV     #7FFF,W10
04E6:  AND     W1,W10,W10
04E8:  BTSS.B  42.1
04EA:  MOV     W1,W10
04EC:  XOR     W3,W10,W11
04EE:  MOV     W1,W6
04F0:  MOV     W3,W7
04F2:  MOV     W3,W12
04F4:  BCLR.B  42.1
04F6:  BCLR.B  42.0
04F8:  RLC     W6,W6
04FA:  SWAP    W6
04FC:  AND     #FF,W6
04FE:  CP0     W6
0500:  BRA     Z,644
0502:  BCLR.B  42.1
0504:  BCLR.B  42.0
0506:  RLC     W7,W7
0508:  SWAP    W7
050A:  AND     #FF,W7
050C:  CP0     W7
050E:  BRA     Z,64E
0510:  BCLR.B  42.1
0512:  BCLR.B  42.0
0514:  CP      W7,W6
0516:  BRA     Z,650
0518:  BRA     N,660
051A:  BCLR    W9.0
051C:  BSET    W9.1
051E:  SUB     W7,W6,W8
0520:  MOV     W7,W6
0522:  AND     #FF,W1
0524:  BSET    W1.7
0526:  AND     #FF,W3
0528:  BSET    W3.7
052A:  MOV     #28,W7
052C:  CP      W7,W8
052E:  BRA     N,552
0530:  BCLR.B  42.1
0532:  BCLR.B  42.0
0534:  RRC     W1,W1
0536:  RRC     W0,W0
0538:  DEC     W8,W8
053A:  BRA     NZ,530
053C:  BRA     558
053E:  MOV     #28,W7
0540:  CP      W7,W8
0542:  BRA     N,556
0544:  BCLR.B  42.1
0546:  BCLR.B  42.0
0548:  RRC     W3,W3
054A:  RRC     W2,W2
054C:  DEC     W8,W8
054E:  BRA     NZ,544
0550:  BRA     570
0552:  MOV     W2,W0
0554:  MOV     W3,W1
0556:  BRA     5DE
0558:  BTSS    W11.F
055A:  BRA     57E
055C:  BTSC    W9.4
055E:  MOV     W12,W11
0560:  NEG     W0,W0
0562:  BRA     Z,568
0564:  COM.B   W1L,W1L
0566:  BRA     56A
0568:  NEG     W1,W1
056A:  BTSC    W9.4
056C:  BRA     5C4
056E:  BRA     57E
0570:  BTSS    W11.F
0572:  BRA     57E
0574:  NEG     W2,W2
0576:  BRA     Z,57C
0578:  COM.B   W3L,W3L
057A:  BRA     57E
057C:  NEG     W3,W3
057E:  AND     #FF,W5
0580:  BCLR.B  42.1
0582:  BCLR.B  42.0
0584:  ADD     W0,W2,W0
0586:  ADDC.B  W1L,W3L,W1L
0588:  BTSC.B  42.0
058A:  BSET    W9.3
058C:  BTSC    W9.0
058E:  BRA     5A2
0590:  BTSC    W9.1
0592:  BRA     596
0594:  BRA     5AC
0596:  BTSC    W11.F
0598:  BRA     5C4
059A:  BTSC    W9.3
059C:  BRA     5F0
059E:  BSET    W9.6
05A0:  BRA     5DE
05A2:  BTSC    W11.F
05A4:  BRA     5C4
05A6:  BTSC    W9.3
05A8:  BRA     5F0
05AA:  BRA     5DE
05AC:  BCLR    W9.2
05AE:  BTSC    W11.F
05B0:  BRA     5BA
05B2:  MOV     W10,W11
05B4:  BTSC    W9.3
05B6:  BRA     5F0
05B8:  BRA     626
05BA:  BSET    W9.4
05BC:  XOR.B   #80,W1L
05BE:  BTSC    W1.7
05C0:  BRA     55C
05C2:  MOV     W10,W11
05C4:  AND     #FF,W1
05C6:  IOR      W0,  W1,W7
05C8:  BRA     Z,5DE
05CA:  BTSC    W1.7
05CC:  BRA     5DE
05CE:  BCLR.B  42.1
05D0:  BCLR.B  42.0
05D2:  RLC     W0,W0
05D4:  RLC     W1,W1
05D6:  DEC     W6,W6
05D8:  BTSC.B  42.1
05DA:  BRA     63E
05DC:  BRA     5CA
05DE:  BTSC    W9.0
05E0:  MOV     W10,W11
05E2:  BTSC    W9.1
05E4:  MOV     W12,W11
05E6:  BTSS    W9.5
05E8:  BRA     61E
05EA:  BTSC    W10.F
05EC:  BSET    W0.8
05EE:  BRA     626
05F0:  BSET.B  42.0
05F2:  RRC.B   W1L,W1L
05F4:  RRC     W0,W0
05F6:  BTSC.B  42.0
05F8:  BSET    W9.5
05FA:  INC     W6,W6
05FC:  BRA     Z,63E
05FE:  BTSS    W9.5
0600:  BRA     612
0602:  INC     W0,W0
0604:  BRA     NZ,612
0606:  INC.B   W1L,W1L
0608:  BRA     NZ,612
060A:  RRC.B   W1L,W1L
060C:  RRC     W0,W0
060E:  INC     W6,W6
0610:  BRA     Z,63E
0612:  BTSC    W9.0
0614:  MOV     W10,W11
0616:  BTSC    W9.1
0618:  MOV     W12,W11
061A:  BTSC.B  42.1
061C:  BRA     63E
061E:  BTSC    W9.6
0620:  MOV     W10,W11
0622:  BTSC    W9.7
0624:  MOV     W12,W11
0626:  IOR      W0,  W1,W2
0628:  BRA     Z,670
062A:  BCLR    W1.7
062C:  SWAP    W6
062E:  BCLR.B  42.1
0630:  BCLR.B  42.0
0632:  RRC     W6,W6
0634:  XOR     W6,W1,W1
0636:  BSET    W1.F
0638:  BTSS    W11.F
063A:  BCLR    W1.F
063C:  BRA     670
063E:  MOV     #0,W0
0640:  MOV     #0,W1
0642:  BRA     670
0644:  BTSC    W10.F
0646:  XOR     W8,W3,W3
0648:  MOV     W2,W0
064A:  MOV     W3,W1
064C:  BRA     670
064E:  BRA     670
0650:  AND     #FF,W3
0652:  BSET    W3.7
0654:  AND     #FF,W1
0656:  BSET    W1.7
0658:  BTSC    W11.F
065A:  BCLR    W3.7
065C:  BSET    W9.2
065E:  BRA     570
0660:  SUB     W6,W7,W8
0662:  AND     #FF,W1
0664:  BSET    W1.7
0666:  AND     #FF,W3
0668:  BSET    W3.7
066A:  BCLR    W9.1
066C:  BSET    W9.0
066E:  BRA     53E
0670:  MOV     #12,W5
0672:  REPEAT  #3
0674:  MOV     [--W15],[W5--]
0676:  MOV     [--W15],W5
0678:  RETURN  
067A:  MOV     W0,W2
067C:  MOV     W1,W3
067E:  MOV.B   W1L,W0L
0680:  SWAP    W0
0682:  BSET    W0.F
0684:  RLC     W1,W1
0686:  SWAP    W1
0688:  ZE      W1,W1
068A:  MOV     #8E,W4
068C:  SUB.B   W4L,W1L,W1L
068E:  BRA     Z,69C
0690:  CP0     W0
0692:  BRA     Z,69C
0694:  BCLR.B  42.0
0696:  RRC     W0,W0
0698:  DEC     W1,W1
069A:  BRA     NZ,690
069C:  BTSS    W3.F
069E:  BRA     6A4
06A0:  NEG     W0,W0
06A2:  BRA     6A4
06A4:  RETURN  
*
0856:  MOV     W5,[W15++]
0858:  MOV     W6,[W15++]
085A:  MOV     W0,W4
085C:  MOV     W1,W5
085E:  CLR     W0
0860:  CLR     W1
0862:  BCLR    W6.0
0864:  BTSS    W5.F
0866:  BRA     874
0868:  BSET    W6.0
086A:  NEG     W4,W4
086C:  BRA     Z,872
086E:  COM     W5,W5
0870:  BRA     874
0872:  NEG     W5,W5
0874:  IOR      W4,  W5,W3
0876:  BRA     Z,89E
0878:  CLR     W2
087A:  MOV     #B6,W1
087C:  BTSC    W2.7
087E:  BRA     88E
0880:  BCLR.B  42.0
0882:  RLC     W4,W4
0884:  RLC     W5,W5
0886:  RLC     W0,W0
0888:  RLC     W2,W2
088A:  DEC     W1,W1
088C:  BRA     NZ,87C
088E:  SWAP    W1
0890:  BCLR.B  42.0
0892:  RRC     W1,W1
0894:  BCLR    W1.F
0896:  BCLR    W2.7
0898:  XOR.B   W2L,W1L,W1L
089A:  BTSC    W6.0
089C:  BSET    W1.F
089E:  MOV     [--W15],W6
08A0:  MOV     [--W15],W5
08A2:  RETURN  
08A4:  MOV     W5,[W15++]
08A6:  MOV     #C,W5
08A8:  REPEAT  #4
08AA:  MOV     [W5++],[W15++]
08AC:  CLR     W9
08AE:  XOR     W1,W3,W9
08B0:  MOV     W1,W6
08B2:  MOV     W0,W5
08B4:  MOV     W3,W8
08B6:  MOV     W2,W7
08B8:  RLC     W1,W1
08BA:  SWAP    W1
08BC:  ZE      W1,W1
08BE:  CP0     W1
08C0:  BRA     Z,95E
08C2:  RLC     W3,W3
08C4:  SWAP    W3
08C6:  ZE      W3,W3
08C8:  CP0     W3
08CA:  BRA     Z,95E
08CC:  CLR     W0
08CE:  SUB.B   W1L,W3L,W0L
08D0:  BRA     NC,8D8
08D2:  ADD.B   #7F,W0L
08D4:  BRA     C,95E
08D6:  BRA     8DE
08D8:  SUB.B   #81,W0L
08DA:  BRA     NC,95E
08DC:  BRA     Z,95E
08DE:  MOV     W5,W1
08E0:  MOV     W6,W2
08E2:  BSET    W2.7
08E4:  AND     #FF,W2
08E6:  AND     #FF,W8
08E8:  BSET    W8.7
08EA:  MOV     #19,W10
08EC:  CLR     W3
08EE:  CLR     W4
08F0:  SUB     W1,W7,W1
08F2:  SUBB    W2,W8,W2
08F4:  BRA     N,8FA
08F6:  BRA     C,900
08F8:  BRA     NZ,902
08FA:  ADD     W1,W7,W1
08FC:  ADDC    W2,W8,W2
08FE:  BRA     902
0900:  BSET    W4.0
0902:  DEC     W10,W10
0904:  BRA     Z,914
0906:  BCLR.B  42.0
0908:  RLC     W1,W1
090A:  RLC     W2,W2
090C:  BCLR.B  42.0
090E:  RLC     W4,W4
0910:  RLC     W3,W3
0912:  BRA     8F0
0914:  CLR     W10
0916:  BTSC    W3.8
0918:  BRA     91C
091A:  BRA     928
091C:  BCLR.B  42.0
091E:  RRC     W3,W3
0920:  BCLR    W3.7
0922:  RRC     W4,W4
0924:  RLC     W10,W10
0926:  BRA     92C
0928:  DEC     W0,W0
092A:  BRA     Z,95E
092C:  BTSC    W10.F
092E:  BRA     NC,93A
0930:  RLC     W1,W1
0932:  RLC     W2,W2
0934:  SUB     W1,W7,W1
0936:  SUBB    W2,W8,W2
0938:  BRA     NC,94C
093A:  INC     W4,W4
093C:  BRA     NZ,94C
093E:  INC     W3,W3
0940:  BRA     NZ,94C
0942:  INC     W0,W0
0944:  BRA     Z,95E
0946:  BRA     94C
0948:  DEC     W0,W0
094A:  BRA     Z,95E
094C:  SWAP    W0
094E:  RRC     W0,W1
0950:  BSET    W1.F
0952:  BTSS    W9.F
0954:  BCLR    W1.F
0956:  BCLR    W3.7
0958:  XOR.B   W3L,W1L,W1L
095A:  MOV     W4,W0
095C:  BRA     964
095E:  MOV     #0,W0
0960:  MOV     #0,W1
0962:  BRA     964
0964:  MOV     #14,W5
0966:  REPEAT  #4
0968:  MOV     [--W15],[W5--]
096A:  MOV     [--W15],W5
096C:  RETURN  
096E:  MOV     W8,[W15++]
0970:  MOV     #12,W8
0972:  REPEAT  #4
0974:  MOV     [W8++],[W15++]
0976:  MOV     #0,W9
0978:  BTSC.B  43.0
097A:  MOV     #1,W9
097C:  MOV     W9,[W15++]
097E:  CLR     W8
0980:  CLR     W9
0982:  CLR     W10
0984:  CLR     W11
0986:  CLR     W12
0988:  CLR     W13
098A:  MOV     #E,W8
098C:  MOV     #0,W9
098E:  LNK     #10
0990:  MOV     W12,[W14+W8]
0992:  DEC2    W8,W8
0994:  BRA     NN,990
0996:  XOR     W4,W5,W8
0998:  BRA     NZ,99E
099A:  XOR     W6,W7,W8
099C:  BRA     Z,A2E
099E:  CLR     W8
09A0:  CLR     W13
09A2:  MOV     W13,[W15++]
09A4:  BTSS    W3.F
09A6:  BRA     9BC
09A8:  MOV     [--W15],W13
09AA:  BSET    W13.F
09AC:  MOV     W13,[W15++]
09AE:  COM     W3,W3
09B0:  COM     W2,W2
09B2:  COM     W1,W1
09B4:  NEG     W0,W0
09B6:  ADDC    W1,#0,W1
09B8:  ADDC    W2,#0,W2
09BA:  ADDC    W3,#0,W3
09BC:  BTSS    W7.F
09BE:  BRA     9D4
09C0:  MOV     [--W15],W13
09C2:  BTG     W13.F
09C4:  MOV     W13,[W15++]
09C6:  COM     W7,W7
09C8:  COM     W6,W6
09CA:  COM     W5,W5
09CC:  NEG     W4,W4
09CE:  ADDC    W5,#0,W5
09D0:  ADDC    W6,#0,W6
09D2:  ADDC    W7,#0,W7
09D4:  MOV     #40,W13
09D6:  BCLR.B  42.0
09D8:  RLC     W0,W0
09DA:  RLC     W1,W1
09DC:  RLC     W2,W2
09DE:  RLC     W3,W3
09E0:  RLC     W8,W8
09E2:  RLC     W9,W9
09E4:  RLC     W10,W10
09E6:  RLC     W11,W11
09E8:  CP      W11,W7
09EA:  BRA     NZ,9F6
09EC:  CPB     W10,W6
09EE:  BRA     NZ,9F6
09F0:  CPB     W9,W5
09F2:  BRA     NZ,9F6
09F4:  CPB     W8,W4
09F6:  BRA     NC,A02
09F8:  SUB     W8,W4,W8
09FA:  SUBB    W9,W5,W9
09FC:  SUBB    W10,W6,W10
09FE:  SUBB    W11,W7,W11
0A00:  BSET.B  42.0
0A02:  MOV     W8,[W14]
0A04:  MOV     W9,[W14+#2]
0A06:  MOV     W10,[W14+#4]
0A08:  MOV     W11,[W14+#6]
0A0A:  MOV     [W14+#8],W8
0A0C:  MOV     [W14+#A],W9
0A0E:  MOV     [W14+#C],W10
0A10:  MOV     [W14+#E],W11
0A12:  RLC     W8,W8
0A14:  RLC     W9,W9
0A16:  RLC     W10,W10
0A18:  RLC     W11,W11
0A1A:  MOV     W8,[W14+#8]
0A1C:  MOV     W9,[W14+#A]
0A1E:  MOV     W10,[W14+#C]
0A20:  MOV     W11,[W14+#E]
0A22:  MOV     [W14],W8
0A24:  MOV     [W14+#2],W9
0A26:  MOV     [W14+#4],W10
0A28:  MOV     [W14+#6],W11
0A2A:  DEC     W13,W13
0A2C:  BRA     NZ,9D6
0A2E:  MOV     [W14+#8],W0
0A30:  MOV     [W14+#A],W1
0A32:  MOV     [W14+#C],W2
0A34:  MOV     [W14+#E],W3
0A36:  MOV     [--W15],W13
0A38:  BTSS    W13.F
0A3A:  BRA     A4A
0A3C:  COM     W3,W3
0A3E:  COM     W2,W2
0A40:  COM     W1,W1
0A42:  NEG     W0,W0
0A44:  ADDC    W1,#0,W1
0A46:  ADDC    W2,#0,W2
0A48:  ADDC    W3,#0,W3
0A4A:  ULNK    
0A4C:  BRA     A4E
0A4E:  MOV     [--W15],W9
0A50:  CP0     W9
0A52:  BRA     Z,A5C
0A54:  MOV     W8,W0
0A56:  MOV     W9,W1
0A58:  MOV     W10,W2
0A5A:  MOV     W11,W3
0A5C:  MOV     #1A,W8
0A5E:  REPEAT  #4
0A60:  MOV     [--W15],[W8--]
0A62:  MOV     [--W15],W8
0A64:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
024E:  MOV     W5,[W15++]
0250:  MOV     #4B00,W5
0252:  REPEAT  #19E
0254:  NOP     
0256:  DEC     W5,W5
0258:  BRA     NZ,260
025A:  CLR     85A
025C:  MOV     #0,W0
025E:  BRA     26C
0260:  BTSS.B  232.0
0262:  BRA     252
0264:  PUSH    232
0266:  POP     85A
0268:  MOV     236,W0
026A:  BCLR.B  232.1
026C:  MOV     [--W15],W5
026E:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14   
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 PercentError; 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... unsigned int16 TempInputSamples[2]; 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
.................... FlagType TriggerValueFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... void DisableInterrupts(void); 
.................... void EnableInterrupts(void); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH]; // =  
.................... //!{ 
.................... //!     -129,     19,     39,    -74,    -39,    301,    604,    354,   -397, 
.................... //!     -894,   -580,     91,    196,   -272,   -154,   1241,   2589,   1599, 
.................... //!    -1984,  -5096,  -4105,    977,   5788,   5788,    977,  -4105,  -5096, 
.................... //!    -1984,   1599,   2589,   1241,   -154,   -272,    196,     91,   -580, 
.................... //!     -894,   -397,    354,    604,    301,    -39,    -74,     39,     19, 
.................... //!     -129,   -192,    -81,     71,    115,     55,     -6,    -15,     16, 
.................... //!       -9 
.................... //!}; 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    if ((TriggerFlag == 2) || (TriggerValueFlag == 0)) 
020E:  MOV     1226,W4
0210:  CP.B    W4L,#2
0212:  BRA     Z,218
0214:  CP0.B   1228
0216:  BRA     NZ,21C
....................    { 
....................       DMADoneFlag = 1; 
0218:  MOV.B   #1,W0L
021A:  MOV.B   W0L,1222
....................    } 
.................... } 
....................  
021C:  BCLR.B  84.4
021E:  MOV     #1A,W0
0220:  REPEAT  #C
0222:  MOV     [--W15],[W0--]
0224:  MOV     [--W15],W0
0226:  POP     32
0228:  POP     36
022A:  POP     42
022C:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
022E:  PUSH    42
0230:  PUSH    36
0232:  PUSH    32
0234:  MOV     W0,[W15++]
0236:  MOV     #2,W0
0238:  REPEAT  #C
023A:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
023C:  BCLR.B  85.6
023E:  MOV     #1A,W0
0240:  REPEAT  #C
0242:  MOV     [--W15],[W0--]
0244:  MOV     [--W15],W0
0246:  POP     32
0248:  POP     36
024A:  POP     42
024C:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0270:  PUSH    42
0272:  PUSH    36
0274:  PUSH    32
0276:  MOV     W0,[W15++]
0278:  MOV     #2,W0
027A:  REPEAT  #C
027C:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
027E:  CALL    24E
0282:  MOV.B   W0L,961
....................    UARTRXFlag = 1; 
0284:  MOV.B   #1,W0L
0286:  MOV.B   W0L,1224
.................... } 
....................  
0288:  BCLR.B  87.6
028A:  MOV     #1A,W0
028C:  REPEAT  #C
028E:  MOV     [--W15],[W0--]
0290:  MOV     [--W15],W0
0292:  POP     32
0294:  POP     36
0296:  POP     42
0298:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
029A:  PUSH    42
029C:  PUSH    36
029E:  PUSH    32
02A0:  MOV     W0,[W15++]
02A2:  MOV     #2,W0
02A4:  REPEAT  #C
02A6:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); 
02A8:  BCLR.B  2C9.6
02AA:  BTG.B   2CD.6
....................    //read_adc(); 
....................    if((NormalizeFlag == 1) || (TriggerValueFlag == 0)) 
02AC:  MOV     1222,W4
02AE:  LSR     W4,#8,W4
02B0:  CP.B    W4L,#1
02B2:  BRA     Z,2B8
02B4:  CP0.B   1228
02B6:  BRA     NZ,2C8
....................    { 
....................       read_adc(); 
02B8:  BCLR.B  320.0
02BA:  BSET.B  320.1
02BC:  BTSS.B  320.0
02BE:  BRA     2BC
....................       NormalizeDataCounter++; 
02C0:  INC     121E
02C2:  BTSC.B  42.1
02C4:  INC     1220
....................    } 
02C6:  BRA     34A
....................    else 
....................    { 
....................       unsigned int16 ADCValue = 0; 
02C8:  CLR     12D4
....................        
....................       if (DMAFlag == 0) 
02CA:  CP0.B   1227
02CC:  BRA     NZ,2DC
....................       { 
....................          //disable_interrupts(INT_DMA0); 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
02CE:  MOV     #4000,W1
02D0:  MOV     #0,W2
02D2:  REPEAT  #1FD
02D4:  CLR.B   [W1++]
....................          TriggerFlag = 0; 
02D6:  CLR.B   1226
....................          DMAFlag = 1; 
02D8:  MOV.B   #1,W0L
02DA:  MOV.B   W0L,1227
....................       } 
....................        
....................       if (TriggerFlag != 2) 
02DC:  MOV     1226,W4
02DE:  CP.B    W4L,#2
02E0:  BRA     Z,308
....................       { 
....................             
....................            if(DMAFlag != 2) 
02E2:  MOV     1226,W4
02E4:  LSR     W4,#8,W4
02E6:  CP.B    W4L,#2
02E8:  BRA     Z,2FA
....................            { 
....................               dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
02EA:  BCLR.B  381.7
02EC:  CLR.B   380
02EE:  MOV     #4000,W4
02F0:  MOV     W4,384
02F2:  MOV     #FF,W4
02F4:  MOV     W4,38A
02F6:  BSET.B  381.7
....................               enable_interrupts(INT_DMA0); 
02F8:  BSET.B  94.4
....................            } 
....................            //ADCValue = QuickDigitize(read_adc()); // Trigger on Output Wave 
....................            ADCValue = read_adc() >> 4; 
02FA:  BCLR.B  320.0
02FC:  BSET.B  320.1
02FE:  BTSS.B  320.0
0300:  BRA     2FE
0302:  MOV     300,W5
0304:  LSR     W5,#4,W0
0306:  MOV     W0,12D4
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
0308:  MOV     12D4,W0
030A:  CP      966
030C:  BRA     NZ,320
030E:  CP0.B   1226
0310:  BRA     NZ,320
....................       { 
....................          TempInputSamples[0] = ADCValue; 
0312:  PUSH    12D4
0314:  POP     11F6
....................          DMAFlag = 2; 
0316:  MOV.B   #2,W0L
0318:  MOV.B   W0L,1227
....................          TriggerFlag = 1; 
031A:  MOV.B   #1,W0L
031C:  MOV.B   W0L,1226
....................       } 
031E:  BRA     34A
....................       else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) 
0320:  MOV     11F6,W0
0322:  MOV     12D4,W4
0324:  CP      W4,W0
0326:  BRA     LEU,338
0328:  MOV     1226,W4
032A:  CP.B    W4L,#1
032C:  BRA     NZ,338
....................       { 
....................          TempInputSamples[1] = ADCValue; 
032E:  PUSH    12D4
0330:  POP     11F8
....................          TriggerFlag = 2; 
0332:  MOV.B   #2,W0L
0334:  MOV.B   W0L,1226
....................       } 
0336:  BRA     34A
....................       else if(TriggerFlag == 2) 
0338:  MOV     1226,W4
033A:  CP.B    W4L,#2
033C:  BRA     NZ,348
....................       {     
....................          read_adc(); 
033E:  BCLR.B  320.0
0340:  BSET.B  320.1
0342:  BTSS.B  320.0
0344:  BRA     342
....................       }   
0346:  BRA     34A
....................       else 
....................       { 
....................          DMAFlag = 0;           
0348:  CLR.B   1227
....................       } 
....................    } 
034A:  BCLR.B  84.3
034C:  MOV     #1A,W0
034E:  REPEAT  #C
0350:  MOV     [--W15],[W0--]
0352:  MOV     [--W15],W0
0354:  POP     32
0356:  POP     36
0358:  POP     42
035A:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0E86:  MOV     #4444,W0
0E88:  MOV     W0,A4
0E8A:  BSET.B  81.7
0E8C:  MOV     #46,W0
0E8E:  MOV.B   W0L,742
0E90:  MOV     #57,W0
0E92:  MOV.B   W0L,742
0E94:  BCLR.B  742.6
0E96:  MOV     #3F07,W0
0E98:  MOV     W0,6A6
0E9A:  MOV     #5,W0
0E9C:  MOV     W0,6C6
0E9E:  MOV     #46,W0
0EA0:  MOV.B   W0L,742
0EA2:  MOV     #57,W0
0EA4:  MOV.B   W0L,742
0EA6:  BSET.B  742.6
0EA8:  MOV     #41,W4
0EAA:  MOV     W4,744
0EAC:  MOV     #32,W4
0EAE:  MOV     W4,746
0EB0:  CLR     85A
0EB2:  MOV     #8000,W4
0EB4:  MOV     W4,230
0EB6:  MOV     #400,W4
0EB8:  MOV     W4,232
0EBA:  BSET.B  230.3
0EBC:  MOV     #22,W4
0EBE:  MOV     W4,238
0EC0:  CLR     85E
0EC2:  CLR     964
0EC4:  CLR     966
0EC6:  CLR     968
0EC8:  CLR     96A
0ECA:  CLR     96C
0ECC:  CLR     1166
0ECE:  CLR     1168
0ED0:  CLR     116A
0ED2:  CLR     116C
0ED4:  CLR     116E
0ED6:  CLR     1170
0ED8:  CLR     1172
0EDA:  CLR     1174
0EDC:  CLR     11FE
0EDE:  CLR     1200
0EE0:  CLR     1202
0EE2:  CLR     1204
0EE4:  CLR.B   961
0EE6:  CLR     1206
0EE8:  CLR     1208
0EEA:  CLR     120A
0EEC:  CLR     120C
0EEE:  CLR     120E
0EF0:  CLR     1210
0EF2:  CLR     1212
0EF4:  CLR     1214
0EF6:  CLR     1216
0EF8:  CLR     1218
0EFA:  CLR     121A
0EFC:  CLR     121C
0EFE:  CLR     121E
0F00:  CLR     1220
0F02:  CLR.B   1222
0F04:  CLR.B   1223
0F06:  CLR.B   1224
0F08:  CLR.B   1225
0F0A:  CLR.B   1226
0F0C:  CLR.B   1227
0F0E:  CLR.B   1228
0F10:  MOV     #41,W4
0F12:  MOV     W4,744
0F14:  MOV     #32,W4
0F16:  MOV     W4,746
0F18:  DISI    #E
0F1A:  MOV     #101,W0
0F1C:  MOV     #743,W1
0F1E:  MOV     #78,W2
0F20:  MOV     #9A,W3
0F22:  MOV.B   W2L,[W1]
0F24:  MOV.B   W3L,[W1]
0F26:  MOV.B   W0L,743
0F28:  LSR     W0,#8,W0
0F2A:  MOV     #742,W1
0F2C:  MOV     #46,W2
0F2E:  MOV     #57,W3
0F30:  MOV.B   W2L,[W1]
0F32:  MOV.B   W3L,[W1]
0F34:  MOV.B   W0L,[W1]
0F36:  SETM    32C
0F38:  MOV     #3F80,W15
0F3A:  MOV     #3FFF,W0
0F3C:  MOV     W0,20
0F3E:  NOP     
0F40:  CLR     85C
0F42:  MOV     #3F80,W15
0F44:  MOV     #3FFF,W0
0F46:  MOV     W0,20
0F48:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0F4A:  MOV     #4000,W1
0F4C:  MOV     #0,W2
0F4E:  REPEAT  #FE
0F50:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0F52:  MOV     #41FE,W1
0F54:  MOV     #61,W2
0F56:  MOV.B   #61,W2L
0F58:  REPEAT  #FE
0F5A:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0F5C:  CLR.B   381
0F5E:  MOV.B   #D,W0L
0F60:  MOV.B   W0L,382
0F62:  MOV     #300,W4
0F64:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0F66:  BCLR.B  381.7
0F68:  CLR.B   380
0F6A:  MOV     #4000,W4
0F6C:  MOV     W4,384
0F6E:  MOV     #FF,W4
0F70:  MOV     W4,38A
0F72:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
0F74:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0F76:  MOV     #9F00,W4
0F78:  MOV     W4,324
0F7A:  MOV     #84E0,W4
0F7C:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0F7E:  MOV     #FFFE,W4
0F80:  MOV     W4,32C
0F82:  CLR     322
....................     
....................    read_adc(); 
0F84:  BCLR.B  320.0
0F86:  BSET.B  320.1
0F88:  BTSS.B  320.0
0F8A:  BRA     F88
....................       
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0F8C:  CLR     104
0F8E:  PUSH    85E
0F90:  POP     102
0F92:  MOV     #8000,W4
0F94:  MOV     W4,104
....................    EnableInterrupts(); 
0F96:  CALL    35C
....................     
....................    NormalizeFlag = 1; 
0F9A:  MOV.B   #1,W0L
0F9C:  MOV.B   W0L,1223
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
0F9E:  CP0.B   1222
0FA0:  BRA     NZ,FAC
0FA2:  MOV     121E,W4
0FA4:  XOR     #FF,W4
0FA6:  BRA     NZ,1070
0FA8:  CP0     1220
0FAA:  BRA     NZ,1070
....................       { 
....................          disable_interrupts(INT_DMA0); 
0FAC:  BCLR.B  94.4
....................  
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
0FAE:  CLR     12AA
0FB0:  CLR     12AC
0FB2:  MOV     12AC,W4
0FB4:  CP      W4,#0
0FB6:  BRA     GTU,FD6
0FB8:  BRA     NC,FC2
0FBA:  MOV     12AA,W4
0FBC:  MOV     #FF,W3
0FBE:  CP      W3,W4
0FC0:  BRA     LEU,FD6
....................          { 
....................             AccumulateAnalogData(Index); 
0FC2:  PUSH    12AA
0FC4:  POP     12B4
0FC6:  PUSH    12AC
0FC8:  POP     12B6
0FCA:  CALL    6A6
0FCE:  INC     12AA
0FD0:  BTSC.B  42.1
0FD2:  INC     12AC
0FD4:  BRA     FB2
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
0FD6:  MOV     1222,W4
0FD8:  LSR     W4,#8,W4
0FDA:  CP.B    W4L,#1
0FDC:  BRA     NZ,FE2
....................          { 
....................             NormalizeData(); 
0FDE:  CALL    A66
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
0FE2:  MOV     1224,W4
0FE4:  LSR     W4,#8,W4
0FE6:  CP.B    W4L,#1
0FE8:  BRA     NZ,105C
....................          {           
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0FEA:  CLR     12AE
0FEC:  CLR     12B0
0FEE:  MOV     12B0,W4
0FF0:  CP      W4,#0
0FF2:  BRA     GTU,1018
0FF4:  BRA     NC,FFE
0FF6:  MOV     12AE,W4
0FF8:  MOV     #FF,W3
0FFA:  CP      W3,W4
0FFC:  BRA     LEU,1018
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
0FFE:  MOV     #862,W4
1000:  MOV     12AE,W3
1002:  ADD     W3,W4,W0
1004:  MOV.B   [W0],W5L
1006:  BTSC.B  233.1
1008:  BRA     1006
100A:  PUSH    234
100C:  MOV.B   W5L,[W15-#2]
100E:  POP     234
1010:  INC     12AE
1012:  BTSC.B  42.1
1014:  INC     12B0
1016:  BRA     FEE
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
1018:  CLR     12AE
101A:  CLR     12B0
101C:  MOV     12B0,W4
101E:  CP      W4,#0
1020:  BRA     GTU,105C
1022:  BRA     NC,102C
1024:  MOV     12AE,W4
1026:  MOV     #FF,W3
1028:  CP      W3,W4
102A:  BRA     LEU,105C
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
102C:  MOV     #2,W4
102E:  CLR.B   9
1030:  MOV     12AE,W0
1032:  MOV     12B0,W1
1034:  INC     W4,W4
1036:  DEC     W4,W4
1038:  BRA     Z,1040
103A:  SL      W0,W0
103C:  RLC     W1,W1
103E:  BRA     1036
1040:  MOV     #96E,W4
1042:  ADD     W0,W4,W0
1044:  MOV     #A,W4
1046:  MOV     [W0++],[W4++]
1048:  MOV     [W0++],[W4++]
104A:  BTSC.B  233.1
104C:  BRA     104A
104E:  PUSH    234
1050:  MOV.B   W5L,[W15-#2]
1052:  POP     234
1054:  INC     12AE
1056:  BTSC.B  42.1
1058:  INC     12B0
105A:  BRA     101C
....................             } 
....................          } 
....................           
....................          NormalizeFlag = 0; 
105C:  CLR.B   1223
....................          NormalizeDataCounter = 0; 
105E:  CLR     121E
1060:  CLR     1220
....................          HandShakeFlag = 0;    
1062:  CLR.B   1225
....................          CurrentIndex = 0; 
1064:  CLR     1212
1066:  CLR     1214
....................          enable_interrupts(INT_DMA0); 
1068:  BSET.B  94.4
....................          DMADoneFlag = 0; 
106A:  CLR.B   1222
....................          TriggerFlag = 0; 
106C:  CLR.B   1226
....................          DMAFlag = 0; 
106E:  CLR.B   1227
....................       }   
....................        
....................       if (UARTRXFlag) 
1070:  CP0.B   1224
1072:  BRA     Z,107C
....................       { 
....................          CommHandler(UARTRX); 
1074:  MOV.B   961,W0L
1076:  MOV.B   W0L,12B4
1078:  CALL    C98
....................       }   
107C:  BRA     F9E
....................    } 
.................... } 
....................  
107E:  BRA     107E
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
06A6:  MOV     W5,[W15++]
06A8:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
06AA:  MOV     #1,W4
06AC:  CLR.B   9
06AE:  MOV     1212,W0
06B0:  MOV     1214,W1
06B2:  INC     W4,W4
06B4:  DEC     W4,W4
06B6:  BRA     Z,6BE
06B8:  SL      W0,W0
06BA:  RLC     W1,W1
06BC:  BRA     6B4
06BE:  MOV     #1176,W4
06C0:  ADD     W0,W4,W5
06C2:  MOV     #1,W4
06C4:  CLR.B   9
06C6:  MOV     12B4,W0
06C8:  MOV     12B6,W1
06CA:  INC     W4,W4
06CC:  DEC     W4,W4
06CE:  BRA     Z,6D6
06D0:  SL      W0,W0
06D2:  RLC     W1,W1
06D4:  BRA     6CC
06D6:  MOV     #4000,W4
06D8:  ADD     W0,W4,W0
06DA:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
06DC:  PUSH    1212
06DE:  POP     120E
06E0:  PUSH    1214
06E2:  POP     1210
....................    Accumulator = 0; 
06E4:  CLR     96A
06E6:  CLR     96C
....................    CoefficentIndex = 0; 
06E8:  CLR     120A
06EA:  CLR     120C
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
06EC:  MOV     120C,W4
06EE:  CP      W4,#0
06F0:  BRA     GTU,774
06F2:  BRA     NC,6FC
06F4:  MOV     120A,W4
06F6:  MOV     #3F,W3
06F8:  CP      W3,W4
06FA:  BRA     LEU,774
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
06FC:  MOV     #1,W4
06FE:  CLR.B   9
0700:  MOV     120E,W0
0702:  MOV     1210,W1
0704:  INC     W4,W4
0706:  DEC     W4,W4
0708:  BRA     Z,710
070A:  SL      W0,W0
070C:  RLC     W1,W1
070E:  BRA     706
0710:  MOV     #1176,W4
0712:  ADD     W0,W4,W0
0714:  MOV     W0,W4
0716:  MOV     [W4],W0
0718:  MOV     W0,W5
071A:  CLR     W6
071C:  BTSC    W5.F
071E:  SETM    W6
0720:  MOV     #1,W4
0722:  CLR.B   9
0724:  MOV     120A,W0
0726:  MOV     120C,W1
0728:  INC     W4,W4
072A:  DEC     W4,W4
072C:  BRA     Z,734
072E:  SL      W0,W0
0730:  RLC     W1,W1
0732:  BRA     72A
0734:  MOV     #122A,W4
0736:  ADD     W0,W4,W0
0738:  MOV     W0,W4
073A:  MOV     [W4],W0
073C:  CLR     W1
073E:  BTSC    W0.F
0740:  SETM    W1
0742:  MOV     W0,W2
0744:  MOV     W1,W3
0746:  MOV     W5,W0
0748:  MOV     W6,W1
074A:  CALL    368
074E:  ADD     96A
0750:  MOV     W1,W0
0752:  ADDC    96C,W0
0754:  MOV     W0,96C
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
0756:  MOV     120E,W4
0758:  XOR     #3F,W4
075A:  BRA     NZ,766
075C:  CP0     1210
075E:  BRA     NZ,766
....................       { 
....................          InputIndex = 0; 
0760:  CLR     120E
0762:  CLR     1210
....................       } 
0764:  BRA     76C
....................       else 
....................       { 
....................          InputIndex++; 
0766:  INC     120E
0768:  BTSC.B  42.1
076A:  INC     1210
....................       } 
....................        
....................       CoefficentIndex++; 
076C:  INC     120A
076E:  BTSC.B  42.1
0770:  INC     120C
0772:  BRA     6EC
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
0774:  MOV     #862,W4
0776:  MOV     12B4,W3
0778:  ADD     W3,W4,W5
077A:  MOV     #1,W4
077C:  CLR.B   9
077E:  MOV     1212,W0
0780:  MOV     1214,W1
0782:  INC     W4,W4
0784:  DEC     W4,W4
0786:  BRA     Z,78E
0788:  SL      W0,W0
078A:  RLC     W1,W1
078C:  BRA     784
078E:  MOV     #1176,W4
0790:  ADD     W0,W4,W0
0792:  MOV     [W0],W6
0794:  LSR     W6,#4,W0
0796:  MOV.B   W0L,[W5]
0798:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
079A:  MOV     1222,W4
079C:  LSR     W4,#8,W4
079E:  CP.B    W4L,#1
07A0:  BRA     NZ,7C2
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
07A2:  MOV     #2,W4
07A4:  CLR.B   9
07A6:  MOV     12B4,W0
07A8:  MOV     12B6,W1
07AA:  INC     W4,W4
07AC:  DEC     W4,W4
07AE:  BRA     Z,7B6
07B0:  SL      W0,W0
07B2:  RLC     W1,W1
07B4:  BRA     7AC
07B6:  MOV     #96E,W4
07B8:  ADD     W0,W4,W5
07BA:  MOV     #96A,W4
07BC:  MOV     [W4++],[W5++]
07BE:  MOV     [W4++],[W5++]
....................    } 
07C0:  BRA     83A
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
07C2:  MOV     96A,W0
07C4:  MOV     96C,W1
07C6:  CLR     W3
07C8:  BTSC    W1.F
07CA:  SETM    W3
07CC:  MOV     W3,W2
07CE:  MOV     116E,W4
07D0:  SUB     W0,W4,W0
07D2:  MOV     1170,W4
07D4:  SUBB    W1,W4,W1
07D6:  MOV     1172,W4
07D8:  SUBB    W2,W4,W2
07DA:  MOV     1174,W4
07DC:  SUBB    W3,W4,W3
07DE:  CALL    3AA
07E2:  MOV     W0,12B8
07E4:  MOV     W1,12BA
07E6:  MOV     12B8,W0
07E8:  MOV     12BA,W1
07EA:  MOV     1202,W2
07EC:  MOV     1204,W3
07EE:  CALL    40C
07F2:  MOV     W0,12BC
07F4:  MOV     W1,12BE
07F6:  BCLR.B  43.0
07F8:  MOV     12BC,W0
07FA:  MOV     12BE,W1
07FC:  MOV     #0,W2
07FE:  MOV     #42FE,W3
0800:  CALL    4D0
0804:  MOV     W0,12C0
0806:  MOV     W1,12C2
....................       ConversionValue = (unsigned int8)StepThree; 
0808:  MOV     12C0,W0
080A:  MOV     12C2,W1
080C:  CALL    67A
0810:  MOV.B   W0L,860
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
0812:  MOV     #2,W4
0814:  CLR.B   9
0816:  MOV     12B4,W0
0818:  MOV     12B6,W1
081A:  INC     W4,W4
081C:  DEC     W4,W4
081E:  BRA     Z,826
0820:  SL      W0,W0
0822:  RLC     W1,W1
0824:  BRA     81C
0826:  MOV     #96E,W4
0828:  ADD     W0,W4,W5
082A:  MOV     860,W0
082C:  MOV.B   W0L,[W5+#0]
082E:  MOV.B   #0,W0L
0830:  MOV.B   W0L,[W5+#1]
0832:  MOV.B   #0,W0L
0834:  MOV.B   W0L,[W5+#2]
0836:  MOV.B   #0,W0L
0838:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................    if (CurrentIndex == 0) 
083A:  CP0     1212
083C:  BRA     NZ,84A
083E:  CP0     1214
0840:  BRA     NZ,84A
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
0842:  MOV     #3F,W4
0844:  MOV     W4,1212
0846:  CLR     1214
....................    } 
0848:  BRA     850
....................    else 
....................    { 
....................      CurrentIndex--; 
084A:  DEC     1212
084C:  BTSS.B  42.0
084E:  DEC     1214
....................    }  
0850:  MOV     [--W15],W6
0852:  MOV     [--W15],W5
0854:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
0A66:  MOV     W5,[W15++]
0A68:  MOV     W6,[W15++]
0A6A:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0A6C:  MOV     121C,W4
0A6E:  CP      W4,#0
0A70:  BRA     GTU,C10
0A72:  BRA     NC,A7C
0A74:  MOV     121A,W4
0A76:  MOV     #BB8,W3
0A78:  CP      W3,W4
0A7A:  BRA     LEU,C10
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A7C:  PUSH    A6E
0A7E:  POP     1166
0A80:  PUSH    A70
0A82:  POP     1168
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A84:  PUSH    A6E
0A86:  POP     116A
0A88:  PUSH    A70
0A8A:  POP     116C
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0A8C:  PUSH    4080
0A8E:  POP     964
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A90:  MOV     #41,W4
0A92:  MOV     W4,12B4
0A94:  CLR     12B6
0A96:  MOV     12B6,W4
0A98:  CP      W4,#0
0A9A:  BRA     GTU,BC0
0A9C:  BRA     NC,AA6
0A9E:  MOV     12B4,W4
0AA0:  MOV     #FF,W3
0AA2:  CP      W3,W4
0AA4:  BRA     LEU,BC0
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0AA6:  MOV     #2,W4
0AA8:  CLR.B   9
0AAA:  MOV     12B4,W0
0AAC:  MOV     12B6,W1
0AAE:  INC     W4,W4
0AB0:  DEC     W4,W4
0AB2:  BRA     Z,ABA
0AB4:  SL      W0,W0
0AB6:  RLC     W1,W1
0AB8:  BRA     AB0
0ABA:  MOV     #96E,W4
0ABC:  ADD     W0,W4,W0
0ABE:  MOV     W0,W4
0AC0:  MOV     #0,W3
0AC2:  MOV     [W4++],[W3++]
0AC4:  MOV     [W4++],[W3++]
0AC6:  MOV     116C,W4
0AC8:  CP      W4,W1
0ACA:  BRA     LT,AF2
0ACC:  BRA     GT,AD4
0ACE:  MOV     116A,W4
0AD0:  CP      W4,W0
0AD2:  BRA     LEU,AF2
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0AD4:  MOV     #2,W4
0AD6:  CLR.B   9
0AD8:  MOV     12B4,W0
0ADA:  MOV     12B6,W1
0ADC:  INC     W4,W4
0ADE:  DEC     W4,W4
0AE0:  BRA     Z,AE8
0AE2:  SL      W0,W0
0AE4:  RLC     W1,W1
0AE6:  BRA     ADE
0AE8:  MOV     #96E,W4
0AEA:  ADD     W0,W4,W0
0AEC:  MOV     #116A,W4
0AEE:  MOV     [W0++],[W4++]
0AF0:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0AF2:  MOV     #2,W4
0AF4:  CLR.B   9
0AF6:  MOV     12B4,W0
0AF8:  MOV     12B6,W1
0AFA:  INC     W4,W4
0AFC:  DEC     W4,W4
0AFE:  BRA     Z,B06
0B00:  SL      W0,W0
0B02:  RLC     W1,W1
0B04:  BRA     AFC
0B06:  MOV     #96E,W4
0B08:  ADD     W0,W4,W0
0B0A:  MOV     W0,W4
0B0C:  MOV     #0,W3
0B0E:  MOV     [W4++],[W3++]
0B10:  MOV     [W4++],[W3++]
0B12:  MOV     1168,W4
0B14:  CP      W4,W1
0B16:  BRA     GT,B3E
0B18:  BRA     LT,B20
0B1A:  MOV     1166,W4
0B1C:  CP      W4,W0
0B1E:  BRA     C,B3E
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0B20:  MOV     #2,W4
0B22:  CLR.B   9
0B24:  MOV     12B4,W0
0B26:  MOV     12B6,W1
0B28:  INC     W4,W4
0B2A:  DEC     W4,W4
0B2C:  BRA     Z,B34
0B2E:  SL      W0,W0
0B30:  RLC     W1,W1
0B32:  BRA     B2A
0B34:  MOV     #96E,W4
0B36:  ADD     W0,W4,W0
0B38:  MOV     #1166,W4
0B3A:  MOV     [W0++],[W4++]
0B3C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0B3E:  MOV     #1,W4
0B40:  CLR.B   9
0B42:  MOV     12B4,W0
0B44:  MOV     12B6,W1
0B46:  INC     W4,W4
0B48:  DEC     W4,W4
0B4A:  BRA     Z,B52
0B4C:  SL      W0,W0
0B4E:  RLC     W1,W1
0B50:  BRA     B48
0B52:  MOV     #4000,W4
0B54:  ADD     W0,W4,W0
0B56:  MOV     W0,W4
0B58:  MOV     [W4],W0
0B5A:  MOV     964,W4
0B5C:  CP      W4,W0
0B5E:  BRA     LEU,B7C
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0B60:  MOV     #1,W4
0B62:  CLR.B   9
0B64:  MOV     12B4,W0
0B66:  MOV     12B6,W1
0B68:  INC     W4,W4
0B6A:  DEC     W4,W4
0B6C:  BRA     Z,B74
0B6E:  SL      W0,W0
0B70:  RLC     W1,W1
0B72:  BRA     B6A
0B74:  MOV     #4000,W4
0B76:  ADD     W0,W4,W0
0B78:  MOV     [W0],[W15++]
0B7A:  POP     964
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0B7C:  MOV     #2,W4
0B7E:  CLR.B   9
0B80:  MOV     12B4,W0
0B82:  MOV     12B6,W1
0B84:  INC     W4,W4
0B86:  DEC     W4,W4
0B88:  BRA     Z,B90
0B8A:  SL      W0,W0
0B8C:  RLC     W1,W1
0B8E:  BRA     B86
0B90:  MOV     #96E,W4
0B92:  ADD     W0,W4,W0
0B94:  MOV     W0,W4
0B96:  MOV     #0,W3
0B98:  MOV     [W4++],[W3++]
0B9A:  MOV     [W4++],[W3++]
0B9C:  CLR     W3
0B9E:  BTSC    W1.F
0BA0:  SETM    W3
0BA2:  MOV     W3,W2
0BA4:  ADD     116E
0BA6:  MOV     W1,W0
0BA8:  ADDC    1170,W0
0BAA:  MOV     W0,1170
0BAC:  MOV     1172,W4
0BAE:  ADDC    W2,W4,W0
0BB0:  MOV     W0,1172
0BB2:  MOV     1174,W4
0BB4:  ADDC    W3,W4,W0
0BB6:  MOV     W0,1174
0BB8:  INC     12B4
0BBA:  BTSC.B  42.1
0BBC:  INC     12B6
0BBE:  BRA     A96
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0BC0:  MOV     1166,W4
0BC2:  MOV     116A,W3
0BC4:  SUB     W4,W3,W0
0BC6:  MOV     1168,W4
0BC8:  MOV     116C,W3
0BCA:  SUBB    W4,W3,W1
0BCC:  CALL    856
0BD0:  MOV     W0,11FE
0BD2:  MOV     W1,1200
....................       AverageMultiplier = (255.0/ AverageDivider); 
0BD4:  MOV     #0,W0
0BD6:  MOV     #437F,W1
0BD8:  MOV     11FE,W2
0BDA:  MOV     1200,W3
0BDC:  CALL    8A4
0BE0:  MOV     W0,1202
0BE2:  MOV     W1,1204
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0BE4:  BCLR.B  43.0
0BE6:  MOV     116E,W0
0BE8:  MOV     1170,W1
0BEA:  MOV     1172,W2
0BEC:  MOV     1174,W3
0BEE:  MOV     #BF,W4
0BF0:  MOV     #0,W5
0BF2:  MOV     #0,W6
0BF4:  MOV     #0,W7
0BF6:  CALL    96E
0BFA:  MOV     W0,116E
0BFC:  MOV     W1,1170
0BFE:  MOV     W2,1172
0C00:  MOV     W3,1174
....................        
....................       TriggerValue = InitialTriggerValue; 
0C02:  PUSH    964
0C04:  POP     966
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0C06:  MOV     #96E,W1
0C08:  MOV     #0,W2
0C0A:  REPEAT  #1FD
0C0C:  CLR.B   [W1++]
....................    }   
0C0E:  BRA     C78
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0C10:  PUSH    4080
0C12:  POP     964
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0C14:  MOV     #41,W4
0C16:  MOV     W4,12B8
0C18:  CLR     12BA
0C1A:  MOV     12BA,W4
0C1C:  CP      W4,#0
0C1E:  BRA     GTU,C70
0C20:  BRA     NC,C2A
0C22:  MOV     12B8,W4
0C24:  MOV     #FF,W3
0C26:  CP      W3,W4
0C28:  BRA     LEU,C70
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0C2A:  MOV     #1,W4
0C2C:  CLR.B   9
0C2E:  MOV     12B8,W0
0C30:  MOV     12BA,W1
0C32:  INC     W4,W4
0C34:  DEC     W4,W4
0C36:  BRA     Z,C3E
0C38:  SL      W0,W0
0C3A:  RLC     W1,W1
0C3C:  BRA     C34
0C3E:  MOV     #4000,W4
0C40:  ADD     W0,W4,W0
0C42:  MOV     W0,W4
0C44:  MOV     [W4],W0
0C46:  MOV     964,W4
0C48:  CP      W4,W0
0C4A:  BRA     LEU,C68
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0C4C:  MOV     #1,W4
0C4E:  CLR.B   9
0C50:  MOV     12B8,W0
0C52:  MOV     12BA,W1
0C54:  INC     W4,W4
0C56:  DEC     W4,W4
0C58:  BRA     Z,C60
0C5A:  SL      W0,W0
0C5C:  RLC     W1,W1
0C5E:  BRA     C56
0C60:  MOV     #4000,W4
0C62:  ADD     W0,W4,W0
0C64:  MOV     [W0],[W15++]
0C66:  POP     964
....................         }              
0C68:  INC     12B8
0C6A:  BTSC.B  42.1
0C6C:  INC     12BA
0C6E:  BRA     C1A
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0C70:  PUSH    964
0C72:  POP     966
....................       ErrorCounter = 0;  
0C74:  CLR     121A
0C76:  CLR     121C
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0C78:  CLR     121E
0C7A:  CLR     1220
....................    NormalizeFlag = 0; 
0C7C:  CLR.B   1223
....................    CurrentIndex = 0; 
0C7E:  CLR     1212
0C80:  CLR     1214
0C82:  MOV     [--W15],W7
0C84:  MOV     [--W15],W6
0C86:  MOV     [--W15],W5
0C88:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
.................... { 
....................     InputSamples[CurrentIndex] = ADCValue; 
....................     InputIndex = CurrentIndex; 
....................     CoefficentIndex = 0; 
....................     Accumulator = 0; 
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
....................          { 
....................             InputIndex = 0; 
....................          } 
....................          else 
....................          { 
....................             InputIndex++; 
....................          } 
....................          CoefficentIndex++; 
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
....................      
....................     if (CurrentIndex == 0) 
....................     { 
....................       CurrentIndex = COEF_LENGTH - 1; 
....................     } 
....................     else 
....................     { 
....................       CurrentIndex--; 
....................     }  
....................        
....................     return ConversionValue;   
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0C98:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0C9A:  MOV.B   12B4,W0L
0C9C:  CLR.B   1
0C9E:  XOR     #2B,W0
0CA0:  BRA     Z,CBC
0CA2:  XOR     #1,W0
0CA4:  BRA     Z,CC2
0CA6:  XOR     #6E,W0
0CA8:  BRA     Z,CC6
0CAA:  XOR     #8,W0
0CAC:  BRA     Z,CD8
0CAE:  XOR     #68,W0
0CB0:  BRA     Z,DA2
0CB2:  XOR     #1,W0
0CB4:  BRA     Z,E02
0CB6:  XOR     #6,W0
0CB8:  BRA     Z,E5A
0CBA:  BRA     E7E
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0CBC:  MOV.B   #1,W0L
0CBE:  MOV.B   W0L,1225
....................          break; 
0CC0:  BRA     E7E
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0CC2:  BCLR.B  94.3
....................          break; 
0CC4:  BRA     E7E
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0CC6:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0CC8:  CLR     104
0CCA:  PUSH    85E
0CCC:  POP     102
0CCE:  MOV     #8000,W4
0CD0:  MOV     W4,104
....................          HandshakeFlag = 1;   
0CD2:  MOV.B   #1,W0L
0CD4:  MOV.B   W0L,1225
....................          break;  
0CD6:  BRA     E7E
....................                       
....................       case 'L': 
....................          DisableInterrupts(); 
0CD8:  CALL    C8A
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0CDC:  MOV     #122A,W1
0CDE:  MOV     #0,W2
0CE0:  REPEAT  #7F
0CE2:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0CE4:  MOV     1206,W4
0CE6:  XOR     #40,W4
0CE8:  BRA     NZ,CEE
0CEA:  CP0     1208
0CEC:  BRA     Z,D6A
....................          { 
....................             if (kbhit(SHARP)) 
0CEE:  BTSS.B  232.0
0CF0:  BRA     D68
0CF2:  PUSH    42
0CF4:  BCLR.B  81.7
0CF6:  SETM.B  42
0CF8:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0CFA:  CALL    24E
0CFE:  BCLR.B  81.7
0D00:  POP     42
0D02:  BSET.B  81.7
0D04:  MOV.B   W0L,12B5
....................                 
....................                if ((CoefficentByte == 'L') && (CSharpCoefficentRecieved == 0)) 
0D06:  MOV     12B4,W4
0D08:  LSR     W4,#8,W4
0D0A:  XOR.B   #4C,W4L
0D0C:  BRA     NZ,D18
0D0E:  CP0     1206
0D10:  BRA     NZ,D18
0D12:  CP0     1208
0D14:  BRA     NZ,D18
....................                { 
....................                   ; // Do nothing 
....................                }               
0D16:  BRA     D68
....................                else if (NumberCSharpByteRecieved == 0) 
0D18:  CP0     1216
0D1A:  BRA     NZ,D2C
0D1C:  CP0     1218
0D1E:  BRA     NZ,D2C
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0D20:  MOV.B   12B5,W0L
0D22:  MOV.B   W0L,962
....................                   NumberCSharpByteRecieved = 1; 
0D24:  MOV     #1,W4
0D26:  MOV     W4,1216
0D28:  CLR     1218
....................                }            
0D2A:  BRA     D68
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0D2C:  MOV.B   12B5,W0L
0D2E:  MOV.B   W0L,963
....................                   NumberCSharpByteRecieved = 0; 
0D30:  CLR     1216
0D32:  CLR     1218
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0D34:  MOV.B   963,W0L
0D36:  MOV.B   W0L,W5L
0D38:  CLR.B   B
0D3A:  MOV.B   W5L,W0L
0D3C:  MOV.B   W0L,B
0D3E:  CLR.B   W5
0D40:  MOV     W5,W0
0D42:  IOR     962,W0
0D44:  MOV     W0,968
....................                   fir_coef[CSharpCoefficentRecieved] = ByteConversionResult; 
0D46:  MOV     #1,W4
0D48:  CLR.B   9
0D4A:  MOV     1206,W0
0D4C:  MOV     1208,W1
0D4E:  INC     W4,W4
0D50:  DEC     W4,W4
0D52:  BRA     Z,D5A
0D54:  SL      W0,W0
0D56:  RLC     W1,W1
0D58:  BRA     D50
0D5A:  MOV     #122A,W4
0D5C:  ADD     W0,W4,W5
0D5E:  MOV     968,W4
0D60:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0D62:  INC     1206
0D64:  BTSC.B  42.1
0D66:  INC     1208
....................                } 
....................             } 
0D68:  BRA     CE4
....................          } 
....................           
....................          switch (fir_coef[0]) 
0D6A:  MOV     122A,W0
0D6C:  XOR     #D2,W0
0D6E:  BRA     Z,D7A
0D70:  XOR     #FA,W0
0D72:  BRA     Z,D80
0D74:  XOR     #149,W0
0D76:  BRA     Z,D86
0D78:  BRA     D8C
....................          { 
....................          case 210: //Todo:: Fall Through  
....................             TimerTicks = 53334; 
0D7A:  MOV     #D056,W4
0D7C:  MOV     W4,85E
....................             break; 
0D7E:  BRA     D90
....................          case 40: 
....................             TimerTicks = 53334; 
0D80:  MOV     #D056,W4
0D82:  MOV     W4,85E
....................             break; 
0D84:  BRA     D90
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0D86:  MOV     #1F40,W4
0D88:  MOV     W4,85E
....................             break; 
0D8A:  BRA     D90
....................          default:  
....................             TimerTicks = 8000; 
0D8C:  MOV     #1F40,W4
0D8E:  MOV     W4,85E
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0D90:  CLR     1206
0D92:  CLR     1208
....................          NormalizeFlag = 1; 
0D94:  MOV.B   #1,W0L
0D96:  MOV.B   W0L,1223
....................          HandshakeFlag = 1; 
0D98:  MOV.B   #1,W0L
0D9A:  MOV.B   W0L,1225
....................          EnableInterrupts(); 
0D9C:  CALL    35C
....................          break; 
0DA0:  BRA     E7E
....................          
....................       case '$': 
....................          DisableInterrupts(); 
0DA2:  CALL    C8A
....................          TriggerValue = 0; // reset trigger value 
0DA6:  CLR     966
....................           
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0DA8:  BTSS.B  232.0
0DAA:  BRA     DEC
0DAC:  PUSH    42
0DAE:  BCLR.B  81.7
0DB0:  SETM.B  42
0DB2:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0DB4:  CALL    24E
0DB8:  BCLR.B  81.7
0DBA:  POP     42
0DBC:  BSET.B  81.7
0DBE:  MOV.B   W0L,12B6
....................                 
....................                if (isdigit(DigitByte)) 
0DC0:  MOV     12B6,W4
0DC2:  MOV     #30,W3
0DC4:  CP.B    W3L,W4L
0DC6:  BRA     GTU,DE2
0DC8:  MOV     12B6,W4
0DCA:  MOV     #39,W3
0DCC:  CP.B    W3L,W4L
0DCE:  BRA     NC,DE2
....................                { 
....................                   TriggerValue = TriggerValue * 10 + CharToInt(DigitByte); 
0DD0:  MOV     966,W4
0DD2:  MUL.UU  W4,#A,W0
0DD4:  MOV     W0,W5
0DD6:  MOV.B   12B6,W0L
0DD8:  SE      W0,W0
0DDA:  SUB     #30,W0
0DDC:  ADD     W0,W5,W0
0DDE:  MOV     W0,966
....................                } 
0DE0:  BRA     DEC
....................                else if (DigitByte == ')') 
0DE2:  MOV     12B6,W4
0DE4:  XOR.B   #29,W4L
0DE6:  BRA     NZ,DEC
....................                { 
....................                   break; 
0DE8:  BRA     DEE
....................                } 
0DEA:  BRA     DEC
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0DEC:  BRA     DA8
....................          } 
....................           
....................          TriggerValueFlag = 1; 
0DEE:  MOV.B   #1,W0L
0DF0:  MOV.B   W0L,1228
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0DF2:  CLR     104
0DF4:  PUSH    85E
0DF6:  POP     102
0DF8:  MOV     #8000,W4
0DFA:  MOV     W4,104
....................          EnableInterrupts(); 
0DFC:  CALL    35C
....................          break;  
0E00:  BRA     E7E
....................           
....................       case '%': 
....................          DisableInterrupts();   
0E02:  CALL    C8A
....................          TimerTicks = 0; // reset trigger value 
0E06:  CLR     85E
....................              
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0E08:  BTSS.B  232.0
0E0A:  BRA     E52
0E0C:  PUSH    42
0E0E:  BCLR.B  81.7
0E10:  SETM.B  42
0E12:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0E14:  CALL    24E
0E18:  BCLR.B  81.7
0E1A:  POP     42
0E1C:  BSET.B  81.7
0E1E:  MOV.B   W0L,12B7
....................                 
....................                if (isdigit(DigitByte)) 
0E20:  MOV     12B6,W4
0E22:  LSR     W4,#8,W4
0E24:  MOV     #30,W3
0E26:  CP.B    W3L,W4L
0E28:  BRA     GTU,E46
0E2A:  MOV     12B6,W4
0E2C:  LSR     W4,#8,W4
0E2E:  MOV     #39,W3
0E30:  CP.B    W3L,W4L
0E32:  BRA     NC,E46
....................                { 
....................                   TimerTicks = TimerTicks * 10 + CharToInt(DigitByte); 
0E34:  MOV     85E,W4
0E36:  MUL.UU  W4,#A,W0
0E38:  MOV     W0,W5
0E3A:  MOV.B   12B7,W0L
0E3C:  SE      W0,W0
0E3E:  SUB     #30,W0
0E40:  ADD     W0,W5,W0
0E42:  MOV     W0,85E
....................                } 
0E44:  BRA     E52
....................                else if (DigitByte == ')') 
0E46:  MOV     12B6,W4
0E48:  LSR     W4,#8,W4
0E4A:  XOR.B   #29,W4L
0E4C:  BRA     NZ,E52
....................                { 
....................                   break; 
0E4E:  BRA     E54
....................                } 
0E50:  BRA     E52
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0E52:  BRA     E08
....................          } 
....................          EnableInterrupts(); 
0E54:  CALL    35C
....................          break; 
0E58:  BRA     E7E
....................             
....................       case '#': 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0E5A:  MOV     #4000,W1
0E5C:  MOV     #0,W2
0E5E:  REPEAT  #1FD
0E60:  CLR.B   [W1++]
....................          dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E62:  BCLR.B  381.7
0E64:  CLR.B   380
0E66:  MOV     #4000,W4
0E68:  MOV     W4,384
0E6A:  MOV     #FF,W4
0E6C:  MOV     W4,38A
0E6E:  BSET.B  381.7
....................          enable_interrupts(INT_DMA0); 
0E70:  BSET.B  94.4
....................          DMAFlag = 0; 
0E72:  CLR.B   1227
....................          TriggerFlag = 0; 
0E74:  CLR.B   1226
....................          TriggerValueFlag = 0; 
0E76:  CLR.B   1228
....................          HandshakeFlag = 1; 
0E78:  MOV.B   #1,W0L
0E7A:  MOV.B   W0L,1225
....................          break; 
0E7C:  BRA     E7E
....................    
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0E7E:  CLR.B   12B4
....................    UARTRXFlag = 0; 
0E80:  CLR.B   1224
0E82:  MOV     [--W15],W5
0E84:  RETURN  
.................... } 
....................  
.................... void DisableInterrupts(void) 
.................... { 
....................    disable_interrupts(INT_TIMER1); // disable timer 
*
0C8A:  BCLR.B  94.3
....................    disable_interrupts(INT_RDA2); 
0C8C:  BCLR.B  97.6
....................    disable_interrupts(GLOBAL);  
0C8E:  BCLR.B  81.7
0C90:  MOV     #E0,W4
0C92:  MOV     W4,42
0C94:  BSET.B  81.7
0C96:  RETURN  
.................... } 
....................  
.................... void EnableInterrupts(void) 
.................... { 
....................    enable_interrupts(INT_RDA2); 
*
035C:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
035E:  BSET.B  94.3
....................    enable_interrupts(GLOBAL); 
0360:  BCLR.B  81.7
0362:  CLR     42
0364:  BSET.B  81.7
0366:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
