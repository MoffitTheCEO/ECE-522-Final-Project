CCS PCD C Compiler, Version 5.008, 5967               15-Nov-22 19:33

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4362 bytes (10%)
                           Largest free fragment is 39670
               RAM used:   3542 (22%) at main() level
                           3614 (22%) worst case
               Stack used: 86 locations (52 in main + 34 for interrupts)
               Stack size: 30

*
0000:  GOTO    F14
*
001A:  DATA    A4,06,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    66,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
0290:  MOV     W5,[W15++]
0292:  MOV     #C,W5
0294:  REPEAT  #3
0296:  MOV     [W5++],[W15++]
0298:  MUL.UU  W0,W2,W4
029A:  BTSS    W3.F
029C:  BRA     2A2
029E:  MUL.SS  W0,W3,W6
02A0:  BRA     2A4
02A2:  MUL.UU  W0,W3,W6
02A4:  BCLR.B  42.0
02A6:  ADD     W6,W5,W5
02A8:  ADDC    W7,#0,W8
02AA:  BTSS    W1.F
02AC:  BRA     2B2
02AE:  MUL.SS  W1,W2,W6
02B0:  BRA     2B4
02B2:  MUL.UU  W1,W2,W6
02B4:  ADDC    W6,W5,W5
02B6:  ADDC    W7,W8,W8
02B8:  ADDC    #0,W9
02BA:  MUL.SS  W1,W3,W6
02BC:  ADDC    W6,W8,W8
02BE:  ADDC    W9,W7,W7
02C0:  MOV     W7,W3
02C2:  MOV     W8,W2
02C4:  MOV     W5,W1
02C6:  MOV     W4,W0
02C8:  MOV     #12,W5
02CA:  REPEAT  #3
02CC:  MOV     [--W15],[W5--]
02CE:  MOV     [--W15],W5
02D0:  RETURN  
02D2:  MOV     W5,[W15++]
02D4:  MOV     #C,W5
02D6:  REPEAT  #3
02D8:  MOV     [W5++],[W15++]
02DA:  MOV     W0,W4
02DC:  MOV     W1,W5
02DE:  MOV     W2,W6
02E0:  MOV     W3,W7
02E2:  CLR     W0
02E4:  CLR     W1
02E6:  CLR     W2
02E8:  CLR     W3
02EA:  BCLR    W8.0
02EC:  BTSS    W7.F
02EE:  BRA     2FA
02F0:  BSET    W6.0
02F2:  NEG     W4,W4
02F4:  COM     W5,W5
02F6:  COM     W6,W6
02F8:  COM     W7,W7
02FA:  XOR     W4,W5,W9
02FC:  BRA     NZ,302
02FE:  XOR     W6,W7,W9
0300:  BRA     Z,32A
0302:  MOV     #D6,W1
0304:  BTSC    W2.7
0306:  BRA     31A
0308:  BCLR.B  42.0
030A:  RLC     W4,W4
030C:  RLC     W5,W5
030E:  RLC     W6,W6
0310:  RLC     W7,W7
0312:  RLC     W0,W0
0314:  RLC     W2,W2
0316:  DEC     W1,W1
0318:  BRA     NZ,304
031A:  SWAP    W1
031C:  BCLR.B  42.0
031E:  RRC     W1,W1
0320:  BCLR    W1.F
0322:  BCLR    W2.7
0324:  XOR.B   W2L,W1L,W1L
0326:  BTSC    W6.0
0328:  BSET    W1.F
032A:  MOV     #12,W5
032C:  REPEAT  #3
032E:  MOV     [--W15],[W5--]
0330:  MOV     [--W15],W5
0332:  RETURN  
0334:  MOV     W5,[W15++]
0336:  MOV     #C,W5
0338:  REPEAT  #4
033A:  MOV     [W5++],[W15++]
033C:  MOV     W0,W4
033E:  MOV     W1,W5
0340:  MOV     W3,W7
0342:  MOV     W2,W6
0344:  BCLR.B  42.0
0346:  BCLR.B  42.1
0348:  RLC     W1,W1
034A:  SWAP    W1
034C:  AND     #FF,W1
034E:  CP0     W1
0350:  BRA     Z,3E8
0352:  BCLR.B  42.0
0354:  BCLR.B  42.1
0356:  RLC     W3,W3
0358:  SWAP    W3
035A:  AND     #FF,W3
035C:  CP0     W3
035E:  BRA     Z,3E8
0360:  ZE      W0,W0
0362:  ADD.B   W3L,W1L,W0L
0364:  BRA     C,36E
0366:  SUB     #7F,W0
0368:  BRA     Z,3E8
036A:  BRA     NC,3E8
036C:  BRA     372
036E:  ADD.B   #81,W0L
0370:  BRA     C,3E8
0372:  XOR     W5,W7,W10
0374:  BCLR.B  42.0
0376:  BCLR.B  42.1
0378:  AND     #FF,W5
037A:  BSET    W5.7
037C:  BCLR.B  42.0
037E:  AND     #FF,W7
0380:  BSET    W7.7
0382:  MUL.UU  W4,W6,W2
0384:  MUL.UU  W5,W6,W8
0386:  ADDC    W8,W3,W3
0388:  MOV     W9,W1
038A:  BTSC.B  42.0
038C:  INC     W1,W1
038E:  BCLR.B  42.0
0390:  MUL.UU  W7,W4,W8
0392:  ADDC    W8,W3,W3
0394:  ADDC    W9,W1,W1
0396:  MUL.UU  W5,W7,W8
0398:  ADDC    W8,W1,W1
039A:  INC     W0,W0
039C:  CP0     W1
039E:  BTSC.B  42.1
03A0:  BRA     3A4
03A2:  BRA     3AA
03A4:  CP0     W3
03A6:  BTSC.B  42.1
03A8:  BRA     3B4
03AA:  BTSC    W1.F
03AC:  BRA     3B4
03AE:  RLC     W3,W3
03B0:  RLC     W1,W1
03B2:  DEC     W0,W0
03B4:  MOV     W1,W2
03B6:  BCLR.B  42.0
03B8:  BTSS    W3.7
03BA:  BRA     3CE
03BC:  MOV     #FF00,W7
03BE:  AND     W3,W7,W3
03C0:  ADD     #100,W3
03C2:  ADDC    W2,#0,W2
03C4:  CP0     W2
03C6:  BRA     NZ,3CE
03C8:  CP0     W3
03CA:  BRA     NZ,3CE
03CC:  INC     W0,W0
03CE:  SWAP    W0
03D0:  BCLR.B  42.0
03D2:  BCLR.B  42.1
03D4:  RRC     W0,W1
03D6:  BTSC    W10.F
03D8:  BSET    W1.F
03DA:  BCLR    W2.F
03DC:  SWAP    W2
03DE:  XOR.B   W2L,W1L,W1L
03E0:  SWAP    W3
03E2:  MOV.B   W3L,W2L
03E4:  MOV     W2,W0
03E6:  BRA     3EE
03E8:  MOV     #0,W0
03EA:  MOV     #0,W1
03EC:  BRA     3EE
03EE:  MOV     #14,W5
03F0:  REPEAT  #4
03F2:  MOV     [--W15],[W5--]
03F4:  MOV     [--W15],W5
03F6:  RETURN  
03F8:  MOV     W5,[W15++]
03FA:  MOV     #C,W5
03FC:  REPEAT  #3
03FE:  MOV     [W5++],[W15++]
0400:  CLR     W9
0402:  MOV     #8000,W8
0404:  BTSC.B  43.0
0406:  XOR     W8,W3,W3
0408:  CP0     W0
040A:  BRA     NZ,412
040C:  MOV     #7FFF,W10
040E:  AND     W1,W10,W10
0410:  BTSS.B  42.1
0412:  MOV     W1,W10
0414:  XOR     W3,W10,W11
0416:  MOV     W1,W6
0418:  MOV     W3,W7
041A:  MOV     W3,W12
041C:  BCLR.B  42.1
041E:  BCLR.B  42.0
0420:  RLC     W6,W6
0422:  SWAP    W6
0424:  AND     #FF,W6
0426:  CP0     W6
0428:  BRA     Z,56C
042A:  BCLR.B  42.1
042C:  BCLR.B  42.0
042E:  RLC     W7,W7
0430:  SWAP    W7
0432:  AND     #FF,W7
0434:  CP0     W7
0436:  BRA     Z,576
0438:  BCLR.B  42.1
043A:  BCLR.B  42.0
043C:  CP      W7,W6
043E:  BRA     Z,578
0440:  BRA     N,588
0442:  BCLR    W9.0
0444:  BSET    W9.1
0446:  SUB     W7,W6,W8
0448:  MOV     W7,W6
044A:  AND     #FF,W1
044C:  BSET    W1.7
044E:  AND     #FF,W3
0450:  BSET    W3.7
0452:  MOV     #28,W7
0454:  CP      W7,W8
0456:  BRA     N,47A
0458:  BCLR.B  42.1
045A:  BCLR.B  42.0
045C:  RRC     W1,W1
045E:  RRC     W0,W0
0460:  DEC     W8,W8
0462:  BRA     NZ,458
0464:  BRA     480
0466:  MOV     #28,W7
0468:  CP      W7,W8
046A:  BRA     N,47E
046C:  BCLR.B  42.1
046E:  BCLR.B  42.0
0470:  RRC     W3,W3
0472:  RRC     W2,W2
0474:  DEC     W8,W8
0476:  BRA     NZ,46C
0478:  BRA     498
047A:  MOV     W2,W0
047C:  MOV     W3,W1
047E:  BRA     506
0480:  BTSS    W11.F
0482:  BRA     4A6
0484:  BTSC    W9.4
0486:  MOV     W12,W11
0488:  NEG     W0,W0
048A:  BRA     Z,490
048C:  COM.B   W1L,W1L
048E:  BRA     492
0490:  NEG     W1,W1
0492:  BTSC    W9.4
0494:  BRA     4EC
0496:  BRA     4A6
0498:  BTSS    W11.F
049A:  BRA     4A6
049C:  NEG     W2,W2
049E:  BRA     Z,4A4
04A0:  COM.B   W3L,W3L
04A2:  BRA     4A6
04A4:  NEG     W3,W3
04A6:  AND     #FF,W5
04A8:  BCLR.B  42.1
04AA:  BCLR.B  42.0
04AC:  ADD     W0,W2,W0
04AE:  ADDC.B  W1L,W3L,W1L
04B0:  BTSC.B  42.0
04B2:  BSET    W9.3
04B4:  BTSC    W9.0
04B6:  BRA     4CA
04B8:  BTSC    W9.1
04BA:  BRA     4BE
04BC:  BRA     4D4
04BE:  BTSC    W11.F
04C0:  BRA     4EC
04C2:  BTSC    W9.3
04C4:  BRA     518
04C6:  BSET    W9.6
04C8:  BRA     506
04CA:  BTSC    W11.F
04CC:  BRA     4EC
04CE:  BTSC    W9.3
04D0:  BRA     518
04D2:  BRA     506
04D4:  BCLR    W9.2
04D6:  BTSC    W11.F
04D8:  BRA     4E2
04DA:  MOV     W10,W11
04DC:  BTSC    W9.3
04DE:  BRA     518
04E0:  BRA     54E
04E2:  BSET    W9.4
04E4:  XOR.B   #80,W1L
04E6:  BTSC    W1.7
04E8:  BRA     484
04EA:  MOV     W10,W11
04EC:  AND     #FF,W1
04EE:  IOR      W0,  W1,W7
04F0:  BRA     Z,506
04F2:  BTSC    W1.7
04F4:  BRA     506
04F6:  BCLR.B  42.1
04F8:  BCLR.B  42.0
04FA:  RLC     W0,W0
04FC:  RLC     W1,W1
04FE:  DEC     W6,W6
0500:  BTSC.B  42.1
0502:  BRA     566
0504:  BRA     4F2
0506:  BTSC    W9.0
0508:  MOV     W10,W11
050A:  BTSC    W9.1
050C:  MOV     W12,W11
050E:  BTSS    W9.5
0510:  BRA     546
0512:  BTSC    W10.F
0514:  BSET    W0.8
0516:  BRA     54E
0518:  BSET.B  42.0
051A:  RRC.B   W1L,W1L
051C:  RRC     W0,W0
051E:  BTSC.B  42.0
0520:  BSET    W9.5
0522:  INC     W6,W6
0524:  BRA     Z,566
0526:  BTSS    W9.5
0528:  BRA     53A
052A:  INC     W0,W0
052C:  BRA     NZ,53A
052E:  INC.B   W1L,W1L
0530:  BRA     NZ,53A
0532:  RRC.B   W1L,W1L
0534:  RRC     W0,W0
0536:  INC     W6,W6
0538:  BRA     Z,566
053A:  BTSC    W9.0
053C:  MOV     W10,W11
053E:  BTSC    W9.1
0540:  MOV     W12,W11
0542:  BTSC.B  42.1
0544:  BRA     566
0546:  BTSC    W9.6
0548:  MOV     W10,W11
054A:  BTSC    W9.7
054C:  MOV     W12,W11
054E:  IOR      W0,  W1,W2
0550:  BRA     Z,598
0552:  BCLR    W1.7
0554:  SWAP    W6
0556:  BCLR.B  42.1
0558:  BCLR.B  42.0
055A:  RRC     W6,W6
055C:  XOR     W6,W1,W1
055E:  BSET    W1.F
0560:  BTSS    W11.F
0562:  BCLR    W1.F
0564:  BRA     598
0566:  MOV     #0,W0
0568:  MOV     #0,W1
056A:  BRA     598
056C:  BTSC    W10.F
056E:  XOR     W8,W3,W3
0570:  MOV     W2,W0
0572:  MOV     W3,W1
0574:  BRA     598
0576:  BRA     598
0578:  AND     #FF,W3
057A:  BSET    W3.7
057C:  AND     #FF,W1
057E:  BSET    W1.7
0580:  BTSC    W11.F
0582:  BCLR    W3.7
0584:  BSET    W9.2
0586:  BRA     498
0588:  SUB     W6,W7,W8
058A:  AND     #FF,W1
058C:  BSET    W1.7
058E:  AND     #FF,W3
0590:  BSET    W3.7
0592:  BCLR    W9.1
0594:  BSET    W9.0
0596:  BRA     466
0598:  MOV     #12,W5
059A:  REPEAT  #3
059C:  MOV     [--W15],[W5--]
059E:  MOV     [--W15],W5
05A0:  RETURN  
05A2:  MOV     W0,W2
05A4:  MOV     W1,W3
05A6:  MOV.B   W1L,W0L
05A8:  SWAP    W0
05AA:  BSET    W0.F
05AC:  RLC     W1,W1
05AE:  SWAP    W1
05B0:  ZE      W1,W1
05B2:  MOV     #8E,W4
05B4:  SUB.B   W4L,W1L,W1L
05B6:  BRA     Z,5C4
05B8:  CP0     W0
05BA:  BRA     Z,5C4
05BC:  BCLR.B  42.0
05BE:  RRC     W0,W0
05C0:  DEC     W1,W1
05C2:  BRA     NZ,5B8
05C4:  BTSS    W3.F
05C6:  BRA     5CC
05C8:  NEG     W0,W0
05CA:  BRA     5CC
05CC:  RETURN  
*
0982:  MOV     W5,[W15++]
0984:  MOV     W6,[W15++]
0986:  MOV     W0,W4
0988:  MOV     W1,W5
098A:  CLR     W0
098C:  CLR     W1
098E:  BCLR    W6.0
0990:  BTSS    W5.F
0992:  BRA     9A0
0994:  BSET    W6.0
0996:  NEG     W4,W4
0998:  BRA     Z,99E
099A:  COM     W5,W5
099C:  BRA     9A0
099E:  NEG     W5,W5
09A0:  IOR      W4,  W5,W3
09A2:  BRA     Z,9CA
09A4:  CLR     W2
09A6:  MOV     #B6,W1
09A8:  BTSC    W2.7
09AA:  BRA     9BA
09AC:  BCLR.B  42.0
09AE:  RLC     W4,W4
09B0:  RLC     W5,W5
09B2:  RLC     W0,W0
09B4:  RLC     W2,W2
09B6:  DEC     W1,W1
09B8:  BRA     NZ,9A8
09BA:  SWAP    W1
09BC:  BCLR.B  42.0
09BE:  RRC     W1,W1
09C0:  BCLR    W1.F
09C2:  BCLR    W2.7
09C4:  XOR.B   W2L,W1L,W1L
09C6:  BTSC    W6.0
09C8:  BSET    W1.F
09CA:  MOV     [--W15],W6
09CC:  MOV     [--W15],W5
09CE:  RETURN  
09D0:  MOV     W5,[W15++]
09D2:  MOV     #C,W5
09D4:  REPEAT  #4
09D6:  MOV     [W5++],[W15++]
09D8:  CLR     W9
09DA:  XOR     W1,W3,W9
09DC:  MOV     W1,W6
09DE:  MOV     W0,W5
09E0:  MOV     W3,W8
09E2:  MOV     W2,W7
09E4:  RLC     W1,W1
09E6:  SWAP    W1
09E8:  ZE      W1,W1
09EA:  CP0     W1
09EC:  BRA     Z,A8A
09EE:  RLC     W3,W3
09F0:  SWAP    W3
09F2:  ZE      W3,W3
09F4:  CP0     W3
09F6:  BRA     Z,A8A
09F8:  CLR     W0
09FA:  SUB.B   W1L,W3L,W0L
09FC:  BRA     NC,A04
09FE:  ADD.B   #7F,W0L
0A00:  BRA     C,A8A
0A02:  BRA     A0A
0A04:  SUB.B   #81,W0L
0A06:  BRA     NC,A8A
0A08:  BRA     Z,A8A
0A0A:  MOV     W5,W1
0A0C:  MOV     W6,W2
0A0E:  BSET    W2.7
0A10:  AND     #FF,W2
0A12:  AND     #FF,W8
0A14:  BSET    W8.7
0A16:  MOV     #19,W10
0A18:  CLR     W3
0A1A:  CLR     W4
0A1C:  SUB     W1,W7,W1
0A1E:  SUBB    W2,W8,W2
0A20:  BRA     N,A26
0A22:  BRA     C,A2C
0A24:  BRA     NZ,A2E
0A26:  ADD     W1,W7,W1
0A28:  ADDC    W2,W8,W2
0A2A:  BRA     A2E
0A2C:  BSET    W4.0
0A2E:  DEC     W10,W10
0A30:  BRA     Z,A40
0A32:  BCLR.B  42.0
0A34:  RLC     W1,W1
0A36:  RLC     W2,W2
0A38:  BCLR.B  42.0
0A3A:  RLC     W4,W4
0A3C:  RLC     W3,W3
0A3E:  BRA     A1C
0A40:  CLR     W10
0A42:  BTSC    W3.8
0A44:  BRA     A48
0A46:  BRA     A54
0A48:  BCLR.B  42.0
0A4A:  RRC     W3,W3
0A4C:  BCLR    W3.7
0A4E:  RRC     W4,W4
0A50:  RLC     W10,W10
0A52:  BRA     A58
0A54:  DEC     W0,W0
0A56:  BRA     Z,A8A
0A58:  BTSC    W10.F
0A5A:  BRA     NC,A66
0A5C:  RLC     W1,W1
0A5E:  RLC     W2,W2
0A60:  SUB     W1,W7,W1
0A62:  SUBB    W2,W8,W2
0A64:  BRA     NC,A78
0A66:  INC     W4,W4
0A68:  BRA     NZ,A78
0A6A:  INC     W3,W3
0A6C:  BRA     NZ,A78
0A6E:  INC     W0,W0
0A70:  BRA     Z,A8A
0A72:  BRA     A78
0A74:  DEC     W0,W0
0A76:  BRA     Z,A8A
0A78:  SWAP    W0
0A7A:  RRC     W0,W1
0A7C:  BSET    W1.F
0A7E:  BTSS    W9.F
0A80:  BCLR    W1.F
0A82:  BCLR    W3.7
0A84:  XOR.B   W3L,W1L,W1L
0A86:  MOV     W4,W0
0A88:  BRA     A90
0A8A:  MOV     #0,W0
0A8C:  MOV     #0,W1
0A8E:  BRA     A90
0A90:  MOV     #14,W5
0A92:  REPEAT  #4
0A94:  MOV     [--W15],[W5--]
0A96:  MOV     [--W15],W5
0A98:  RETURN  
0A9A:  MOV     W8,[W15++]
0A9C:  MOV     #12,W8
0A9E:  REPEAT  #4
0AA0:  MOV     [W8++],[W15++]
0AA2:  MOV     #0,W9
0AA4:  BTSC.B  43.0
0AA6:  MOV     #1,W9
0AA8:  MOV     W9,[W15++]
0AAA:  CLR     W8
0AAC:  CLR     W9
0AAE:  CLR     W10
0AB0:  CLR     W11
0AB2:  CLR     W12
0AB4:  CLR     W13
0AB6:  MOV     #E,W8
0AB8:  MOV     #0,W9
0ABA:  LNK     #10
0ABC:  MOV     W12,[W14+W8]
0ABE:  DEC2    W8,W8
0AC0:  BRA     NN,ABC
0AC2:  XOR     W4,W5,W8
0AC4:  BRA     NZ,ACA
0AC6:  XOR     W6,W7,W8
0AC8:  BRA     Z,B5A
0ACA:  CLR     W8
0ACC:  CLR     W13
0ACE:  MOV     W13,[W15++]
0AD0:  BTSS    W3.F
0AD2:  BRA     AE8
0AD4:  MOV     [--W15],W13
0AD6:  BSET    W13.F
0AD8:  MOV     W13,[W15++]
0ADA:  COM     W3,W3
0ADC:  COM     W2,W2
0ADE:  COM     W1,W1
0AE0:  NEG     W0,W0
0AE2:  ADDC    W1,#0,W1
0AE4:  ADDC    W2,#0,W2
0AE6:  ADDC    W3,#0,W3
0AE8:  BTSS    W7.F
0AEA:  BRA     B00
0AEC:  MOV     [--W15],W13
0AEE:  BTG     W13.F
0AF0:  MOV     W13,[W15++]
0AF2:  COM     W7,W7
0AF4:  COM     W6,W6
0AF6:  COM     W5,W5
0AF8:  NEG     W4,W4
0AFA:  ADDC    W5,#0,W5
0AFC:  ADDC    W6,#0,W6
0AFE:  ADDC    W7,#0,W7
0B00:  MOV     #40,W13
0B02:  BCLR.B  42.0
0B04:  RLC     W0,W0
0B06:  RLC     W1,W1
0B08:  RLC     W2,W2
0B0A:  RLC     W3,W3
0B0C:  RLC     W8,W8
0B0E:  RLC     W9,W9
0B10:  RLC     W10,W10
0B12:  RLC     W11,W11
0B14:  CP      W11,W7
0B16:  BRA     NZ,B22
0B18:  CPB     W10,W6
0B1A:  BRA     NZ,B22
0B1C:  CPB     W9,W5
0B1E:  BRA     NZ,B22
0B20:  CPB     W8,W4
0B22:  BRA     NC,B2E
0B24:  SUB     W8,W4,W8
0B26:  SUBB    W9,W5,W9
0B28:  SUBB    W10,W6,W10
0B2A:  SUBB    W11,W7,W11
0B2C:  BSET.B  42.0
0B2E:  MOV     W8,[W14]
0B30:  MOV     W9,[W14+#2]
0B32:  MOV     W10,[W14+#4]
0B34:  MOV     W11,[W14+#6]
0B36:  MOV     [W14+#8],W8
0B38:  MOV     [W14+#A],W9
0B3A:  MOV     [W14+#C],W10
0B3C:  MOV     [W14+#E],W11
0B3E:  RLC     W8,W8
0B40:  RLC     W9,W9
0B42:  RLC     W10,W10
0B44:  RLC     W11,W11
0B46:  MOV     W8,[W14+#8]
0B48:  MOV     W9,[W14+#A]
0B4A:  MOV     W10,[W14+#C]
0B4C:  MOV     W11,[W14+#E]
0B4E:  MOV     [W14],W8
0B50:  MOV     [W14+#2],W9
0B52:  MOV     [W14+#4],W10
0B54:  MOV     [W14+#6],W11
0B56:  DEC     W13,W13
0B58:  BRA     NZ,B02
0B5A:  MOV     [W14+#8],W0
0B5C:  MOV     [W14+#A],W1
0B5E:  MOV     [W14+#C],W2
0B60:  MOV     [W14+#E],W3
0B62:  MOV     [--W15],W13
0B64:  BTSS    W13.F
0B66:  BRA     B76
0B68:  COM     W3,W3
0B6A:  COM     W2,W2
0B6C:  COM     W1,W1
0B6E:  NEG     W0,W0
0B70:  ADDC    W1,#0,W1
0B72:  ADDC    W2,#0,W2
0B74:  ADDC    W3,#0,W3
0B76:  ULNK    
0B78:  BRA     B7A
0B7A:  MOV     [--W15],W9
0B7C:  CP0     W9
0B7E:  BRA     Z,B88
0B80:  MOV     W8,W0
0B82:  MOV     W9,W1
0B84:  MOV     W10,W2
0B86:  MOV     W11,W3
0B88:  MOV     #1A,W8
0B8A:  REPEAT  #4
0B8C:  MOV     [--W15],[W8--]
0B8E:  MOV     [--W15],W8
0B90:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
0244:  MOV     W5,[W15++]
0246:  MOV     #4B00,W5
0248:  REPEAT  #19E
024A:  NOP     
024C:  DEC     W5,W5
024E:  BRA     NZ,256
0250:  CLR     85A
0252:  MOV     #0,W0
0254:  BRA     262
0256:  BTSS.B  232.0
0258:  BRA     248
025A:  PUSH    232
025C:  POP     85A
025E:  MOV     236,W0
0260:  BCLR.B  232.1
0262:  MOV     [--W15],W5
0264:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14   
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
.................... unsigned int8 InboundTriggerValue[4]; 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... signed int16  TempInputSamples[2]; 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
.................... FlagType OutputFlag = 0; 
.................... FlagType DMATriggerFlag = 0; 
.................... FlagType DigitTerminationFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... void DisableInterrupts(void); 
.................... void EnableInterrupts(void); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH]; // =  
.................... //!{ 
.................... //!210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... //!-246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... //!368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... //!1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... //!1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... //!368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... //!-246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... //!210 
.................... //! 
.................... //!}; 
.................... //! 
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,961
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0266:  PUSH    42
0268:  PUSH    36
026A:  PUSH    32
026C:  MOV     W0,[W15++]
026E:  MOV     #2,W0
0270:  REPEAT  #C
0272:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
0274:  CALL    244
0278:  MOV.B   W0L,861
....................    UARTRXFlag = 1; 
027A:  MOV.B   #1,W0L
027C:  MOV.B   W0L,1227
.................... } 
....................  
027E:  BCLR.B  87.6
0280:  MOV     #1A,W0
0282:  REPEAT  #C
0284:  MOV     [--W15],[W0--]
0286:  MOV     [--W15],W0
0288:  POP     32
028A:  POP     36
028C:  POP     42
028E:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
*
06A4:  PUSH    42
06A6:  PUSH    36
06A8:  PUSH    32
06AA:  MOV     W0,[W15++]
06AC:  MOV     #2,W0
06AE:  REPEAT  #C
06B0:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); 
06B2:  BCLR.B  2C9.6
06B4:  BTG.B   2CD.6
....................    //read_adc(); 
....................    if(NormalizeFlag == 1) 
06B6:  MOV     1226,W4
06B8:  CP.B    W4L,#1
06BA:  BRA     NZ,6CC
....................    { 
....................       read_adc(); 
06BC:  BCLR.B  320.0
06BE:  BSET.B  320.1
06C0:  BTSS.B  320.0
06C2:  BRA     6C0
....................       NormalizeDataCounter++; 
06C4:  INC     1222
06C6:  BTSC.B  42.1
06C8:  INC     1224
....................    } 
06CA:  BRA     760
....................    else 
....................    { 
....................       unsigned int16 ADCValue = 0; 
06CC:  CLR     12D6
....................        
....................       if (TriggerFlag != 2) 
06CE:  MOV     1228,W4
06D0:  LSR     W4,#8,W4
06D2:  CP.B    W4L,#2
06D4:  BRA     Z,6EA
....................       { 
....................           ADCValue = QuickDigitize(read_adc()); 
06D6:  BCLR.B  320.0
06D8:  BSET.B  320.1
06DA:  BTSS.B  320.0
06DC:  BRA     6DA
06DE:  MOV     300,W5
06E0:  MOV     W5,12DC
06E2:  CALL    5CE
06E6:  MOV.B   W0L,12D6
06E8:  CLR.B   12D7
....................       } 
....................        
....................       if (DMAFlag == 0) 
06EA:  CP0.B   122A
06EC:  BRA     NZ,6FC
....................       { 
....................          disable_interrupts(INT_DMA0); 
06EE:  BCLR.B  94.4
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
06F0:  MOV     #4000,W1
06F2:  MOV     #0,W2
06F4:  REPEAT  #1FD
06F6:  CLR.B   [W1++]
....................          DMAFlag = 1; 
06F8:  MOV.B   #1,W0L
06FA:  MOV.B   W0L,122A
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
06FC:  MOV     12D6,W0
06FE:  CP      96A
0700:  BRA     NZ,710
0702:  CP0.B   1229
0704:  BRA     NZ,710
....................       { 
....................          TempInputSamples[0] = ADCValue; 
0706:  PUSH    12D6
0708:  POP     11FA
....................          TriggerFlag = 1; 
070A:  MOV.B   #1,W0L
070C:  MOV.B   W0L,1229
....................       } 
070E:  BRA     760
....................       else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) 
0710:  MOV     11FA,W0
0712:  MOV     12D6,W4
0714:  CP      W4,W0
0716:  BRA     LE,72A
0718:  MOV     1228,W4
071A:  LSR     W4,#8,W4
071C:  CP.B    W4L,#1
071E:  BRA     NZ,72A
....................       { 
....................          TempInputSamples[1] = ADCValue; 
0720:  PUSH    12D6
0722:  POP     11FC
....................          TriggerFlag = 2; 
0724:  MOV.B   #2,W0L
0726:  MOV.B   W0L,1229
....................       } 
0728:  BRA     760
....................       else if(TriggerFlag == 2) 
072A:  MOV     1228,W4
072C:  LSR     W4,#8,W4
072E:  CP.B    W4L,#2
0730:  BRA     NZ,75E
....................       { 
....................          if(DMAFlag == 1) 
0732:  MOV     122A,W4
0734:  CP.B    W4L,#1
0736:  BRA     NZ,754
....................          { 
....................             memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0738:  MOV     #4000,W1
073A:  MOV     #0,W2
073C:  REPEAT  #1FD
073E:  CLR.B   [W1++]
....................             dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0740:  BCLR.B  381.7
0742:  CLR.B   380
0744:  MOV     #4000,W4
0746:  MOV     W4,384
0748:  MOV     #FF,W4
074A:  MOV     W4,38A
074C:  BSET.B  381.7
....................             enable_interrupts(INT_DMA0); 
074E:  BSET.B  94.4
....................             DMAFlag = 2; 
0750:  MOV.B   #2,W0L
0752:  MOV.B   W0L,122A
....................          } 
....................           
....................          read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
0754:  BCLR.B  320.0
0756:  BSET.B  320.1
0758:  BTSS.B  320.0
075A:  BRA     758
....................       }   
075C:  BRA     760
....................       else 
....................       { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
....................           
....................          TriggerFlag = 0; 
075E:  CLR.B   1229
....................       } 
....................    } 
0760:  BCLR.B  84.3
0762:  MOV     #1A,W0
0764:  REPEAT  #C
0766:  MOV     [--W15],[W0--]
0768:  MOV     [--W15],W0
076A:  POP     32
076C:  POP     36
076E:  POP     42
0770:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0F14:  MOV     #4444,W0
0F16:  MOV     W0,A4
0F18:  BSET.B  81.7
0F1A:  MOV     #46,W0
0F1C:  MOV.B   W0L,742
0F1E:  MOV     #57,W0
0F20:  MOV.B   W0L,742
0F22:  BCLR.B  742.6
0F24:  MOV     #3F07,W0
0F26:  MOV     W0,6A6
0F28:  MOV     #5,W0
0F2A:  MOV     W0,6C6
0F2C:  MOV     #46,W0
0F2E:  MOV.B   W0L,742
0F30:  MOV     #57,W0
0F32:  MOV.B   W0L,742
0F34:  BSET.B  742.6
0F36:  MOV     #41,W4
0F38:  MOV     W4,744
0F3A:  MOV     #32,W4
0F3C:  MOV     W4,746
0F3E:  CLR     85A
0F40:  MOV     #8000,W4
0F42:  MOV     W4,230
0F44:  MOV     #400,W4
0F46:  MOV     W4,232
0F48:  BSET.B  230.3
0F4A:  MOV     #22,W4
0F4C:  MOV     W4,238
0F4E:  CLR     85E
0F50:  CLR     968
0F52:  CLR     96A
0F54:  CLR     96C
0F56:  CLR     96E
0F58:  CLR     970
0F5A:  CLR     116A
0F5C:  CLR     116C
0F5E:  CLR     116E
0F60:  CLR     1170
0F62:  CLR     1172
0F64:  CLR     1174
0F66:  CLR     1176
0F68:  CLR     1178
0F6A:  CLR     1202
0F6C:  CLR     1204
0F6E:  CLR     1206
0F70:  CLR     1208
0F72:  CLR.B   861
0F74:  CLR     120A
0F76:  CLR     120C
0F78:  CLR     120E
0F7A:  CLR     1210
0F7C:  CLR     1212
0F7E:  CLR     1214
0F80:  CLR     1216
0F82:  CLR     1218
0F84:  CLR     121A
0F86:  CLR     121C
0F88:  CLR     121E
0F8A:  CLR     1220
0F8C:  CLR     1222
0F8E:  CLR     1224
0F90:  CLR.B   961
0F92:  CLR.B   1226
0F94:  CLR.B   1227
0F96:  CLR.B   1228
0F98:  CLR.B   1229
0F9A:  CLR.B   122A
0F9C:  CLR.B   122B
0F9E:  CLR.B   122C
0FA0:  CLR.B   122D
0FA2:  MOV     #41,W4
0FA4:  MOV     W4,744
0FA6:  MOV     #32,W4
0FA8:  MOV     W4,746
0FAA:  DISI    #E
0FAC:  MOV     #101,W0
0FAE:  MOV     #743,W1
0FB0:  MOV     #78,W2
0FB2:  MOV     #9A,W3
0FB4:  MOV.B   W2L,[W1]
0FB6:  MOV.B   W3L,[W1]
0FB8:  MOV.B   W0L,743
0FBA:  LSR     W0,#8,W0
0FBC:  MOV     #742,W1
0FBE:  MOV     #46,W2
0FC0:  MOV     #57,W3
0FC2:  MOV.B   W2L,[W1]
0FC4:  MOV.B   W3L,[W1]
0FC6:  MOV.B   W0L,[W1]
0FC8:  SETM    32C
0FCA:  MOV     #3F80,W15
0FCC:  MOV     #3FFF,W0
0FCE:  MOV     W0,20
0FD0:  NOP     
0FD2:  CLR     85C
0FD4:  MOV     #3F80,W15
0FD6:  MOV     #3FFF,W0
0FD8:  MOV     W0,20
0FDA:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0FDC:  MOV     #4000,W1
0FDE:  MOV     #0,W2
0FE0:  REPEAT  #FE
0FE2:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0FE4:  MOV     #41FE,W1
0FE6:  MOV     #61,W2
0FE8:  MOV.B   #61,W2L
0FEA:  REPEAT  #FE
0FEC:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0FEE:  CLR.B   381
0FF0:  MOV.B   #D,W0L
0FF2:  MOV.B   W0L,382
0FF4:  MOV     #300,W4
0FF6:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0FF8:  BCLR.B  381.7
0FFA:  CLR.B   380
0FFC:  MOV     #4000,W4
0FFE:  MOV     W4,384
1000:  MOV     #FF,W4
1002:  MOV     W4,38A
1004:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
1006:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
1008:  MOV     #9F00,W4
100A:  MOV     W4,324
100C:  MOV     #84E0,W4
100E:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
1010:  MOV     #FFFE,W4
1012:  MOV     W4,32C
1014:  CLR     322
....................     
....................    read_adc(); 
1016:  BCLR.B  320.0
1018:  BSET.B  320.1
101A:  BTSS.B  320.0
101C:  BRA     101A
....................     
....................    //TimerTicks = 53334; 
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
101E:  CLR     104
1020:  PUSH    85E
1022:  POP     102
1024:  MOV     #8000,W4
1026:  MOV     W4,104
....................    EnableInterrupts(); 
1028:  CALL    772
....................     
....................    NormalizeFlag = 1; 
102C:  MOV.B   #1,W0L
102E:  MOV.B   W0L,1226
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
1030:  CP0.B   961
1032:  BRA     NZ,103E
1034:  MOV     1222,W4
1036:  XOR     #FF,W4
1038:  BRA     NZ,10FA
103A:  CP0     1224
103C:  BRA     NZ,10FA
....................       { 
....................          disable_interrupts(INT_DMA0); 
103E:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
1040:  CLR     12AE
1042:  CLR     12B0
1044:  MOV     12B0,W4
1046:  CP      W4,#0
1048:  BRA     GTU,1068
104A:  BRA     NC,1054
104C:  MOV     12AE,W4
104E:  MOV     #FF,W3
1050:  CP      W3,W4
1052:  BRA     LEU,1068
....................          { 
....................             AccumulateAnalogData(Index); 
1054:  PUSH    12AE
1056:  POP     12B8
1058:  PUSH    12B0
105A:  POP     12BA
105C:  CALL    77E
1060:  INC     12AE
1062:  BTSC.B  42.1
1064:  INC     12B0
1066:  BRA     1044
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
1068:  MOV     1226,W4
106A:  CP.B    W4L,#1
106C:  BRA     NZ,1072
....................          { 
....................             NormalizeData(); 
106E:  CALL    B92
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
1072:  MOV     1228,W4
1074:  CP.B    W4L,#1
1076:  BRA     NZ,10EA
....................          { 
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
1078:  CLR     12B2
107A:  CLR     12B4
107C:  MOV     12B4,W4
107E:  CP      W4,#0
1080:  BRA     GTU,10A6
1082:  BRA     NC,108C
1084:  MOV     12B2,W4
1086:  MOV     #FF,W3
1088:  CP      W3,W4
108A:  BRA     LEU,10A6
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
108C:  MOV     #862,W4
108E:  MOV     12B2,W3
1090:  ADD     W3,W4,W0
1092:  MOV.B   [W0],W5L
1094:  BTSC.B  233.1
1096:  BRA     1094
1098:  PUSH    234
109A:  MOV.B   W5L,[W15-#2]
109C:  POP     234
109E:  INC     12B2
10A0:  BTSC.B  42.1
10A2:  INC     12B4
10A4:  BRA     107C
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
10A6:  CLR     12B2
10A8:  CLR     12B4
10AA:  MOV     12B4,W4
10AC:  CP      W4,#0
10AE:  BRA     GTU,10EA
10B0:  BRA     NC,10BA
10B2:  MOV     12B2,W4
10B4:  MOV     #FF,W3
10B6:  CP      W3,W4
10B8:  BRA     LEU,10EA
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
10BA:  MOV     #2,W4
10BC:  CLR.B   9
10BE:  MOV     12B2,W0
10C0:  MOV     12B4,W1
10C2:  INC     W4,W4
10C4:  DEC     W4,W4
10C6:  BRA     Z,10CE
10C8:  SL      W0,W0
10CA:  RLC     W1,W1
10CC:  BRA     10C4
10CE:  MOV     #972,W4
10D0:  ADD     W0,W4,W0
10D2:  MOV     #A,W4
10D4:  MOV     [W0++],[W4++]
10D6:  MOV     [W0++],[W4++]
10D8:  BTSC.B  233.1
10DA:  BRA     10D8
10DC:  PUSH    234
10DE:  MOV.B   W5L,[W15-#2]
10E0:  POP     234
10E2:  INC     12B2
10E4:  BTSC.B  42.1
10E6:  INC     12B4
10E8:  BRA     10AA
....................             } 
....................          } 
....................           
....................          NormalizeFlag = 0; 
10EA:  CLR.B   1226
....................          HandShakeFlag = 0;    
10EC:  CLR.B   1228
....................          CurrentIndex = 0; 
10EE:  CLR     1216
10F0:  CLR     1218
....................          enable_interrupts(INT_DMA0); 
10F2:  BSET.B  94.4
....................          DMADoneFlag = 0; 
10F4:  CLR.B   961
....................          TriggerFlag = 0; 
10F6:  CLR.B   1229
....................          DMAFlag = 0; 
10F8:  CLR.B   122A
....................       }   
....................        
....................       if (UARTRXFlag) 
10FA:  CP0.B   1227
10FC:  BRA     Z,1106
....................       { 
....................          CommHandler(UARTRX); 
10FE:  MOV.B   861,W0L
1100:  MOV.B   W0L,12B8
1102:  CALL    DC4
....................       }   
1106:  BRA     1030
....................    } 
.................... } 
....................  
1108:  BRA     1108
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
077E:  MOV     W5,[W15++]
0780:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
0782:  MOV     #1,W4
0784:  CLR.B   9
0786:  MOV     1216,W0
0788:  MOV     1218,W1
078A:  INC     W4,W4
078C:  DEC     W4,W4
078E:  BRA     Z,796
0790:  SL      W0,W0
0792:  RLC     W1,W1
0794:  BRA     78C
0796:  MOV     #117A,W4
0798:  ADD     W0,W4,W5
079A:  MOV     #1,W4
079C:  CLR.B   9
079E:  MOV     12B8,W0
07A0:  MOV     12BA,W1
07A2:  INC     W4,W4
07A4:  DEC     W4,W4
07A6:  BRA     Z,7AE
07A8:  SL      W0,W0
07AA:  RLC     W1,W1
07AC:  BRA     7A4
07AE:  MOV     #4000,W4
07B0:  ADD     W0,W4,W0
07B2:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
07B4:  PUSH    1216
07B6:  POP     1212
07B8:  PUSH    1218
07BA:  POP     1214
....................    Accumulator = 0; 
07BC:  CLR     96E
07BE:  CLR     970
....................    CoefficentIndex = 0; 
07C0:  CLR     120E
07C2:  CLR     1210
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
07C4:  MOV     1210,W4
07C6:  CP      W4,#0
07C8:  BRA     GTU,85A
07CA:  BRA     NC,7D4
07CC:  MOV     120E,W4
07CE:  MOV     #3F,W3
07D0:  CP      W3,W4
07D2:  BRA     LEU,85A
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
07D4:  MOV     #1,W4
07D6:  CLR.B   9
07D8:  MOV     1212,W0
07DA:  MOV     1214,W1
07DC:  INC     W4,W4
07DE:  DEC     W4,W4
07E0:  BRA     Z,7E8
07E2:  SL      W0,W0
07E4:  RLC     W1,W1
07E6:  BRA     7DE
07E8:  MOV     #117A,W4
07EA:  ADD     W0,W4,W0
07EC:  MOV     W0,W4
07EE:  MOV     [W4],W0
07F0:  MOV     W0,W5
07F2:  CLR     W6
07F4:  BTSC    W5.F
07F6:  SETM    W6
07F8:  MOV     #1,W4
07FA:  CLR.B   9
07FC:  MOV     120E,W0
07FE:  MOV     1210,W1
0800:  INC     W4,W4
0802:  DEC     W4,W4
0804:  BRA     Z,80C
0806:  SL      W0,W0
0808:  RLC     W1,W1
080A:  BRA     802
080C:  MOV     #122E,W4
080E:  ADD     W0,W4,W0
0810:  MOV     W0,W4
0812:  MOV     [W4],W0
0814:  CLR     W1
0816:  BTSC    W0.F
0818:  SETM    W1
081A:  PUSH    42
081C:  BCLR.B  81.7
081E:  SETM.B  42
0820:  BSET.B  81.7
0822:  MOV     W0,W2
0824:  MOV     W1,W3
0826:  MOV     W5,W0
0828:  MOV     W6,W1
082A:  CALL    290
082E:  BCLR.B  81.7
0830:  POP     42
0832:  BSET.B  81.7
0834:  ADD     96E
0836:  MOV     W1,W0
0838:  ADDC    970,W0
083A:  MOV     W0,970
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
083C:  MOV     1212,W4
083E:  XOR     #3F,W4
0840:  BRA     NZ,84C
0842:  CP0     1214
0844:  BRA     NZ,84C
....................       { 
....................          InputIndex = 0; 
0846:  CLR     1212
0848:  CLR     1214
....................       } 
084A:  BRA     852
....................       else 
....................       { 
....................          InputIndex++; 
084C:  INC     1212
084E:  BTSC.B  42.1
0850:  INC     1214
....................       } 
....................        
....................       CoefficentIndex++; 
0852:  INC     120E
0854:  BTSC.B  42.1
0856:  INC     1210
0858:  BRA     7C4
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
085A:  MOV     #862,W4
085C:  MOV     12B8,W3
085E:  ADD     W3,W4,W5
0860:  MOV     #1,W4
0862:  CLR.B   9
0864:  MOV     1216,W0
0866:  MOV     1218,W1
0868:  INC     W4,W4
086A:  DEC     W4,W4
086C:  BRA     Z,874
086E:  SL      W0,W0
0870:  RLC     W1,W1
0872:  BRA     86A
0874:  MOV     #117A,W4
0876:  ADD     W0,W4,W0
0878:  MOV     [W0],W6
087A:  LSR     W6,#4,W0
087C:  MOV.B   W0L,[W5]
087E:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
0880:  MOV     1226,W4
0882:  CP.B    W4L,#1
0884:  BRA     NZ,8A6
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
0886:  MOV     #2,W4
0888:  CLR.B   9
088A:  MOV     12B8,W0
088C:  MOV     12BA,W1
088E:  INC     W4,W4
0890:  DEC     W4,W4
0892:  BRA     Z,89A
0894:  SL      W0,W0
0896:  RLC     W1,W1
0898:  BRA     890
089A:  MOV     #972,W4
089C:  ADD     W0,W4,W5
089E:  MOV     #96E,W4
08A0:  MOV     [W4++],[W5++]
08A2:  MOV     [W4++],[W5++]
....................    } 
08A4:  BRA     966
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
08A6:  MOV     96E,W0
08A8:  MOV     970,W1
08AA:  CLR     W3
08AC:  BTSC    W1.F
08AE:  SETM    W3
08B0:  MOV     W3,W2
08B2:  MOV     1172,W4
08B4:  SUB     W0,W4,W0
08B6:  MOV     1174,W4
08B8:  SUBB    W1,W4,W1
08BA:  MOV     1176,W4
08BC:  SUBB    W2,W4,W2
08BE:  MOV     1178,W4
08C0:  SUBB    W3,W4,W3
08C2:  CALL    2D2
08C6:  MOV     W0,12BC
08C8:  MOV     W1,12BE
08CA:  PUSH    42
08CC:  BCLR.B  81.7
08CE:  SETM.B  42
08D0:  BSET.B  81.7
08D2:  MOV     12BC,W0
08D4:  MOV     12BE,W1
08D6:  MOV     1206,W2
08D8:  MOV     1208,W3
08DA:  CALL    334
08DE:  BCLR.B  81.7
08E0:  POP     42
08E2:  BSET.B  81.7
08E4:  MOV     W0,12C0
08E6:  MOV     W1,12C2
08E8:  BCLR.B  43.0
08EA:  PUSH    42
08EC:  BCLR.B  81.7
08EE:  SETM.B  42
08F0:  BSET.B  81.7
08F2:  MOV     12C0,W0
08F4:  MOV     12C2,W1
08F6:  MOV     #0,W2
08F8:  MOV     #42FE,W3
08FA:  CALL    3F8
08FE:  BCLR.B  81.7
0900:  POP     42
0902:  BSET.B  81.7
0904:  MOV     W0,12C4
0906:  MOV     W1,12C6
....................       //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................       //ConversionValue = (unsigned int8)OutputValue; 
....................       ConversionValue = (unsigned int8)StepThree; 
0908:  PUSH    42
090A:  BCLR.B  81.7
090C:  SETM.B  42
090E:  BSET.B  81.7
0910:  MOV     12C4,W0
0912:  MOV     12C6,W1
0914:  CALL    5A2
0918:  BCLR.B  81.7
091A:  POP     42
091C:  BSET.B  81.7
091E:  MOV.B   W0L,860
....................       DebugAccumulator[DMAADCIndex] = Accumulator; 
0920:  MOV     #2,W4
0922:  CLR.B   9
0924:  MOV     12B8,W0
0926:  MOV     12BA,W1
0928:  INC     W4,W4
092A:  DEC     W4,W4
092C:  BRA     Z,934
092E:  SL      W0,W0
0930:  RLC     W1,W1
0932:  BRA     92A
0934:  MOV     #D6E,W4
0936:  ADD     W0,W4,W5
0938:  MOV     #96E,W4
093A:  MOV     [W4++],[W5++]
093C:  MOV     [W4++],[W5++]
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
093E:  MOV     #2,W4
0940:  CLR.B   9
0942:  MOV     12B8,W0
0944:  MOV     12BA,W1
0946:  INC     W4,W4
0948:  DEC     W4,W4
094A:  BRA     Z,952
094C:  SL      W0,W0
094E:  RLC     W1,W1
0950:  BRA     948
0952:  MOV     #972,W4
0954:  ADD     W0,W4,W5
0956:  MOV     860,W0
0958:  MOV.B   W0L,[W5+#0]
095A:  MOV.B   #0,W0L
095C:  MOV.B   W0L,[W5+#1]
095E:  MOV.B   #0,W0L
0960:  MOV.B   W0L,[W5+#2]
0962:  MOV.B   #0,W0L
0964:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................     if (CurrentIndex == 0) 
0966:  CP0     1216
0968:  BRA     NZ,976
096A:  CP0     1218
096C:  BRA     NZ,976
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
096E:  MOV     #3F,W4
0970:  MOV     W4,1216
0972:  CLR     1218
....................    } 
0974:  BRA     97C
....................    else 
....................    { 
....................      CurrentIndex--; 
0976:  DEC     1216
0978:  BTSS.B  42.0
097A:  DEC     1218
....................    }  
097C:  MOV     [--W15],W6
097E:  MOV     [--W15],W5
0980:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
0B92:  MOV     W5,[W15++]
0B94:  MOV     W6,[W15++]
0B96:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0B98:  MOV     1220,W4
0B9A:  CP      W4,#0
0B9C:  BRA     GTU,D3C
0B9E:  BRA     NC,BA8
0BA0:  MOV     121E,W4
0BA2:  MOV     #BB8,W3
0BA4:  CP      W3,W4
0BA6:  BRA     LEU,D3C
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0BA8:  PUSH    A72
0BAA:  POP     116A
0BAC:  PUSH    A74
0BAE:  POP     116C
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0BB0:  PUSH    A72
0BB2:  POP     116E
0BB4:  PUSH    A74
0BB6:  POP     1170
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0BB8:  PUSH    4080
0BBA:  POP     968
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0BBC:  MOV     #41,W4
0BBE:  MOV     W4,12B8
0BC0:  CLR     12BA
0BC2:  MOV     12BA,W4
0BC4:  CP      W4,#0
0BC6:  BRA     GTU,CEC
0BC8:  BRA     NC,BD2
0BCA:  MOV     12B8,W4
0BCC:  MOV     #FF,W3
0BCE:  CP      W3,W4
0BD0:  BRA     LEU,CEC
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0BD2:  MOV     #2,W4
0BD4:  CLR.B   9
0BD6:  MOV     12B8,W0
0BD8:  MOV     12BA,W1
0BDA:  INC     W4,W4
0BDC:  DEC     W4,W4
0BDE:  BRA     Z,BE6
0BE0:  SL      W0,W0
0BE2:  RLC     W1,W1
0BE4:  BRA     BDC
0BE6:  MOV     #972,W4
0BE8:  ADD     W0,W4,W0
0BEA:  MOV     W0,W4
0BEC:  MOV     #0,W3
0BEE:  MOV     [W4++],[W3++]
0BF0:  MOV     [W4++],[W3++]
0BF2:  MOV     1170,W4
0BF4:  CP      W4,W1
0BF6:  BRA     LT,C1E
0BF8:  BRA     GT,C00
0BFA:  MOV     116E,W4
0BFC:  CP      W4,W0
0BFE:  BRA     LEU,C1E
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0C00:  MOV     #2,W4
0C02:  CLR.B   9
0C04:  MOV     12B8,W0
0C06:  MOV     12BA,W1
0C08:  INC     W4,W4
0C0A:  DEC     W4,W4
0C0C:  BRA     Z,C14
0C0E:  SL      W0,W0
0C10:  RLC     W1,W1
0C12:  BRA     C0A
0C14:  MOV     #972,W4
0C16:  ADD     W0,W4,W0
0C18:  MOV     #116E,W4
0C1A:  MOV     [W0++],[W4++]
0C1C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0C1E:  MOV     #2,W4
0C20:  CLR.B   9
0C22:  MOV     12B8,W0
0C24:  MOV     12BA,W1
0C26:  INC     W4,W4
0C28:  DEC     W4,W4
0C2A:  BRA     Z,C32
0C2C:  SL      W0,W0
0C2E:  RLC     W1,W1
0C30:  BRA     C28
0C32:  MOV     #972,W4
0C34:  ADD     W0,W4,W0
0C36:  MOV     W0,W4
0C38:  MOV     #0,W3
0C3A:  MOV     [W4++],[W3++]
0C3C:  MOV     [W4++],[W3++]
0C3E:  MOV     116C,W4
0C40:  CP      W4,W1
0C42:  BRA     GT,C6A
0C44:  BRA     LT,C4C
0C46:  MOV     116A,W4
0C48:  CP      W4,W0
0C4A:  BRA     C,C6A
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0C4C:  MOV     #2,W4
0C4E:  CLR.B   9
0C50:  MOV     12B8,W0
0C52:  MOV     12BA,W1
0C54:  INC     W4,W4
0C56:  DEC     W4,W4
0C58:  BRA     Z,C60
0C5A:  SL      W0,W0
0C5C:  RLC     W1,W1
0C5E:  BRA     C56
0C60:  MOV     #972,W4
0C62:  ADD     W0,W4,W0
0C64:  MOV     #116A,W4
0C66:  MOV     [W0++],[W4++]
0C68:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0C6A:  MOV     #1,W4
0C6C:  CLR.B   9
0C6E:  MOV     12B8,W0
0C70:  MOV     12BA,W1
0C72:  INC     W4,W4
0C74:  DEC     W4,W4
0C76:  BRA     Z,C7E
0C78:  SL      W0,W0
0C7A:  RLC     W1,W1
0C7C:  BRA     C74
0C7E:  MOV     #4000,W4
0C80:  ADD     W0,W4,W0
0C82:  MOV     W0,W4
0C84:  MOV     [W4],W0
0C86:  MOV     968,W4
0C88:  CP      W4,W0
0C8A:  BRA     LEU,CA8
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0C8C:  MOV     #1,W4
0C8E:  CLR.B   9
0C90:  MOV     12B8,W0
0C92:  MOV     12BA,W1
0C94:  INC     W4,W4
0C96:  DEC     W4,W4
0C98:  BRA     Z,CA0
0C9A:  SL      W0,W0
0C9C:  RLC     W1,W1
0C9E:  BRA     C96
0CA0:  MOV     #4000,W4
0CA2:  ADD     W0,W4,W0
0CA4:  MOV     [W0],[W15++]
0CA6:  POP     968
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0CA8:  MOV     #2,W4
0CAA:  CLR.B   9
0CAC:  MOV     12B8,W0
0CAE:  MOV     12BA,W1
0CB0:  INC     W4,W4
0CB2:  DEC     W4,W4
0CB4:  BRA     Z,CBC
0CB6:  SL      W0,W0
0CB8:  RLC     W1,W1
0CBA:  BRA     CB2
0CBC:  MOV     #972,W4
0CBE:  ADD     W0,W4,W0
0CC0:  MOV     W0,W4
0CC2:  MOV     #0,W3
0CC4:  MOV     [W4++],[W3++]
0CC6:  MOV     [W4++],[W3++]
0CC8:  CLR     W3
0CCA:  BTSC    W1.F
0CCC:  SETM    W3
0CCE:  MOV     W3,W2
0CD0:  ADD     1172
0CD2:  MOV     W1,W0
0CD4:  ADDC    1174,W0
0CD6:  MOV     W0,1174
0CD8:  MOV     1176,W4
0CDA:  ADDC    W2,W4,W0
0CDC:  MOV     W0,1176
0CDE:  MOV     1178,W4
0CE0:  ADDC    W3,W4,W0
0CE2:  MOV     W0,1178
0CE4:  INC     12B8
0CE6:  BTSC.B  42.1
0CE8:  INC     12BA
0CEA:  BRA     BC2
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0CEC:  MOV     116A,W4
0CEE:  MOV     116E,W3
0CF0:  SUB     W4,W3,W0
0CF2:  MOV     116C,W4
0CF4:  MOV     1170,W3
0CF6:  SUBB    W4,W3,W1
0CF8:  CALL    982
0CFC:  MOV     W0,1202
0CFE:  MOV     W1,1204
....................       AverageMultiplier = (255.0/ AverageDivider); 
0D00:  MOV     #0,W0
0D02:  MOV     #437F,W1
0D04:  MOV     1202,W2
0D06:  MOV     1204,W3
0D08:  CALL    9D0
0D0C:  MOV     W0,1206
0D0E:  MOV     W1,1208
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0D10:  BCLR.B  43.0
0D12:  MOV     1172,W0
0D14:  MOV     1174,W1
0D16:  MOV     1176,W2
0D18:  MOV     1178,W3
0D1A:  MOV     #BF,W4
0D1C:  MOV     #0,W5
0D1E:  MOV     #0,W6
0D20:  MOV     #0,W7
0D22:  CALL    A9A
0D26:  MOV     W0,1172
0D28:  MOV     W1,1174
0D2A:  MOV     W2,1176
0D2C:  MOV     W3,1178
....................        
....................       TriggerValue = InitialTriggerValue; 
0D2E:  PUSH    968
0D30:  POP     96A
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0D32:  MOV     #972,W1
0D34:  MOV     #0,W2
0D36:  REPEAT  #1FD
0D38:  CLR.B   [W1++]
....................    }   
0D3A:  BRA     DA4
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0D3C:  PUSH    4080
0D3E:  POP     968
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0D40:  MOV     #41,W4
0D42:  MOV     W4,12BC
0D44:  CLR     12BE
0D46:  MOV     12BE,W4
0D48:  CP      W4,#0
0D4A:  BRA     GTU,D9C
0D4C:  BRA     NC,D56
0D4E:  MOV     12BC,W4
0D50:  MOV     #FF,W3
0D52:  CP      W3,W4
0D54:  BRA     LEU,D9C
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0D56:  MOV     #1,W4
0D58:  CLR.B   9
0D5A:  MOV     12BC,W0
0D5C:  MOV     12BE,W1
0D5E:  INC     W4,W4
0D60:  DEC     W4,W4
0D62:  BRA     Z,D6A
0D64:  SL      W0,W0
0D66:  RLC     W1,W1
0D68:  BRA     D60
0D6A:  MOV     #4000,W4
0D6C:  ADD     W0,W4,W0
0D6E:  MOV     W0,W4
0D70:  MOV     [W4],W0
0D72:  MOV     968,W4
0D74:  CP      W4,W0
0D76:  BRA     LEU,D94
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0D78:  MOV     #1,W4
0D7A:  CLR.B   9
0D7C:  MOV     12BC,W0
0D7E:  MOV     12BE,W1
0D80:  INC     W4,W4
0D82:  DEC     W4,W4
0D84:  BRA     Z,D8C
0D86:  SL      W0,W0
0D88:  RLC     W1,W1
0D8A:  BRA     D82
0D8C:  MOV     #4000,W4
0D8E:  ADD     W0,W4,W0
0D90:  MOV     [W0],[W15++]
0D92:  POP     968
....................         }              
0D94:  INC     12BC
0D96:  BTSC.B  42.1
0D98:  INC     12BE
0D9A:  BRA     D46
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0D9C:  PUSH    968
0D9E:  POP     96A
....................       ErrorCounter = 0;  
0DA0:  CLR     121E
0DA2:  CLR     1220
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0DA4:  CLR     1222
0DA6:  CLR     1224
....................    NormalizeFlag = 0; 
0DA8:  CLR.B   1226
....................    CurrentIndex = 0; 
0DAA:  CLR     1216
0DAC:  CLR     1218
0DAE:  MOV     [--W15],W7
0DB0:  MOV     [--W15],W6
0DB2:  MOV     [--W15],W5
0DB4:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
*
05CE:  MOV     W5,[W15++]
05D0:  MOV     W6,[W15++]
.................... { 
....................     InputIndex = CurrentIndex; 
05D2:  PUSH    1216
05D4:  POP     1212
05D6:  PUSH    1218
05D8:  POP     1214
....................     CoefficentIndex = 0; 
05DA:  CLR     120E
05DC:  CLR     1210
....................     Accumulator = 0; 
05DE:  CLR     96E
05E0:  CLR     970
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
05E2:  MOV     1210,W4
05E4:  CP      W4,#0
05E6:  BRA     GTU,64A
05E8:  BRA     NC,5F2
05EA:  MOV     120E,W4
05EC:  MOV     #3F,W3
05EE:  CP      W3,W4
05F0:  BRA     LEU,64A
....................       { 
....................          Accumulator += (signed int32)ADCValue * (signed int32)fir_coef[CoefficentIndex]; 
05F2:  MOV     12DC,W5
05F4:  MOV     #0,W6
05F6:  MOV     #1,W4
05F8:  CLR.B   9
05FA:  MOV     120E,W0
05FC:  MOV     1210,W1
05FE:  INC     W4,W4
0600:  DEC     W4,W4
0602:  BRA     Z,60A
0604:  SL      W0,W0
0606:  RLC     W1,W1
0608:  BRA     600
060A:  MOV     #122E,W4
060C:  ADD     W0,W4,W0
060E:  MOV     W0,W4
0610:  MOV     [W4],W0
0612:  CLR     W1
0614:  BTSC    W0.F
0616:  SETM    W1
0618:  MOV     W0,W2
061A:  MOV     W1,W3
061C:  MOV     W5,W0
061E:  MOV     W6,W1
0620:  CALL    290
0624:  ADD     96E
0626:  MOV     W1,W0
0628:  ADDC    970,W0
062A:  MOV     W0,970
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
062C:  MOV     1212,W4
062E:  XOR     #3F,W4
0630:  BRA     NZ,63C
0632:  CP0     1214
0634:  BRA     NZ,63C
....................          { 
....................             InputIndex = 0; 
0636:  CLR     1212
0638:  CLR     1214
....................          } 
063A:  BRA     642
....................          else 
....................          { 
....................             InputIndex++; 
063C:  INC     1212
063E:  BTSC.B  42.1
0640:  INC     1214
....................          } 
....................          CoefficentIndex++; 
0642:  INC     120E
0644:  BTSC.B  42.1
0646:  INC     1210
0648:  BRA     5E2
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
064A:  MOV     96E,W0
064C:  MOV     970,W1
064E:  CLR     W3
0650:  BTSC    W1.F
0652:  SETM    W3
0654:  MOV     W3,W2
0656:  MOV     1172,W4
0658:  SUB     W0,W4,W0
065A:  MOV     1174,W4
065C:  SUBB    W1,W4,W1
065E:  MOV     1176,W4
0660:  SUBB    W2,W4,W2
0662:  MOV     1178,W4
0664:  SUBB    W3,W4,W3
0666:  CALL    2D2
066A:  MOV     W0,12DE
066C:  MOV     W1,12E0
066E:  MOV     12DE,W0
0670:  MOV     12E0,W1
0672:  MOV     1206,W2
0674:  MOV     1208,W3
0676:  CALL    334
067A:  MOV     W0,12E2
067C:  MOV     W1,12E4
067E:  BCLR.B  43.0
0680:  MOV     12E2,W0
0682:  MOV     12E4,W1
0684:  MOV     #0,W2
0686:  MOV     #42FE,W3
0688:  CALL    3F8
068C:  MOV     W0,12E6
068E:  MOV     W1,12E8
0690:  MOV     12E6,W0
0692:  MOV     12E8,W1
0694:  CALL    5A2
0698:  MOV.B   W0L,12EA
....................        
....................     return ConversionValue;   
069A:  MOV.B   12EA,W0L
069C:  MOV.B   W0L,0
069E:  MOV     [--W15],W6
06A0:  MOV     [--W15],W5
06A2:  RETURN  
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0DC4:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0DC6:  MOV.B   12B8,W0L
0DC8:  CLR.B   1
0DCA:  XOR     #2B,W0
0DCC:  BRA     Z,DE0
0DCE:  XOR     #1,W0
0DD0:  BRA     Z,DE6
0DD2:  XOR     #6E,W0
0DD4:  BRA     Z,DEA
0DD6:  XOR     #8,W0
0DD8:  BRA     Z,DFC
0DDA:  XOR     #68,W0
0DDC:  BRA     Z,EBA
0DDE:  BRA     F0C
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0DE0:  MOV.B   #1,W0L
0DE2:  MOV.B   W0L,1228
....................          break; 
0DE4:  BRA     F0C
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0DE6:  BCLR.B  94.3
....................          break; 
0DE8:  BRA     F0C
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0DEA:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0DEC:  CLR     104
0DEE:  PUSH    85E
0DF0:  POP     102
0DF2:  MOV     #8000,W4
0DF4:  MOV     W4,104
....................          HandshakeFlag = 1;   
0DF6:  MOV.B   #1,W0L
0DF8:  MOV.B   W0L,1228
....................          break;  
0DFA:  BRA     F0C
....................                       
....................       case 'L': 
....................          DisableInterrupts(); 
0DFC:  CALL    DB6
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0E00:  MOV     #122E,W1
0E02:  MOV     #0,W2
0E04:  REPEAT  #7F
0E06:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0E08:  MOV     120A,W4
0E0A:  XOR     #40,W4
0E0C:  BRA     NZ,E12
0E0E:  CP0     120C
0E10:  BRA     Z,E86
....................          { 
....................             if (kbhit(SHARP)) 
0E12:  BTSS.B  232.0
0E14:  BRA     E84
0E16:  PUSH    42
0E18:  BCLR.B  81.7
0E1A:  SETM.B  42
0E1C:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0E1E:  CALL    244
0E22:  BCLR.B  81.7
0E24:  POP     42
0E26:  BSET.B  81.7
0E28:  MOV.B   W0L,12B9
....................                 
....................                if (CoefficentByte == 'L') 
0E2A:  MOV     12B8,W4
0E2C:  LSR     W4,#8,W4
0E2E:  XOR.B   #4C,W4L
0E30:  BRA     NZ,E34
....................                { 
....................                   ; // Do nothing 
....................                }               
0E32:  BRA     E84
....................                else if (NumberCSharpByteRecieved == 0) 
0E34:  CP0     121A
0E36:  BRA     NZ,E48
0E38:  CP0     121C
0E3A:  BRA     NZ,E48
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0E3C:  MOV.B   12B9,W0L
0E3E:  MOV.B   W0L,962
....................                   NumberCSharpByteRecieved = 1; 
0E40:  MOV     #1,W4
0E42:  MOV     W4,121A
0E44:  CLR     121C
....................                }            
0E46:  BRA     E84
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0E48:  MOV.B   12B9,W0L
0E4A:  MOV.B   W0L,963
....................                   NumberCSharpByteRecieved = 0; 
0E4C:  CLR     121A
0E4E:  CLR     121C
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0E50:  MOV.B   963,W0L
0E52:  MOV.B   W0L,W5L
0E54:  CLR.B   B
0E56:  MOV.B   W5L,W0L
0E58:  MOV.B   W0L,B
0E5A:  CLR.B   W5
0E5C:  MOV     W5,W0
0E5E:  IOR     962,W0
0E60:  MOV     W0,96C
....................                   fir_coef[CSharpCoefficentRecieved] =  ByteConversionResult; 
0E62:  MOV     #1,W4
0E64:  CLR.B   9
0E66:  MOV     120A,W0
0E68:  MOV     120C,W1
0E6A:  INC     W4,W4
0E6C:  DEC     W4,W4
0E6E:  BRA     Z,E76
0E70:  SL      W0,W0
0E72:  RLC     W1,W1
0E74:  BRA     E6C
0E76:  MOV     #122E,W4
0E78:  ADD     W0,W4,W5
0E7A:  MOV     96C,W4
0E7C:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0E7E:  INC     120A
0E80:  BTSC.B  42.1
0E82:  INC     120C
....................                } 
....................             } 
0E84:  BRA     E08
....................          } 
....................           
....................          switch (fir_coef[0]) 
0E86:  MOV     122E,W0
0E88:  XOR     #D2,W0
0E8A:  BRA     Z,E96
0E8C:  XOR     #FA,W0
0E8E:  BRA     Z,E9C
0E90:  XOR     #149,W0
0E92:  BRA     Z,EA2
0E94:  BRA     EA8
....................          { 
....................          case 210: //Todo:: Fall Through  
....................             TimerTicks = 53334; 
0E96:  MOV     #D056,W4
0E98:  MOV     W4,85E
....................             break; 
0E9A:  BRA     EAC
....................          case 40: 
....................             TimerTicks = 53334; 
0E9C:  MOV     #D056,W4
0E9E:  MOV     W4,85E
....................             break; 
0EA0:  BRA     EAC
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0EA2:  MOV     #1F40,W4
0EA4:  MOV     W4,85E
....................             break; 
0EA6:  BRA     EAC
....................          default:  
....................             TimerTicks = 8000; 
0EA8:  MOV     #1F40,W4
0EAA:  MOV     W4,85E
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0EAC:  CLR     120A
0EAE:  CLR     120C
....................          HandshakeFlag = 1; 
0EB0:  MOV.B   #1,W0L
0EB2:  MOV.B   W0L,1228
....................          EnableInterrupts(); 
0EB4:  CALL    772
....................          break; 
0EB8:  BRA     F0C
....................          
....................       case '$': 
....................          DisableInterrupts(); 
0EBA:  CALL    DB6
....................          TriggerValue = 0; // reset trigger value 
0EBE:  CLR     96A
....................           
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0EC0:  BTSS.B  232.0
0EC2:  BRA     F04
0EC4:  PUSH    42
0EC6:  BCLR.B  81.7
0EC8:  SETM.B  42
0ECA:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0ECC:  CALL    244
0ED0:  BCLR.B  81.7
0ED2:  POP     42
0ED4:  BSET.B  81.7
0ED6:  MOV.B   W0L,12BA
....................                 
....................                if (isdigit(DigitByte)) 
0ED8:  MOV     12BA,W4
0EDA:  MOV     #30,W3
0EDC:  CP.B    W3L,W4L
0EDE:  BRA     GTU,EFA
0EE0:  MOV     12BA,W4
0EE2:  MOV     #39,W3
0EE4:  CP.B    W3L,W4L
0EE6:  BRA     NC,EFA
....................                { 
....................                   TriggerValue = TriggerValue * 10 + CharToInt(DigitByte); 
0EE8:  MOV     96A,W4
0EEA:  MUL.UU  W4,#A,W0
0EEC:  MOV     W0,W5
0EEE:  MOV.B   12BA,W0L
0EF0:  SE      W0,W0
0EF2:  SUB     #30,W0
0EF4:  ADD     W0,W5,W0
0EF6:  MOV     W0,96A
....................                } 
0EF8:  BRA     F04
....................                else if (DigitByte == ')') 
0EFA:  MOV     12BA,W4
0EFC:  XOR.B   #29,W4L
0EFE:  BRA     NZ,F04
....................                { 
....................                   break; 
0F00:  BRA     F06
....................                } 
0F02:  BRA     F04
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0F04:  BRA     EC0
....................          } 
....................          EnableInterrupts(); 
0F06:  CALL    772
....................          break;  
0F0A:  BRA     F0C
....................           
.................... //!      case '%': 
.................... //!      disable_interrupts(INT_TIMER1); 
.................... //!      disable_interrupts(INT_RDA2); 
.................... //!      disable_interrupts(GLOBAL);  
.................... //!       
.................... //!      IndexType DataLength = CharToInt(fgetc(SHARP)); 
.................... //!      IndexType DataCounter = 0; 
.................... //!       
.................... //!      while(DataCounter != DataLength) 
.................... //!      { 
.................... //!         InboundTriggerValue[DataCounter] = CharToInt(fgetc(SHARP)); 
.................... //!         DataCounter++; 
.................... //!      } 
.................... //!      break; 
....................           
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0F0C:  CLR.B   12B8
....................    UARTRXFlag = 0; 
0F0E:  CLR.B   1227
0F10:  MOV     [--W15],W5
0F12:  RETURN  
.................... } 
....................  
.................... void DisableInterrupts(void) 
.................... { 
....................    disable_interrupts(INT_TIMER1); // disable timer 
*
0DB6:  BCLR.B  94.3
....................    disable_interrupts(INT_RDA2); 
0DB8:  BCLR.B  97.6
....................    disable_interrupts(GLOBAL);  
0DBA:  BCLR.B  81.7
0DBC:  MOV     #E0,W4
0DBE:  MOV     W4,42
0DC0:  BSET.B  81.7
0DC2:  RETURN  
.................... } 
....................  
.................... void EnableInterrupts(void) 
.................... { 
....................    enable_interrupts(INT_RDA2); 
*
0772:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
0774:  BSET.B  94.3
....................    enable_interrupts(GLOBAL); 
0776:  BCLR.B  81.7
0778:  CLR     42
077A:  BSET.B  81.7
077C:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
