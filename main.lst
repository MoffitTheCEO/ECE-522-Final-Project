CCS PCD C Compiler, Version 5.008, 5967               06-Dec-22 22:14

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4384 bytes (10%)
                           Largest free fragment is 39648
               RAM used:   2257 (14%) at main() level
                           2298 (14%) worst case
               Stack used: 76 locations (60 in main + 16 for interrupts)
               Stack size: 128

*
0000:  GOTO    F34
*
001A:  DATA    7C,02,00
001C:  DATA    00,02,00
*
0050:  DATA    52,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
034C:  MOV     W5,[W15++]
034E:  MOV     #C,W5
0350:  REPEAT  #3
0352:  MOV     [W5++],[W15++]
0354:  MUL.UU  W0,W2,W4
0356:  BTSS    W3.F
0358:  BRA     35E
035A:  MUL.SS  W0,W3,W6
035C:  BRA     360
035E:  MUL.UU  W0,W3,W6
0360:  BCLR.B  42.0
0362:  ADD     W6,W5,W5
0364:  ADDC    W7,#0,W8
0366:  BTSS    W1.F
0368:  BRA     36E
036A:  MUL.SS  W1,W2,W6
036C:  BRA     370
036E:  MUL.UU  W1,W2,W6
0370:  ADDC    W6,W5,W5
0372:  ADDC    W7,W8,W8
0374:  ADDC    #0,W9
0376:  MUL.SS  W1,W3,W6
0378:  ADDC    W6,W8,W8
037A:  ADDC    W9,W7,W7
037C:  MOV     W7,W3
037E:  MOV     W8,W2
0380:  MOV     W5,W1
0382:  MOV     W4,W0
0384:  MOV     #12,W5
0386:  REPEAT  #3
0388:  MOV     [--W15],[W5--]
038A:  MOV     [--W15],W5
038C:  RETURN  
038E:  MOV     W5,[W15++]
0390:  MOV     #C,W5
0392:  REPEAT  #3
0394:  MOV     [W5++],[W15++]
0396:  MOV     W0,W4
0398:  MOV     W1,W5
039A:  MOV     W2,W6
039C:  MOV     W3,W7
039E:  CLR     W0
03A0:  CLR     W1
03A2:  CLR     W2
03A4:  CLR     W3
03A6:  BCLR    W8.0
03A8:  BTSS    W7.F
03AA:  BRA     3B6
03AC:  BSET    W6.0
03AE:  NEG     W4,W4
03B0:  COM     W5,W5
03B2:  COM     W6,W6
03B4:  COM     W7,W7
03B6:  XOR     W4,W5,W9
03B8:  BRA     NZ,3BE
03BA:  XOR     W6,W7,W9
03BC:  BRA     Z,3E6
03BE:  MOV     #D6,W1
03C0:  BTSC    W2.7
03C2:  BRA     3D6
03C4:  BCLR.B  42.0
03C6:  RLC     W4,W4
03C8:  RLC     W5,W5
03CA:  RLC     W6,W6
03CC:  RLC     W7,W7
03CE:  RLC     W0,W0
03D0:  RLC     W2,W2
03D2:  DEC     W1,W1
03D4:  BRA     NZ,3C0
03D6:  SWAP    W1
03D8:  BCLR.B  42.0
03DA:  RRC     W1,W1
03DC:  BCLR    W1.F
03DE:  BCLR    W2.7
03E0:  XOR.B   W2L,W1L,W1L
03E2:  BTSC    W6.0
03E4:  BSET    W1.F
03E6:  MOV     #12,W5
03E8:  REPEAT  #3
03EA:  MOV     [--W15],[W5--]
03EC:  MOV     [--W15],W5
03EE:  RETURN  
03F0:  MOV     W5,[W15++]
03F2:  MOV     #C,W5
03F4:  REPEAT  #4
03F6:  MOV     [W5++],[W15++]
03F8:  MOV     W0,W4
03FA:  MOV     W1,W5
03FC:  MOV     W3,W7
03FE:  MOV     W2,W6
0400:  BCLR.B  42.0
0402:  BCLR.B  42.1
0404:  RLC     W1,W1
0406:  SWAP    W1
0408:  AND     #FF,W1
040A:  CP0     W1
040C:  BRA     Z,4A4
040E:  BCLR.B  42.0
0410:  BCLR.B  42.1
0412:  RLC     W3,W3
0414:  SWAP    W3
0416:  AND     #FF,W3
0418:  CP0     W3
041A:  BRA     Z,4A4
041C:  ZE      W0,W0
041E:  ADD.B   W3L,W1L,W0L
0420:  BRA     C,42A
0422:  SUB     #7F,W0
0424:  BRA     Z,4A4
0426:  BRA     NC,4A4
0428:  BRA     42E
042A:  ADD.B   #81,W0L
042C:  BRA     C,4A4
042E:  XOR     W5,W7,W10
0430:  BCLR.B  42.0
0432:  BCLR.B  42.1
0434:  AND     #FF,W5
0436:  BSET    W5.7
0438:  BCLR.B  42.0
043A:  AND     #FF,W7
043C:  BSET    W7.7
043E:  MUL.UU  W4,W6,W2
0440:  MUL.UU  W5,W6,W8
0442:  ADDC    W8,W3,W3
0444:  MOV     W9,W1
0446:  BTSC.B  42.0
0448:  INC     W1,W1
044A:  BCLR.B  42.0
044C:  MUL.UU  W7,W4,W8
044E:  ADDC    W8,W3,W3
0450:  ADDC    W9,W1,W1
0452:  MUL.UU  W5,W7,W8
0454:  ADDC    W8,W1,W1
0456:  INC     W0,W0
0458:  CP0     W1
045A:  BTSC.B  42.1
045C:  BRA     460
045E:  BRA     466
0460:  CP0     W3
0462:  BTSC.B  42.1
0464:  BRA     470
0466:  BTSC    W1.F
0468:  BRA     470
046A:  RLC     W3,W3
046C:  RLC     W1,W1
046E:  DEC     W0,W0
0470:  MOV     W1,W2
0472:  BCLR.B  42.0
0474:  BTSS    W3.7
0476:  BRA     48A
0478:  MOV     #FF00,W7
047A:  AND     W3,W7,W3
047C:  ADD     #100,W3
047E:  ADDC    W2,#0,W2
0480:  CP0     W2
0482:  BRA     NZ,48A
0484:  CP0     W3
0486:  BRA     NZ,48A
0488:  INC     W0,W0
048A:  SWAP    W0
048C:  BCLR.B  42.0
048E:  BCLR.B  42.1
0490:  RRC     W0,W1
0492:  BTSC    W10.F
0494:  BSET    W1.F
0496:  BCLR    W2.F
0498:  SWAP    W2
049A:  XOR.B   W2L,W1L,W1L
049C:  SWAP    W3
049E:  MOV.B   W3L,W2L
04A0:  MOV     W2,W0
04A2:  BRA     4AA
04A4:  MOV     #0,W0
04A6:  MOV     #0,W1
04A8:  BRA     4AA
04AA:  MOV     #14,W5
04AC:  REPEAT  #4
04AE:  MOV     [--W15],[W5--]
04B0:  MOV     [--W15],W5
04B2:  RETURN  
04B4:  MOV     W5,[W15++]
04B6:  MOV     #C,W5
04B8:  REPEAT  #3
04BA:  MOV     [W5++],[W15++]
04BC:  CLR     W9
04BE:  MOV     #8000,W8
04C0:  BTSC.B  43.0
04C2:  XOR     W8,W3,W3
04C4:  CP0     W0
04C6:  BRA     NZ,4CE
04C8:  MOV     #7FFF,W10
04CA:  AND     W1,W10,W10
04CC:  BTSS.B  42.1
04CE:  MOV     W1,W10
04D0:  XOR     W3,W10,W11
04D2:  MOV     W1,W6
04D4:  MOV     W3,W7
04D6:  MOV     W3,W12
04D8:  BCLR.B  42.1
04DA:  BCLR.B  42.0
04DC:  RLC     W6,W6
04DE:  SWAP    W6
04E0:  AND     #FF,W6
04E2:  CP0     W6
04E4:  BRA     Z,628
04E6:  BCLR.B  42.1
04E8:  BCLR.B  42.0
04EA:  RLC     W7,W7
04EC:  SWAP    W7
04EE:  AND     #FF,W7
04F0:  CP0     W7
04F2:  BRA     Z,632
04F4:  BCLR.B  42.1
04F6:  BCLR.B  42.0
04F8:  CP      W7,W6
04FA:  BRA     Z,634
04FC:  BRA     N,644
04FE:  BCLR    W9.0
0500:  BSET    W9.1
0502:  SUB     W7,W6,W8
0504:  MOV     W7,W6
0506:  AND     #FF,W1
0508:  BSET    W1.7
050A:  AND     #FF,W3
050C:  BSET    W3.7
050E:  MOV     #28,W7
0510:  CP      W7,W8
0512:  BRA     N,536
0514:  BCLR.B  42.1
0516:  BCLR.B  42.0
0518:  RRC     W1,W1
051A:  RRC     W0,W0
051C:  DEC     W8,W8
051E:  BRA     NZ,514
0520:  BRA     53C
0522:  MOV     #28,W7
0524:  CP      W7,W8
0526:  BRA     N,53A
0528:  BCLR.B  42.1
052A:  BCLR.B  42.0
052C:  RRC     W3,W3
052E:  RRC     W2,W2
0530:  DEC     W8,W8
0532:  BRA     NZ,528
0534:  BRA     554
0536:  MOV     W2,W0
0538:  MOV     W3,W1
053A:  BRA     5C2
053C:  BTSS    W11.F
053E:  BRA     562
0540:  BTSC    W9.4
0542:  MOV     W12,W11
0544:  NEG     W0,W0
0546:  BRA     Z,54C
0548:  COM.B   W1L,W1L
054A:  BRA     54E
054C:  NEG     W1,W1
054E:  BTSC    W9.4
0550:  BRA     5A8
0552:  BRA     562
0554:  BTSS    W11.F
0556:  BRA     562
0558:  NEG     W2,W2
055A:  BRA     Z,560
055C:  COM.B   W3L,W3L
055E:  BRA     562
0560:  NEG     W3,W3
0562:  AND     #FF,W5
0564:  BCLR.B  42.1
0566:  BCLR.B  42.0
0568:  ADD     W0,W2,W0
056A:  ADDC.B  W1L,W3L,W1L
056C:  BTSC.B  42.0
056E:  BSET    W9.3
0570:  BTSC    W9.0
0572:  BRA     586
0574:  BTSC    W9.1
0576:  BRA     57A
0578:  BRA     590
057A:  BTSC    W11.F
057C:  BRA     5A8
057E:  BTSC    W9.3
0580:  BRA     5D4
0582:  BSET    W9.6
0584:  BRA     5C2
0586:  BTSC    W11.F
0588:  BRA     5A8
058A:  BTSC    W9.3
058C:  BRA     5D4
058E:  BRA     5C2
0590:  BCLR    W9.2
0592:  BTSC    W11.F
0594:  BRA     59E
0596:  MOV     W10,W11
0598:  BTSC    W9.3
059A:  BRA     5D4
059C:  BRA     60A
059E:  BSET    W9.4
05A0:  XOR.B   #80,W1L
05A2:  BTSC    W1.7
05A4:  BRA     540
05A6:  MOV     W10,W11
05A8:  AND     #FF,W1
05AA:  IOR      W0,  W1,W7
05AC:  BRA     Z,5C2
05AE:  BTSC    W1.7
05B0:  BRA     5C2
05B2:  BCLR.B  42.1
05B4:  BCLR.B  42.0
05B6:  RLC     W0,W0
05B8:  RLC     W1,W1
05BA:  DEC     W6,W6
05BC:  BTSC.B  42.1
05BE:  BRA     622
05C0:  BRA     5AE
05C2:  BTSC    W9.0
05C4:  MOV     W10,W11
05C6:  BTSC    W9.1
05C8:  MOV     W12,W11
05CA:  BTSS    W9.5
05CC:  BRA     602
05CE:  BTSC    W10.F
05D0:  BSET    W0.8
05D2:  BRA     60A
05D4:  BSET.B  42.0
05D6:  RRC.B   W1L,W1L
05D8:  RRC     W0,W0
05DA:  BTSC.B  42.0
05DC:  BSET    W9.5
05DE:  INC     W6,W6
05E0:  BRA     Z,622
05E2:  BTSS    W9.5
05E4:  BRA     5F6
05E6:  INC     W0,W0
05E8:  BRA     NZ,5F6
05EA:  INC.B   W1L,W1L
05EC:  BRA     NZ,5F6
05EE:  RRC.B   W1L,W1L
05F0:  RRC     W0,W0
05F2:  INC     W6,W6
05F4:  BRA     Z,622
05F6:  BTSC    W9.0
05F8:  MOV     W10,W11
05FA:  BTSC    W9.1
05FC:  MOV     W12,W11
05FE:  BTSC.B  42.1
0600:  BRA     622
0602:  BTSC    W9.6
0604:  MOV     W10,W11
0606:  BTSC    W9.7
0608:  MOV     W12,W11
060A:  IOR      W0,  W1,W2
060C:  BRA     Z,654
060E:  BCLR    W1.7
0610:  SWAP    W6
0612:  BCLR.B  42.1
0614:  BCLR.B  42.0
0616:  RRC     W6,W6
0618:  XOR     W6,W1,W1
061A:  BSET    W1.F
061C:  BTSS    W11.F
061E:  BCLR    W1.F
0620:  BRA     654
0622:  MOV     #0,W0
0624:  MOV     #0,W1
0626:  BRA     654
0628:  BTSC    W10.F
062A:  XOR     W8,W3,W3
062C:  MOV     W2,W0
062E:  MOV     W3,W1
0630:  BRA     654
0632:  BRA     654
0634:  AND     #FF,W3
0636:  BSET    W3.7
0638:  AND     #FF,W1
063A:  BSET    W1.7
063C:  BTSC    W11.F
063E:  BCLR    W3.7
0640:  BSET    W9.2
0642:  BRA     554
0644:  SUB     W6,W7,W8
0646:  AND     #FF,W1
0648:  BSET    W1.7
064A:  AND     #FF,W3
064C:  BSET    W3.7
064E:  BCLR    W9.1
0650:  BSET    W9.0
0652:  BRA     522
0654:  MOV     #12,W5
0656:  REPEAT  #3
0658:  MOV     [--W15],[W5--]
065A:  MOV     [--W15],W5
065C:  RETURN  
065E:  MOV     W0,W2
0660:  MOV     W1,W3
0662:  MOV.B   W1L,W0L
0664:  SWAP    W0
0666:  BSET    W0.F
0668:  RLC     W1,W1
066A:  SWAP    W1
066C:  ZE      W1,W1
066E:  MOV     #8E,W4
0670:  SUB.B   W4L,W1L,W1L
0672:  BRA     Z,680
0674:  CP0     W0
0676:  BRA     Z,680
0678:  BCLR.B  42.0
067A:  RRC     W0,W0
067C:  DEC     W1,W1
067E:  BRA     NZ,674
0680:  BTSS    W3.F
0682:  BRA     688
0684:  NEG     W0,W0
0686:  BRA     688
0688:  RETURN  
*
0838:  MOV     W5,[W15++]
083A:  MOV     W6,[W15++]
083C:  MOV     W0,W4
083E:  MOV     W1,W5
0840:  CLR     W0
0842:  CLR     W1
0844:  BCLR    W6.0
0846:  BTSS    W5.F
0848:  BRA     856
084A:  BSET    W6.0
084C:  NEG     W4,W4
084E:  BRA     Z,854
0850:  COM     W5,W5
0852:  BRA     856
0854:  NEG     W5,W5
0856:  IOR      W4,  W5,W3
0858:  BRA     Z,880
085A:  CLR     W2
085C:  MOV     #B6,W1
085E:  BTSC    W2.7
0860:  BRA     870
0862:  BCLR.B  42.0
0864:  RLC     W4,W4
0866:  RLC     W5,W5
0868:  RLC     W0,W0
086A:  RLC     W2,W2
086C:  DEC     W1,W1
086E:  BRA     NZ,85E
0870:  SWAP    W1
0872:  BCLR.B  42.0
0874:  RRC     W1,W1
0876:  BCLR    W1.F
0878:  BCLR    W2.7
087A:  XOR.B   W2L,W1L,W1L
087C:  BTSC    W6.0
087E:  BSET    W1.F
0880:  MOV     [--W15],W6
0882:  MOV     [--W15],W5
0884:  RETURN  
0886:  MOV     W5,[W15++]
0888:  MOV     #C,W5
088A:  REPEAT  #4
088C:  MOV     [W5++],[W15++]
088E:  CLR     W9
0890:  XOR     W1,W3,W9
0892:  MOV     W1,W6
0894:  MOV     W0,W5
0896:  MOV     W3,W8
0898:  MOV     W2,W7
089A:  RLC     W1,W1
089C:  SWAP    W1
089E:  ZE      W1,W1
08A0:  CP0     W1
08A2:  BRA     Z,940
08A4:  RLC     W3,W3
08A6:  SWAP    W3
08A8:  ZE      W3,W3
08AA:  CP0     W3
08AC:  BRA     Z,940
08AE:  CLR     W0
08B0:  SUB.B   W1L,W3L,W0L
08B2:  BRA     NC,8BA
08B4:  ADD.B   #7F,W0L
08B6:  BRA     C,940
08B8:  BRA     8C0
08BA:  SUB.B   #81,W0L
08BC:  BRA     NC,940
08BE:  BRA     Z,940
08C0:  MOV     W5,W1
08C2:  MOV     W6,W2
08C4:  BSET    W2.7
08C6:  AND     #FF,W2
08C8:  AND     #FF,W8
08CA:  BSET    W8.7
08CC:  MOV     #19,W10
08CE:  CLR     W3
08D0:  CLR     W4
08D2:  SUB     W1,W7,W1
08D4:  SUBB    W2,W8,W2
08D6:  BRA     N,8DC
08D8:  BRA     C,8E2
08DA:  BRA     NZ,8E4
08DC:  ADD     W1,W7,W1
08DE:  ADDC    W2,W8,W2
08E0:  BRA     8E4
08E2:  BSET    W4.0
08E4:  DEC     W10,W10
08E6:  BRA     Z,8F6
08E8:  BCLR.B  42.0
08EA:  RLC     W1,W1
08EC:  RLC     W2,W2
08EE:  BCLR.B  42.0
08F0:  RLC     W4,W4
08F2:  RLC     W3,W3
08F4:  BRA     8D2
08F6:  CLR     W10
08F8:  BTSC    W3.8
08FA:  BRA     8FE
08FC:  BRA     90A
08FE:  BCLR.B  42.0
0900:  RRC     W3,W3
0902:  BCLR    W3.7
0904:  RRC     W4,W4
0906:  RLC     W10,W10
0908:  BRA     90E
090A:  DEC     W0,W0
090C:  BRA     Z,940
090E:  BTSC    W10.F
0910:  BRA     NC,91C
0912:  RLC     W1,W1
0914:  RLC     W2,W2
0916:  SUB     W1,W7,W1
0918:  SUBB    W2,W8,W2
091A:  BRA     NC,92E
091C:  INC     W4,W4
091E:  BRA     NZ,92E
0920:  INC     W3,W3
0922:  BRA     NZ,92E
0924:  INC     W0,W0
0926:  BRA     Z,940
0928:  BRA     92E
092A:  DEC     W0,W0
092C:  BRA     Z,940
092E:  SWAP    W0
0930:  RRC     W0,W1
0932:  BSET    W1.F
0934:  BTSS    W9.F
0936:  BCLR    W1.F
0938:  BCLR    W3.7
093A:  XOR.B   W3L,W1L,W1L
093C:  MOV     W4,W0
093E:  BRA     946
0940:  MOV     #0,W0
0942:  MOV     #0,W1
0944:  BRA     946
0946:  MOV     #14,W5
0948:  REPEAT  #4
094A:  MOV     [--W15],[W5--]
094C:  MOV     [--W15],W5
094E:  RETURN  
0950:  MOV     W8,[W15++]
0952:  MOV     #12,W8
0954:  REPEAT  #4
0956:  MOV     [W8++],[W15++]
0958:  MOV     #0,W9
095A:  BTSC.B  43.0
095C:  MOV     #1,W9
095E:  MOV     W9,[W15++]
0960:  CLR     W8
0962:  CLR     W9
0964:  CLR     W10
0966:  CLR     W11
0968:  CLR     W12
096A:  CLR     W13
096C:  MOV     #E,W8
096E:  MOV     #0,W9
0970:  LNK     #10
0972:  MOV     W12,[W14+W8]
0974:  DEC2    W8,W8
0976:  BRA     NN,972
0978:  XOR     W4,W5,W8
097A:  BRA     NZ,980
097C:  XOR     W6,W7,W8
097E:  BRA     Z,A10
0980:  CLR     W8
0982:  CLR     W13
0984:  MOV     W13,[W15++]
0986:  BTSS    W3.F
0988:  BRA     99E
098A:  MOV     [--W15],W13
098C:  BSET    W13.F
098E:  MOV     W13,[W15++]
0990:  COM     W3,W3
0992:  COM     W2,W2
0994:  COM     W1,W1
0996:  NEG     W0,W0
0998:  ADDC    W1,#0,W1
099A:  ADDC    W2,#0,W2
099C:  ADDC    W3,#0,W3
099E:  BTSS    W7.F
09A0:  BRA     9B6
09A2:  MOV     [--W15],W13
09A4:  BTG     W13.F
09A6:  MOV     W13,[W15++]
09A8:  COM     W7,W7
09AA:  COM     W6,W6
09AC:  COM     W5,W5
09AE:  NEG     W4,W4
09B0:  ADDC    W5,#0,W5
09B2:  ADDC    W6,#0,W6
09B4:  ADDC    W7,#0,W7
09B6:  MOV     #40,W13
09B8:  BCLR.B  42.0
09BA:  RLC     W0,W0
09BC:  RLC     W1,W1
09BE:  RLC     W2,W2
09C0:  RLC     W3,W3
09C2:  RLC     W8,W8
09C4:  RLC     W9,W9
09C6:  RLC     W10,W10
09C8:  RLC     W11,W11
09CA:  CP      W11,W7
09CC:  BRA     NZ,9D8
09CE:  CPB     W10,W6
09D0:  BRA     NZ,9D8
09D2:  CPB     W9,W5
09D4:  BRA     NZ,9D8
09D6:  CPB     W8,W4
09D8:  BRA     NC,9E4
09DA:  SUB     W8,W4,W8
09DC:  SUBB    W9,W5,W9
09DE:  SUBB    W10,W6,W10
09E0:  SUBB    W11,W7,W11
09E2:  BSET.B  42.0
09E4:  MOV     W8,[W14]
09E6:  MOV     W9,[W14+#2]
09E8:  MOV     W10,[W14+#4]
09EA:  MOV     W11,[W14+#6]
09EC:  MOV     [W14+#8],W8
09EE:  MOV     [W14+#A],W9
09F0:  MOV     [W14+#C],W10
09F2:  MOV     [W14+#E],W11
09F4:  RLC     W8,W8
09F6:  RLC     W9,W9
09F8:  RLC     W10,W10
09FA:  RLC     W11,W11
09FC:  MOV     W8,[W14+#8]
09FE:  MOV     W9,[W14+#A]
0A00:  MOV     W10,[W14+#C]
0A02:  MOV     W11,[W14+#E]
0A04:  MOV     [W14],W8
0A06:  MOV     [W14+#2],W9
0A08:  MOV     [W14+#4],W10
0A0A:  MOV     [W14+#6],W11
0A0C:  DEC     W13,W13
0A0E:  BRA     NZ,9B8
0A10:  MOV     [W14+#8],W0
0A12:  MOV     [W14+#A],W1
0A14:  MOV     [W14+#C],W2
0A16:  MOV     [W14+#E],W3
0A18:  MOV     [--W15],W13
0A1A:  BTSS    W13.F
0A1C:  BRA     A2C
0A1E:  COM     W3,W3
0A20:  COM     W2,W2
0A22:  COM     W1,W1
0A24:  NEG     W0,W0
0A26:  ADDC    W1,#0,W1
0A28:  ADDC    W2,#0,W2
0A2A:  ADDC    W3,#0,W3
0A2C:  ULNK    
0A2E:  BRA     A30
0A30:  MOV     [--W15],W9
0A32:  CP0     W9
0A34:  BRA     Z,A3E
0A36:  MOV     W8,W0
0A38:  MOV     W9,W1
0A3A:  MOV     W10,W2
0A3C:  MOV     W11,W3
0A3E:  MOV     #1A,W8
0A40:  REPEAT  #4
0A42:  MOV     [--W15],[W8--]
0A44:  MOV     [--W15],W8
0A46:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) // slow down clock to 32 MHz 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 // UART TX Pin 
.................... #pin_select U2RX=PIN_B7 // UART RX Pin 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) 
*
0230:  MOV     W5,[W15++]
0232:  MOV     #4B00,W5
0234:  REPEAT  #19E
0236:  NOP     
0238:  DEC     W5,W5
023A:  BRA     NZ,242
023C:  CLR     800
023E:  MOV     #0,W0
0240:  BRA     24E
0242:  BTSS.B  232.0
0244:  BRA     234
0246:  PUSH    232
0248:  POP     800
024A:  MOV     236,W0
024C:  BCLR.B  232.1
024E:  MOV     [--W15],W5
0250:  RETURN  
....................  
.................... #include <stdio.h> // include files  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> // include files  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 // buffer length is 255 
.................... #define COEF_LENGTH 64 // number of coefficents 
.................... #define ADC_MAX_DATA_VALUE 255 // max value of unsinged 8bit data  
.................... #define LED_PIN PIN_B14  // LED pin for toggling in timer handler 
....................  
.................... #define CharToInt(A) (int)(A - 0x30) 
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; // ADC DMA Channel is Channel 0  
....................  
.................... unsigned int16 TimerTicks = 0; // timer ticks of timer  
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
.................... unsigned int16 TempInputSamples[2]; // used for trigger value  
....................  
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; // dma done flag 
.................... FlagType NormalizeFlag = 0; // normalize flag  
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; // trigger flag  
.................... FlagType DMAFlag = 0; // dma flag 
.................... FlagType TriggerValueFlag = 0; // trigger value flag 
....................  
.................... void AccumulateAnalogData(IndexType); // filter data and store into array  
.................... void NormalizeData(); // normalize the input data 
.................... void CommHandler(char); // handle UART commuication 
.................... void DisableInterrupts(void); // disable interrupt  
.................... void EnableInterrupts(void); // enable interrupts  
....................  
.................... volatile signed int16 fir_coef[COEF_LENGTH]; //array to hold filter coeffiecents 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) // Slow down clock 
....................  
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; // Banked DMA buffer stored in memory 
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  // DMA Handler 
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    if ((TriggerFlag == 2) || (TriggerValueFlag == 0)) // when trigger value found of normlization flag is high  
020E:  MOV     DCA,W4
0210:  LSR     W4,#8,W4
0212:  CP.B    W4L,#2
0214:  BRA     Z,21A
0216:  CP0.B   DCD
0218:  BRA     NZ,21E
....................    { 
....................       DMADoneFlag = 1; // set DMA Done Flag  
021A:  MOV.B   #1,W0L
021C:  MOV.B   W0L,907
....................    } 
.................... } 
....................  
....................  
021E:  BCLR.B  84.4
0220:  MOV     #1A,W0
0222:  REPEAT  #C
0224:  MOV     [--W15],[W0--]
0226:  MOV     [--W15],W0
0228:  POP     32
022A:  POP     36
022C:  POP     42
022E:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() // UART Handler  
*
0252:  PUSH    42
0254:  PUSH    36
0256:  PUSH    32
0258:  MOV     W0,[W15++]
025A:  MOV     #2,W0
025C:  REPEAT  #C
025E:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); // read char from UART RX buffer 
0260:  CALL    230
0264:  MOV.B   W0L,807
....................    UARTRXFlag = 1; // set UART RX Flag 
0266:  MOV.B   #1,W0L
0268:  MOV.B   W0L,DC9
.................... } 
....................  
026A:  BCLR.B  87.6
026C:  MOV     #1A,W0
026E:  REPEAT  #C
0270:  MOV     [--W15],[W0--]
0272:  MOV     [--W15],W0
0274:  POP     32
0276:  POP     36
0278:  POP     42
027A:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() // Timer Handler  
027C:  PUSH    42
027E:  PUSH    36
0280:  PUSH    32
0282:  MOV     W0,[W15++]
0284:  MOV     #2,W0
0286:  REPEAT  #C
0288:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN); // Toggle LED 
028A:  BCLR.B  2C9.6
028C:  BTG.B   2CD.6
....................   
....................    if((NormalizeFlag == 1) || (TriggerValueFlag == 0)) // If nomalize flag high or inital trigger value find 
028E:  MOV     DC8,W4
0290:  CP.B    W4L,#1
0292:  BRA     Z,298
0294:  CP0.B   DCD
0296:  BRA     NZ,2A8
....................    { 
....................       read_adc(); // read ADC  
0298:  BCLR.B  320.0
029A:  BSET.B  320.1
029C:  BTSS.B  320.0
029E:  BRA     29C
....................       NormalizeDataCounter++; // increment data aquired counter  
02A0:  INC     0DC4
02A2:  BTSC.B  42.1
02A4:  INC     0DC6
....................    } 
02A6:  BRA     32E
....................    else 
....................    { 
....................       unsigned int16 ADCValue = 0; 
02A8:  CLR     E7A
....................        
....................       if (DMAFlag == 0) // If dma flag is reset  
02AA:  CP0.B   DCC
02AC:  BRA     NZ,2BC
....................       { 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); // clear DMA buffer 
02AE:  MOV     #4000,W1
02B0:  MOV     #0,W2
02B2:  REPEAT  #1FD
02B4:  CLR.B   [W1++]
....................          TriggerFlag = 0; // reset trigger flag 
02B6:  CLR.B   DCB
....................          DMAFlag = 1; // ser dma flag  
02B8:  MOV.B   #1,W0L
02BA:  MOV.B   W0L,DCC
....................       } 
....................        
....................       if (TriggerFlag != 2) // if trigger value has not been found  
02BC:  MOV     DCA,W4
02BE:  LSR     W4,#8,W4
02C0:  CP.B    W4L,#2
02C2:  BRA     Z,2E8
....................       { 
....................             
....................            if(DMAFlag != 2) // is dma has not been stated  
02C4:  MOV     DCC,W4
02C6:  CP.B    W4L,#2
02C8:  BRA     Z,2DA
....................            { 
....................               dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); // start dma  
02CA:  BCLR.B  381.7
02CC:  CLR.B   380
02CE:  MOV     #4000,W4
02D0:  MOV     W4,384
02D2:  MOV     #FF,W4
02D4:  MOV     W4,38A
02D6:  BSET.B  381.7
....................               enable_interrupts(INT_DMA0); // enable DMA interrupts 
02D8:  BSET.B  94.4
....................            } 
....................    
....................            ADCValue = read_adc() >> 4; // read ADC and shift data to be 8 bits  
02DA:  BCLR.B  320.0
02DC:  BSET.B  320.1
02DE:  BTSS.B  320.0
02E0:  BRA     2DE
02E2:  MOV     300,W5
02E4:  LSR     W5,#4,W0
02E6:  MOV     W0,E7A
....................       } 
....................        
....................       if((ADCValue == TriggerValue) && (TriggerFlag == 0)) // If trigger value is found  
02E8:  MOV     E7A,W0
02EA:  CP      90C
02EC:  BRA     NZ,300
02EE:  CP0.B   DCB
02F0:  BRA     NZ,300
....................       { 
....................          TempInputSamples[0] = ADCValue; // store ADC Value into temp array 
02F2:  PUSH    E7A
02F4:  POP     DA0
....................          DMAFlag = 2; // signal syste m that DMA IS started 
02F6:  MOV.B   #2,W0L
02F8:  MOV.B   W0L,DCC
....................          TriggerFlag = 1; // move onto next step of trigger value detections 
02FA:  MOV.B   #1,W0L
02FC:  MOV.B   W0L,DCB
....................       } 
02FE:  BRA     32E
....................       else if((ADCValue > TempInputSamples[0]) && (TriggerFlag == 1)) // if ADC Value is greater then trigger value 
0300:  MOV     DA0,W0
0302:  MOV     E7A,W4
0304:  CP      W4,W0
0306:  BRA     LEU,31A
0308:  MOV     DCA,W4
030A:  LSR     W4,#8,W4
030C:  CP.B    W4L,#1
030E:  BRA     NZ,31A
....................       { 
....................          TempInputSamples[1] = ADCValue; // store ADC Value into temp array 
0310:  PUSH    E7A
0312:  POP     DA2
....................          TriggerFlag = 2; // signal system that trigger value has been found  
0314:  MOV.B   #2,W0L
0316:  MOV.B   W0L,DCB
....................       } 
0318:  BRA     32E
....................       else if(TriggerFlag == 2) // if trigger value has been found  
031A:  MOV     DCA,W4
031C:  LSR     W4,#8,W4
031E:  CP.B    W4L,#2
0320:  BRA     NZ,32C
....................       {     
....................          read_adc(); // run ADC DMA conversion until DMA buffer is full 
0322:  BCLR.B  320.0
0324:  BSET.B  320.1
0326:  BTSS.B  320.0
0328:  BRA     326
....................       }   
032A:  BRA     32E
....................       else 
....................       { 
....................          DMAFlag = 0; // If no trigger value found reset and start over       
032C:  CLR.B   DCC
....................       } 
....................    } 
032E:  BCLR.B  84.3
0330:  MOV     #1A,W0
0332:  REPEAT  #C
0334:  MOV     [--W15],[W0--]
0336:  MOV     [--W15],W0
0338:  POP     32
033A:  POP     36
033C:  POP     42
033E:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0F34:  MOV     #4444,W0
0F36:  MOV     W0,A4
0F38:  BSET.B  81.7
0F3A:  MOV     #46,W0
0F3C:  MOV.B   W0L,742
0F3E:  MOV     #57,W0
0F40:  MOV.B   W0L,742
0F42:  BCLR.B  742.6
0F44:  MOV     #3F07,W0
0F46:  MOV     W0,6A6
0F48:  MOV     #5,W0
0F4A:  MOV     W0,6C6
0F4C:  MOV     #46,W0
0F4E:  MOV.B   W0L,742
0F50:  MOV     #57,W0
0F52:  MOV.B   W0L,742
0F54:  BSET.B  742.6
0F56:  MOV     #41,W4
0F58:  MOV     W4,744
0F5A:  MOV     #32,W4
0F5C:  MOV     W4,746
0F5E:  CLR     800
0F60:  MOV     #8000,W4
0F62:  MOV     W4,230
0F64:  MOV     #400,W4
0F66:  MOV     W4,232
0F68:  BSET.B  230.3
0F6A:  MOV     #22,W4
0F6C:  MOV     W4,238
0F6E:  CLR     804
0F70:  CLR     90A
0F72:  CLR     90C
0F74:  CLR     90E
0F76:  CLR     910
0F78:  CLR     912
0F7A:  CLR     D10
0F7C:  CLR     D12
0F7E:  CLR     D14
0F80:  CLR     D16
0F82:  CLR     D18
0F84:  CLR     D1A
0F86:  CLR     D1C
0F88:  CLR     D1E
0F8A:  CLR     DA4
0F8C:  CLR     DA6
0F8E:  CLR     DA8
0F90:  CLR     DAA
0F92:  CLR.B   807
0F94:  CLR     DAC
0F96:  CLR     DAE
0F98:  CLR     DB0
0F9A:  CLR     DB2
0F9C:  CLR     DB4
0F9E:  CLR     DB6
0FA0:  CLR     DB8
0FA2:  CLR     DBA
0FA4:  CLR     DBC
0FA6:  CLR     DBE
0FA8:  CLR     DC0
0FAA:  CLR     DC2
0FAC:  CLR     DC4
0FAE:  CLR     DC6
0FB0:  CLR.B   907
0FB2:  CLR.B   DC8
0FB4:  CLR.B   DC9
0FB6:  CLR.B   DCA
0FB8:  CLR.B   DCB
0FBA:  CLR.B   DCC
0FBC:  CLR.B   DCD
0FBE:  MOV     #41,W4
0FC0:  MOV     W4,744
0FC2:  MOV     #32,W4
0FC4:  MOV     W4,746
0FC6:  DISI    #E
0FC8:  MOV     #101,W0
0FCA:  MOV     #743,W1
0FCC:  MOV     #78,W2
0FCE:  MOV     #9A,W3
0FD0:  MOV.B   W2L,[W1]
0FD2:  MOV.B   W3L,[W1]
0FD4:  MOV.B   W0L,743
0FD6:  LSR     W0,#8,W0
0FD8:  MOV     #742,W1
0FDA:  MOV     #46,W2
0FDC:  MOV     #57,W3
0FDE:  MOV.B   W2L,[W1]
0FE0:  MOV.B   W3L,[W1]
0FE2:  MOV.B   W0L,[W1]
0FE4:  SETM    32C
0FE6:  MOV     #3F80,W15
0FE8:  MOV     #3FFF,W0
0FEA:  MOV     W0,20
0FEC:  NOP     
0FEE:  CLR     802
0FF0:  MOV     #3F80,W15
0FF2:  MOV     #3FFF,W0
0FF4:  MOV     W0,20
0FF6:  NOP     
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); // clear DMA buffer  
0FF8:  MOV     #4000,W1
0FFA:  MOV     #0,W2
0FFC:  REPEAT  #FE
0FFE:  CLR.B   [W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); // set up DMA  
1000:  CLR.B   381
1002:  MOV.B   #D,W0L
1004:  MOV.B   W0L,382
1006:  MOV     #300,W4
1008:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); // Start DMA  
100A:  BCLR.B  381.7
100C:  CLR.B   380
100E:  MOV     #4000,W4
1010:  MOV     W4,384
1012:  MOV     #FF,W4
1014:  MOV     W4,38A
1016:  BSET.B  381.7
....................     
....................    enable_interrupts(INT_DMA0); // Enable DMA interrupt 
1018:  BSET.B  94.4
....................     
....................    setup_adc(ADC_CLOCK_INTERNAL); // set adc clock internal  
101A:  MOV     #9F00,W4
101C:  MOV     W4,324
101E:  MOV     #84E0,W4
1020:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); // set adc port and refernce voltage 
1022:  MOV     #FFFE,W4
1024:  MOV     W4,32C
1026:  CLR     322
....................    read_adc(); // read ADC to kickstart DMA tranfer 
1028:  BCLR.B  320.0
102A:  BSET.B  320.1
102C:  BTSS.B  320.0
102E:  BRA     102C
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); // set up timer clock and timer ticks 
1030:  CLR     104
1032:  PUSH    804
1034:  POP     102
1036:  MOV     #8000,W4
1038:  MOV     W4,104
....................    EnableInterrupts(); // enable interrupts  
103A:  CALL    340
....................     
....................    NormalizeFlag = 1; // System needs to normalize data  
103E:  MOV.B   #1,W0L
1040:  MOV.B   W0L,DC8
....................  
....................    while(TRUE) // loop runs forever  
....................    { 
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) // if DMA buffer full or Normlization data is acquired 
1042:  CP0.B   907
1044:  BRA     NZ,1050
1046:  MOV     DC4,W4
1048:  XOR     #FF,W4
104A:  BRA     NZ,1110
104C:  CP0     DC6
104E:  BRA     NZ,1110
....................       { 
....................          disable_interrupts(INT_DMA0); // disable DMA interrupt 
1050:  BCLR.B  94.4
....................  
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
1052:  CLR     E4E
1054:  CLR     E50
1056:  MOV     E50,W4
1058:  CP      W4,#0
105A:  BRA     GTU,107A
105C:  BRA     NC,1066
105E:  MOV     E4E,W4
1060:  MOV     #FF,W3
1062:  CP      W3,W4
1064:  BRA     LEU,107A
....................          { 
....................             AccumulateAnalogData(Index); // Filter data and store into array  
1066:  PUSH    E4E
1068:  POP     E58
106A:  PUSH    E50
106C:  POP     E5A
106E:  CALL    68A
1072:  INC     0E4E
1074:  BTSC.B  42.1
1076:  INC     0E50
1078:  BRA     1056
....................          } 
....................           
....................          if (NormalizeFlag == 1) // if normalizaon data is present 
107A:  MOV     DC8,W4
107C:  CP.B    W4L,#1
107E:  BRA     NZ,1084
....................          { 
....................             NormalizeData(); // normalize data 
1080:  CALL    A48
....................          } 
....................              
....................          if (HandShakeFlag == 1) // if C# GUI is ready for more data  
1084:  MOV     DCA,W4
1086:  CP.B    W4L,#1
1088:  BRA     NZ,10FC
....................          {           
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
108A:  CLR     E52
108C:  CLR     E54
108E:  MOV     E54,W4
1090:  CP      W4,#0
1092:  BRA     GTU,10B8
1094:  BRA     NC,109E
1096:  MOV     E52,W4
1098:  MOV     #FF,W3
109A:  CP      W3,W4
109C:  BRA     LEU,10B8
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
109E:  MOV     #808,W4
10A0:  MOV     E52,W3
10A2:  ADD     W3,W4,W0
10A4:  MOV.B   [W0],W5L
10A6:  BTSC.B  233.1
10A8:  BRA     10A6
10AA:  PUSH    234
10AC:  MOV.B   W5L,[W15-#2]
10AE:  POP     234
10B0:  INC     0E52
10B2:  BTSC.B  42.1
10B4:  INC     0E54
10B6:  BRA     108E
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
10B8:  CLR     E52
10BA:  CLR     E54
10BC:  MOV     E54,W4
10BE:  CP      W4,#0
10C0:  BRA     GTU,10FC
10C2:  BRA     NC,10CC
10C4:  MOV     E52,W4
10C6:  MOV     #FF,W3
10C8:  CP      W3,W4
10CA:  BRA     LEU,10FC
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
10CC:  MOV     #2,W4
10CE:  CLR.B   9
10D0:  MOV     E52,W0
10D2:  MOV     E54,W1
10D4:  INC     W4,W4
10D6:  DEC     W4,W4
10D8:  BRA     Z,10E0
10DA:  SL      W0,W0
10DC:  RLC     W1,W1
10DE:  BRA     10D6
10E0:  MOV     #914,W4
10E2:  ADD     W0,W4,W0
10E4:  MOV     #A,W4
10E6:  MOV     [W0++],[W4++]
10E8:  MOV     [W0++],[W4++]
10EA:  BTSC.B  233.1
10EC:  BRA     10EA
10EE:  PUSH    234
10F0:  MOV.B   W5L,[W15-#2]
10F2:  POP     234
10F4:  INC     0E52
10F6:  BTSC.B  42.1
10F8:  INC     0E54
10FA:  BRA     10BC
....................             } 
....................          } 
....................          //reset flags and enable DMA interrupt 
....................          NormalizeFlag = 0; 
10FC:  CLR.B   DC8
....................          NormalizeDataCounter = 0; 
10FE:  CLR     DC4
1100:  CLR     DC6
....................          HandShakeFlag = 0;    
1102:  CLR.B   DCA
....................          CurrentIndex = 0; 
1104:  CLR     DB8
1106:  CLR     DBA
....................          enable_interrupts(INT_DMA0); 
1108:  BSET.B  94.4
....................          DMADoneFlag = 0; 
110A:  CLR.B   907
....................          TriggerFlag = 0; 
110C:  CLR.B   DCB
....................          DMAFlag = 0; 
110E:  CLR.B   DCC
....................       }   
....................        
....................       if (UARTRXFlag) // if UART data is recieved 
1110:  CP0.B   DC9
1112:  BRA     Z,111C
....................       { 
....................          CommHandler(UARTRX); // Comm Handler will deal with UART RX data  
1114:  MOV.B   807,W0L
1116:  MOV.B   W0L,E58
1118:  CALL    C7A
....................       }   
111C:  BRA     1042
....................    } 
.................... } 
....................  
111E:  PWRSAV  #0
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
068A:  MOV     W5,[W15++]
068C:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; // fill input samples array with current DMA buffer data  
068E:  MOV     #1,W4
0690:  CLR.B   9
0692:  MOV     DB8,W0
0694:  MOV     DBA,W1
0696:  INC     W4,W4
0698:  DEC     W4,W4
069A:  BRA     Z,6A2
069C:  SL      W0,W0
069E:  RLC     W1,W1
06A0:  BRA     698
06A2:  MOV     #D20,W4
06A4:  ADD     W0,W4,W5
06A6:  MOV     #1,W4
06A8:  CLR.B   9
06AA:  MOV     E58,W0
06AC:  MOV     E5A,W1
06AE:  INC     W4,W4
06B0:  DEC     W4,W4
06B2:  BRA     Z,6BA
06B4:  SL      W0,W0
06B6:  RLC     W1,W1
06B8:  BRA     6B0
06BA:  MOV     #4000,W4
06BC:  ADD     W0,W4,W0
06BE:  MOV     [W0],[W5]
....................    //Filter provided by Dr. Zheng  
....................    InputIndex = CurrentIndex;  
06C0:  PUSH    DB8
06C2:  POP     DB4
06C4:  PUSH    DBA
06C6:  POP     DB6
....................    Accumulator = 0; 
06C8:  CLR     910
06CA:  CLR     912
....................    CoefficentIndex = 0; 
06CC:  CLR     DB0
06CE:  CLR     DB2
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
06D0:  MOV     DB2,W4
06D2:  CP      W4,#0
06D4:  BRA     GTU,758
06D6:  BRA     NC,6E0
06D8:  MOV     DB0,W4
06DA:  MOV     #3F,W3
06DC:  CP      W3,W4
06DE:  BRA     LEU,758
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
06E0:  MOV     #1,W4
06E2:  CLR.B   9
06E4:  MOV     DB4,W0
06E6:  MOV     DB6,W1
06E8:  INC     W4,W4
06EA:  DEC     W4,W4
06EC:  BRA     Z,6F4
06EE:  SL      W0,W0
06F0:  RLC     W1,W1
06F2:  BRA     6EA
06F4:  MOV     #D20,W4
06F6:  ADD     W0,W4,W0
06F8:  MOV     W0,W4
06FA:  MOV     [W4],W0
06FC:  MOV     W0,W5
06FE:  CLR     W6
0700:  BTSC    W5.F
0702:  SETM    W6
0704:  MOV     #1,W4
0706:  CLR.B   9
0708:  MOV     DB0,W0
070A:  MOV     DB2,W1
070C:  INC     W4,W4
070E:  DEC     W4,W4
0710:  BRA     Z,718
0712:  SL      W0,W0
0714:  RLC     W1,W1
0716:  BRA     70E
0718:  MOV     #DCE,W4
071A:  ADD     W0,W4,W0
071C:  MOV     W0,W4
071E:  MOV     [W4],W0
0720:  CLR     W1
0722:  BTSC    W0.F
0724:  SETM    W1
0726:  MOV     W0,W2
0728:  MOV     W1,W3
072A:  MOV     W5,W0
072C:  MOV     W6,W1
072E:  CALL    34C
0732:  ADD     910
0734:  MOV     W1,W0
0736:  ADDC    912,W0
0738:  MOV     W0,912
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
073A:  MOV     DB4,W4
073C:  XOR     #3F,W4
073E:  BRA     NZ,74A
0740:  CP0     DB6
0742:  BRA     NZ,74A
....................       { 
....................          InputIndex = 0; 
0744:  CLR     DB4
0746:  CLR     DB6
....................       } 
0748:  BRA     750
....................       else 
....................       { 
....................          InputIndex++; 
074A:  INC     0DB4
074C:  BTSC.B  42.1
074E:  INC     0DB6
....................       } 
....................        
....................       CoefficentIndex++; 
0750:  INC     0DB0
0752:  BTSC.B  42.1
0754:  INC     0DB2
0756:  BRA     6D0
....................    } 
....................    //Filter provided by Dr. Zheng   
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; // store 12 bit input data into 8 bit array by shifting by 4  
0758:  MOV     #808,W4
075A:  MOV     E58,W3
075C:  ADD     W3,W4,W5
075E:  MOV     #1,W4
0760:  CLR.B   9
0762:  MOV     DB8,W0
0764:  MOV     DBA,W1
0766:  INC     W4,W4
0768:  DEC     W4,W4
076A:  BRA     Z,772
076C:  SL      W0,W0
076E:  RLC     W1,W1
0770:  BRA     768
0772:  MOV     #D20,W4
0774:  ADD     W0,W4,W0
0776:  MOV     [W0],W6
0778:  LSR     W6,#4,W0
077A:  MOV.B   W0L,[W5]
077C:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) // if normalizing data  
077E:  MOV     DC8,W4
0780:  CP.B    W4L,#1
0782:  BRA     NZ,7A4
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; // store accumulator data into output array 
0784:  MOV     #2,W4
0786:  CLR.B   9
0788:  MOV     E58,W0
078A:  MOV     E5A,W1
078C:  INC     W4,W4
078E:  DEC     W4,W4
0790:  BRA     Z,798
0792:  SL      W0,W0
0794:  RLC     W1,W1
0796:  BRA     78E
0798:  MOV     #914,W4
079A:  ADD     W0,W4,W5
079C:  MOV     #910,W4
079E:  MOV     [W4++],[W5++]
07A0:  MOV     [W4++],[W5++]
....................    } 
07A2:  BRA     81C
....................    else 
....................    { 
....................       // Math to go get 8bit digitzed output data  
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
07A4:  MOV     910,W0
07A6:  MOV     912,W1
07A8:  CLR     W3
07AA:  BTSC    W1.F
07AC:  SETM    W3
07AE:  MOV     W3,W2
07B0:  MOV     D18,W4
07B2:  SUB     W0,W4,W0
07B4:  MOV     D1A,W4
07B6:  SUBB    W1,W4,W1
07B8:  MOV     D1C,W4
07BA:  SUBB    W2,W4,W2
07BC:  MOV     D1E,W4
07BE:  SUBB    W3,W4,W3
07C0:  CALL    38E
07C4:  MOV     W0,E5C
07C6:  MOV     W1,E5E
07C8:  MOV     E5C,W0
07CA:  MOV     E5E,W1
07CC:  MOV     DA8,W2
07CE:  MOV     DAA,W3
07D0:  CALL    3F0
07D4:  MOV     W0,E60
07D6:  MOV     W1,E62
07D8:  BCLR.B  43.0
07DA:  MOV     E60,W0
07DC:  MOV     E62,W1
07DE:  MOV     #0,W2
07E0:  MOV     #42FE,W3
07E2:  CALL    4B4
07E6:  MOV     W0,E64
07E8:  MOV     W1,E66
....................       ConversionValue = (unsigned int8)StepThree; 
07EA:  MOV     E64,W0
07EC:  MOV     E66,W1
07EE:  CALL    65E
07F2:  MOV.B   W0L,806
....................       DigitizedData[DMAADCIndex] = ConversionValue; // store output data into output array 
07F4:  MOV     #2,W4
07F6:  CLR.B   9
07F8:  MOV     E58,W0
07FA:  MOV     E5A,W1
07FC:  INC     W4,W4
07FE:  DEC     W4,W4
0800:  BRA     Z,808
0802:  SL      W0,W0
0804:  RLC     W1,W1
0806:  BRA     7FE
0808:  MOV     #914,W4
080A:  ADD     W0,W4,W5
080C:  MOV     806,W0
080E:  MOV.B   W0L,[W5+#0]
0810:  MOV.B   #0,W0L
0812:  MOV.B   W0L,[W5+#1]
0814:  MOV.B   #0,W0L
0816:  MOV.B   W0L,[W5+#2]
0818:  MOV.B   #0,W0L
081A:  MOV.B   W0L,[W5+#3]
....................    } 
....................    //Filter provided by Dr. Zheng  
....................    if (CurrentIndex == 0) 
081C:  CP0     DB8
081E:  BRA     NZ,82C
0820:  CP0     DBA
0822:  BRA     NZ,82C
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
0824:  MOV     #3F,W4
0826:  MOV     W4,DB8
0828:  CLR     DBA
....................    } 
082A:  BRA     832
....................    else 
....................    { 
....................      CurrentIndex--; 
082C:  DEC     0DB8
082E:  BTSS.B  42.0
0830:  DEC     0DBA
....................    }  
0832:  MOV     [--W15],W6
0834:  MOV     [--W15],W5
0836:  RETURN  
....................    //Filter provided by Dr. Zheng  
.................... } 
....................  
.................... void NormalizeData(void) 
*
0A48:  MOV     W5,[W15++]
0A4A:  MOV     W6,[W15++]
0A4C:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0A4E:  MOV     DC2,W4
0A50:  CP      W4,#0
0A52:  BRA     GTU,BF2
0A54:  BRA     NC,A5E
0A56:  MOV     DC0,W4
0A58:  MOV     #BB8,W3
0A5A:  CP      W3,W4
0A5C:  BRA     LEU,BF2
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A5E:  PUSH    A14
0A60:  POP     D10
0A62:  PUSH    A16
0A64:  POP     D12
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A66:  PUSH    A14
0A68:  POP     D14
0A6A:  PUSH    A16
0A6C:  POP     D16
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0A6E:  PUSH    4080
0A70:  POP     90A
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A72:  MOV     #41,W4
0A74:  MOV     W4,E58
0A76:  CLR     E5A
0A78:  MOV     E5A,W4
0A7A:  CP      W4,#0
0A7C:  BRA     GTU,BA2
0A7E:  BRA     NC,A88
0A80:  MOV     E58,W4
0A82:  MOV     #FF,W3
0A84:  CP      W3,W4
0A86:  BRA     LEU,BA2
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0A88:  MOV     #2,W4
0A8A:  CLR.B   9
0A8C:  MOV     E58,W0
0A8E:  MOV     E5A,W1
0A90:  INC     W4,W4
0A92:  DEC     W4,W4
0A94:  BRA     Z,A9C
0A96:  SL      W0,W0
0A98:  RLC     W1,W1
0A9A:  BRA     A92
0A9C:  MOV     #914,W4
0A9E:  ADD     W0,W4,W0
0AA0:  MOV     W0,W4
0AA2:  MOV     #0,W3
0AA4:  MOV     [W4++],[W3++]
0AA6:  MOV     [W4++],[W3++]
0AA8:  MOV     D16,W4
0AAA:  CP      W4,W1
0AAC:  BRA     LT,AD4
0AAE:  BRA     GT,AB6
0AB0:  MOV     D14,W4
0AB2:  CP      W4,W0
0AB4:  BRA     LEU,AD4
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0AB6:  MOV     #2,W4
0AB8:  CLR.B   9
0ABA:  MOV     E58,W0
0ABC:  MOV     E5A,W1
0ABE:  INC     W4,W4
0AC0:  DEC     W4,W4
0AC2:  BRA     Z,ACA
0AC4:  SL      W0,W0
0AC6:  RLC     W1,W1
0AC8:  BRA     AC0
0ACA:  MOV     #914,W4
0ACC:  ADD     W0,W4,W0
0ACE:  MOV     #D14,W4
0AD0:  MOV     [W0++],[W4++]
0AD2:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0AD4:  MOV     #2,W4
0AD6:  CLR.B   9
0AD8:  MOV     E58,W0
0ADA:  MOV     E5A,W1
0ADC:  INC     W4,W4
0ADE:  DEC     W4,W4
0AE0:  BRA     Z,AE8
0AE2:  SL      W0,W0
0AE4:  RLC     W1,W1
0AE6:  BRA     ADE
0AE8:  MOV     #914,W4
0AEA:  ADD     W0,W4,W0
0AEC:  MOV     W0,W4
0AEE:  MOV     #0,W3
0AF0:  MOV     [W4++],[W3++]
0AF2:  MOV     [W4++],[W3++]
0AF4:  MOV     D12,W4
0AF6:  CP      W4,W1
0AF8:  BRA     GT,B20
0AFA:  BRA     LT,B02
0AFC:  MOV     D10,W4
0AFE:  CP      W4,W0
0B00:  BRA     C,B20
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0B02:  MOV     #2,W4
0B04:  CLR.B   9
0B06:  MOV     E58,W0
0B08:  MOV     E5A,W1
0B0A:  INC     W4,W4
0B0C:  DEC     W4,W4
0B0E:  BRA     Z,B16
0B10:  SL      W0,W0
0B12:  RLC     W1,W1
0B14:  BRA     B0C
0B16:  MOV     #914,W4
0B18:  ADD     W0,W4,W0
0B1A:  MOV     #D10,W4
0B1C:  MOV     [W0++],[W4++]
0B1E:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0B20:  MOV     #1,W4
0B22:  CLR.B   9
0B24:  MOV     E58,W0
0B26:  MOV     E5A,W1
0B28:  INC     W4,W4
0B2A:  DEC     W4,W4
0B2C:  BRA     Z,B34
0B2E:  SL      W0,W0
0B30:  RLC     W1,W1
0B32:  BRA     B2A
0B34:  MOV     #4000,W4
0B36:  ADD     W0,W4,W0
0B38:  MOV     W0,W4
0B3A:  MOV     [W4],W0
0B3C:  MOV     90A,W4
0B3E:  CP      W4,W0
0B40:  BRA     LEU,B5E
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0B42:  MOV     #1,W4
0B44:  CLR.B   9
0B46:  MOV     E58,W0
0B48:  MOV     E5A,W1
0B4A:  INC     W4,W4
0B4C:  DEC     W4,W4
0B4E:  BRA     Z,B56
0B50:  SL      W0,W0
0B52:  RLC     W1,W1
0B54:  BRA     B4C
0B56:  MOV     #4000,W4
0B58:  ADD     W0,W4,W0
0B5A:  MOV     [W0],[W15++]
0B5C:  POP     90A
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0B5E:  MOV     #2,W4
0B60:  CLR.B   9
0B62:  MOV     E58,W0
0B64:  MOV     E5A,W1
0B66:  INC     W4,W4
0B68:  DEC     W4,W4
0B6A:  BRA     Z,B72
0B6C:  SL      W0,W0
0B6E:  RLC     W1,W1
0B70:  BRA     B68
0B72:  MOV     #914,W4
0B74:  ADD     W0,W4,W0
0B76:  MOV     W0,W4
0B78:  MOV     #0,W3
0B7A:  MOV     [W4++],[W3++]
0B7C:  MOV     [W4++],[W3++]
0B7E:  CLR     W3
0B80:  BTSC    W1.F
0B82:  SETM    W3
0B84:  MOV     W3,W2
0B86:  ADD     D18
0B88:  MOV     W1,W0
0B8A:  ADDC    D1A,W0
0B8C:  MOV     W0,D1A
0B8E:  MOV     D1C,W4
0B90:  ADDC    W2,W4,W0
0B92:  MOV     W0,D1C
0B94:  MOV     D1E,W4
0B96:  ADDC    W3,W4,W0
0B98:  MOV     W0,D1E
0B9A:  INC     0E58
0B9C:  BTSC.B  42.1
0B9E:  INC     0E5A
0BA0:  BRA     A78
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0BA2:  MOV     D10,W4
0BA4:  MOV     D14,W3
0BA6:  SUB     W4,W3,W0
0BA8:  MOV     D12,W4
0BAA:  MOV     D16,W3
0BAC:  SUBB    W4,W3,W1
0BAE:  CALL    838
0BB2:  MOV     W0,DA4
0BB4:  MOV     W1,DA6
....................       AverageMultiplier = (255.0/ AverageDivider); 
0BB6:  MOV     #0,W0
0BB8:  MOV     #437F,W1
0BBA:  MOV     DA4,W2
0BBC:  MOV     DA6,W3
0BBE:  CALL    886
0BC2:  MOV     W0,DA8
0BC4:  MOV     W1,DAA
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0BC6:  BCLR.B  43.0
0BC8:  MOV     D18,W0
0BCA:  MOV     D1A,W1
0BCC:  MOV     D1C,W2
0BCE:  MOV     D1E,W3
0BD0:  MOV     #BF,W4
0BD2:  MOV     #0,W5
0BD4:  MOV     #0,W6
0BD6:  MOV     #0,W7
0BD8:  CALL    950
0BDC:  MOV     W0,D18
0BDE:  MOV     W1,D1A
0BE0:  MOV     W2,D1C
0BE2:  MOV     W3,D1E
....................        
....................       TriggerValue = InitialTriggerValue; 
0BE4:  PUSH    90A
0BE6:  POP     90C
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0BE8:  MOV     #914,W1
0BEA:  MOV     #0,W2
0BEC:  REPEAT  #1FD
0BEE:  CLR.B   [W1++]
....................    }   
0BF0:  BRA     C5A
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0BF2:  PUSH    4080
0BF4:  POP     90A
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0BF6:  MOV     #41,W4
0BF8:  MOV     W4,E5C
0BFA:  CLR     E5E
0BFC:  MOV     E5E,W4
0BFE:  CP      W4,#0
0C00:  BRA     GTU,C52
0C02:  BRA     NC,C0C
0C04:  MOV     E5C,W4
0C06:  MOV     #FF,W3
0C08:  CP      W3,W4
0C0A:  BRA     LEU,C52
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0C0C:  MOV     #1,W4
0C0E:  CLR.B   9
0C10:  MOV     E5C,W0
0C12:  MOV     E5E,W1
0C14:  INC     W4,W4
0C16:  DEC     W4,W4
0C18:  BRA     Z,C20
0C1A:  SL      W0,W0
0C1C:  RLC     W1,W1
0C1E:  BRA     C16
0C20:  MOV     #4000,W4
0C22:  ADD     W0,W4,W0
0C24:  MOV     W0,W4
0C26:  MOV     [W4],W0
0C28:  MOV     90A,W4
0C2A:  CP      W4,W0
0C2C:  BRA     LEU,C4A
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0C2E:  MOV     #1,W4
0C30:  CLR.B   9
0C32:  MOV     E5C,W0
0C34:  MOV     E5E,W1
0C36:  INC     W4,W4
0C38:  DEC     W4,W4
0C3A:  BRA     Z,C42
0C3C:  SL      W0,W0
0C3E:  RLC     W1,W1
0C40:  BRA     C38
0C42:  MOV     #4000,W4
0C44:  ADD     W0,W4,W0
0C46:  MOV     [W0],[W15++]
0C48:  POP     90A
....................         }              
0C4A:  INC     0E5C
0C4C:  BTSC.B  42.1
0C4E:  INC     0E5E
0C50:  BRA     BFC
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0C52:  PUSH    90A
0C54:  POP     90C
....................       ErrorCounter = 0;  
0C56:  CLR     DC0
0C58:  CLR     DC2
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0C5A:  CLR     DC4
0C5C:  CLR     DC6
....................    NormalizeFlag = 0; 
0C5E:  CLR.B   DC8
....................    CurrentIndex = 0; 
0C60:  CLR     DB8
0C62:  CLR     DBA
0C64:  MOV     [--W15],W7
0C66:  MOV     [--W15],W6
0C68:  MOV     [--W15],W5
0C6A:  RETURN  
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
*
0C7A:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0C7C:  MOV.B   E58,W0L
0C7E:  CLR.B   1
0C80:  XOR     #2B,W0
0C82:  BRA     Z,CA2
0C84:  XOR     #1,W0
0C86:  BRA     Z,CA8
0C88:  XOR     #6E,W0
0C8A:  BRA     Z,CAC
0C8C:  XOR     #8,W0
0C8E:  BRA     Z,CBE
0C90:  XOR     #68,W0
0C92:  BRA     Z,D88
0C94:  XOR     #1,W0
0C96:  BRA     Z,DE8
0C98:  XOR     #6,W0
0C9A:  BRA     Z,E44
0C9C:  XOR     #63,W0
0C9E:  BRA     Z,E68
0CA0:  BRA     F2C
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0CA2:  MOV.B   #1,W0L
0CA4:  MOV.B   W0L,DCA
....................          break; 
0CA6:  BRA     F2C
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0CA8:  BCLR.B  94.3
....................          break; 
0CAA:  BRA     F2C
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0CAC:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0CAE:  CLR     104
0CB0:  PUSH    804
0CB2:  POP     102
0CB4:  MOV     #8000,W4
0CB6:  MOV     W4,104
....................          HandshakeFlag = 1;   
0CB8:  MOV.B   #1,W0L
0CBA:  MOV.B   W0L,DCA
....................          break;  
0CBC:  BRA     F2C
....................                       
....................       case 'L': 
....................          DisableInterrupts(); 
0CBE:  CALL    C6C
....................          memset(fir_coef, 0, COEF_LENGTH*2);  
0CC2:  MOV     #DCE,W1
0CC4:  MOV     #0,W2
0CC6:  REPEAT  #7F
0CC8:  CLR.B   [W1++]
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0CCA:  MOV     DAC,W4
0CCC:  XOR     #40,W4
0CCE:  BRA     NZ,CD4
0CD0:  CP0     DAE
0CD2:  BRA     Z,D50
....................          { 
....................             if (kbhit(SHARP)) 
0CD4:  BTSS.B  232.0
0CD6:  BRA     D4E
0CD8:  PUSH    42
0CDA:  BCLR.B  81.7
0CDC:  SETM.B  42
0CDE:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0CE0:  CALL    230
0CE4:  BCLR.B  81.7
0CE6:  POP     42
0CE8:  BSET.B  81.7
0CEA:  MOV.B   W0L,E59
....................                 
....................                if ((CoefficentByte == 'L') && (CSharpCoefficentRecieved == 0)) 
0CEC:  MOV     E58,W4
0CEE:  LSR     W4,#8,W4
0CF0:  XOR.B   #4C,W4L
0CF2:  BRA     NZ,CFE
0CF4:  CP0     DAC
0CF6:  BRA     NZ,CFE
0CF8:  CP0     DAE
0CFA:  BRA     NZ,CFE
....................                { 
....................                   ; // Do nothing 
....................                }               
0CFC:  BRA     D4E
....................                else if (NumberCSharpByteRecieved == 0) 
0CFE:  CP0     DBC
0D00:  BRA     NZ,D12
0D02:  CP0     DBE
0D04:  BRA     NZ,D12
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0D06:  MOV.B   E59,W0L
0D08:  MOV.B   W0L,908
....................                   NumberCSharpByteRecieved = 1; 
0D0A:  MOV     #1,W4
0D0C:  MOV     W4,DBC
0D0E:  CLR     DBE
....................                }            
0D10:  BRA     D4E
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0D12:  MOV.B   E59,W0L
0D14:  MOV.B   W0L,909
....................                   NumberCSharpByteRecieved = 0; 
0D16:  CLR     DBC
0D18:  CLR     DBE
....................                   ByteConversionResult = ((unsigned int16)CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0D1A:  MOV.B   909,W0L
0D1C:  MOV.B   W0L,W5L
0D1E:  CLR.B   B
0D20:  MOV.B   W5L,W0L
0D22:  MOV.B   W0L,B
0D24:  CLR.B   W5
0D26:  MOV     W5,W0
0D28:  IOR     908,W0
0D2A:  MOV     W0,90E
....................                   fir_coef[CSharpCoefficentRecieved] = ByteConversionResult; 
0D2C:  MOV     #1,W4
0D2E:  CLR.B   9
0D30:  MOV     DAC,W0
0D32:  MOV     DAE,W1
0D34:  INC     W4,W4
0D36:  DEC     W4,W4
0D38:  BRA     Z,D40
0D3A:  SL      W0,W0
0D3C:  RLC     W1,W1
0D3E:  BRA     D36
0D40:  MOV     #DCE,W4
0D42:  ADD     W0,W4,W5
0D44:  MOV     90E,W4
0D46:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0D48:  INC     0DAC
0D4A:  BTSC.B  42.1
0D4C:  INC     0DAE
....................                } 
....................             } 
0D4E:  BRA     CCA
....................          } 
....................           
....................          switch (fir_coef[0]) 
0D50:  MOV     DCE,W0
0D52:  XOR     #D2,W0
0D54:  BRA     Z,D60
0D56:  XOR     #FA,W0
0D58:  BRA     Z,D66
0D5A:  XOR     #149,W0
0D5C:  BRA     Z,D6C
0D5E:  BRA     D72
....................          { 
....................          case 210:  
....................             TimerTicks = 53334; 
0D60:  MOV     #D056,W4
0D62:  MOV     W4,804
....................             break; 
0D64:  BRA     D76
....................          case 40: 
....................             TimerTicks = 53334; 
0D66:  MOV     #D056,W4
0D68:  MOV     W4,804
....................             break; 
0D6A:  BRA     D76
....................          case 353: 
....................             TimerTicks = 8000; 
0D6C:  MOV     #1F40,W4
0D6E:  MOV     W4,804
....................             break; 
0D70:  BRA     D76
....................          default:  
....................             TimerTicks = 8000; 
0D72:  MOV     #1F40,W4
0D74:  MOV     W4,804
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0D76:  CLR     DAC
0D78:  CLR     DAE
....................          NormalizeFlag = 1; 
0D7A:  MOV.B   #1,W0L
0D7C:  MOV.B   W0L,DC8
....................          HandshakeFlag = 1; 
0D7E:  MOV.B   #1,W0L
0D80:  MOV.B   W0L,DCA
....................          EnableInterrupts(); 
0D82:  CALL    340
....................          break; 
0D86:  BRA     F2C
....................          
....................       case '$': 
....................          DisableInterrupts(); 
0D88:  CALL    C6C
....................          TriggerValue = 0; // reset trigger value 
0D8C:  CLR     90C
....................           
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0D8E:  BTSS.B  232.0
0D90:  BRA     DD2
0D92:  PUSH    42
0D94:  BCLR.B  81.7
0D96:  SETM.B  42
0D98:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0D9A:  CALL    230
0D9E:  BCLR.B  81.7
0DA0:  POP     42
0DA2:  BSET.B  81.7
0DA4:  MOV.B   W0L,E5A
....................                 
....................                if (isdigit(DigitByte)) 
0DA6:  MOV     E5A,W4
0DA8:  MOV     #30,W3
0DAA:  CP.B    W3L,W4L
0DAC:  BRA     GTU,DC8
0DAE:  MOV     E5A,W4
0DB0:  MOV     #39,W3
0DB2:  CP.B    W3L,W4L
0DB4:  BRA     NC,DC8
....................                { 
....................                   TriggerValue = TriggerValue * 10 + CharToInt(DigitByte); 
0DB6:  MOV     90C,W4
0DB8:  MUL.UU  W4,#A,W0
0DBA:  MOV     W0,W5
0DBC:  MOV.B   E5A,W0L
0DBE:  SE      W0,W0
0DC0:  SUB     #30,W0
0DC2:  ADD     W0,W5,W0
0DC4:  MOV     W0,90C
....................                } 
0DC6:  BRA     DD2
....................                else if (DigitByte == ')') 
0DC8:  MOV     E5A,W4
0DCA:  XOR.B   #29,W4L
0DCC:  BRA     NZ,DD2
....................                { 
....................                   break; 
0DCE:  BRA     DD4
....................                } 
0DD0:  BRA     DD2
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0DD2:  BRA     D8E
....................          } 
....................           
....................          TriggerValueFlag = 1; 
0DD4:  MOV.B   #1,W0L
0DD6:  MOV.B   W0L,DCD
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0DD8:  CLR     104
0DDA:  PUSH    804
0DDC:  POP     102
0DDE:  MOV     #8000,W4
0DE0:  MOV     W4,104
....................          EnableInterrupts(); 
0DE2:  CALL    340
....................          break;  
0DE6:  BRA     F2C
....................           
....................       case '%': 
....................          DisableInterrupts();   
0DE8:  CALL    C6C
....................          TimerTicks = 0; // reset trigger value 
0DEC:  CLR     804
....................              
....................          while (TRUE) 
....................          { 
....................              if (kbhit(SHARP)) 
0DEE:  BTSS.B  232.0
0DF0:  BRA     E38
0DF2:  PUSH    42
0DF4:  BCLR.B  81.7
0DF6:  SETM.B  42
0DF8:  BSET.B  81.7
....................             { 
....................                char DigitByte = fgetc(SHARP); 
0DFA:  CALL    230
0DFE:  BCLR.B  81.7
0E00:  POP     42
0E02:  BSET.B  81.7
0E04:  MOV.B   W0L,E5B
....................                 
....................                if (isdigit(DigitByte)) 
0E06:  MOV     E5A,W4
0E08:  LSR     W4,#8,W4
0E0A:  MOV     #30,W3
0E0C:  CP.B    W3L,W4L
0E0E:  BRA     GTU,E2C
0E10:  MOV     E5A,W4
0E12:  LSR     W4,#8,W4
0E14:  MOV     #39,W3
0E16:  CP.B    W3L,W4L
0E18:  BRA     NC,E2C
....................                { 
....................                   TimerTicks = TimerTicks * 10 + CharToInt(DigitByte); 
0E1A:  MOV     804,W4
0E1C:  MUL.UU  W4,#A,W0
0E1E:  MOV     W0,W5
0E20:  MOV.B   E5B,W0L
0E22:  SE      W0,W0
0E24:  SUB     #30,W0
0E26:  ADD     W0,W5,W0
0E28:  MOV     W0,804
....................                } 
0E2A:  BRA     E38
....................                else if (DigitByte == ')') 
0E2C:  MOV     E5A,W4
0E2E:  LSR     W4,#8,W4
0E30:  XOR.B   #29,W4L
0E32:  BRA     NZ,E38
....................                { 
....................                   break; 
0E34:  BRA     E3A
....................                } 
0E36:  BRA     E38
....................                else 
....................                { 
....................                   ; //Do nothing 
....................                } 
....................             } 
0E38:  BRA     DEE
....................          } 
....................           
....................          HandshakeFlag = 1; 
0E3A:  MOV.B   #1,W0L
0E3C:  MOV.B   W0L,DCA
....................          EnableInterrupts(); 
0E3E:  CALL    340
....................          break; 
0E42:  BRA     F2C
....................             
....................       case '#': 
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0E44:  MOV     #4000,W1
0E46:  MOV     #0,W2
0E48:  REPEAT  #1FD
0E4A:  CLR.B   [W1++]
....................          dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E4C:  BCLR.B  381.7
0E4E:  CLR.B   380
0E50:  MOV     #4000,W4
0E52:  MOV     W4,384
0E54:  MOV     #FF,W4
0E56:  MOV     W4,38A
0E58:  BSET.B  381.7
....................          enable_interrupts(INT_DMA0); 
0E5A:  BSET.B  94.4
....................          DMAFlag = 0; 
0E5C:  CLR.B   DCC
....................          TriggerFlag = 0; 
0E5E:  CLR.B   DCB
....................          TriggerValueFlag = 0; 
0E60:  CLR.B   DCD
....................          HandshakeFlag = 1; 
0E62:  MOV.B   #1,W0L
0E64:  MOV.B   W0L,DCA
....................          break; 
0E66:  BRA     F2C
....................           
....................       case '@': 
....................          DisableInterrupts(); 
0E68:  CALL    C6C
....................          memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0E6C:  MOV     #4000,W1
0E6E:  MOV     #0,W2
0E70:  REPEAT  #1FD
0E72:  CLR.B   [W1++]
....................          dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E74:  BCLR.B  381.7
0E76:  CLR.B   380
0E78:  MOV     #4000,W4
0E7A:  MOV     W4,384
0E7C:  MOV     #FF,W4
0E7E:  MOV     W4,38A
0E80:  BSET.B  381.7
....................          enable_interrupts(INT_DMA0); 
0E82:  BSET.B  94.4
....................          enable_interrupts(GLOBAL); 
0E84:  BCLR.B  81.7
0E86:  CLR     42
0E88:  BSET.B  81.7
....................          HandshakeFlag = 1; 
0E8A:  MOV.B   #1,W0L
0E8C:  MOV.B   W0L,DCA
....................          unsigned int8 TXData; 
....................          while(TRUE) 
....................          { 
....................             output_toggle(LED_PIN); 
0E8E:  BCLR.B  2C9.6
0E90:  BTG.B   2CD.6
....................             read_adc(); 
0E92:  BCLR.B  320.0
0E94:  BSET.B  320.1
0E96:  BTSS.B  320.0
0E98:  BRA     E96
....................              
....................             if((DMADoneFlag == 1) && (HandshakeFlag == 1)) 
0E9A:  MOV     906,W4
0E9C:  LSR     W4,#8,W4
0E9E:  CP.B    W4L,#1
0EA0:  BRA     NZ,EF0
0EA2:  MOV     DCA,W4
0EA4:  CP.B    W4L,#1
0EA6:  BRA     NZ,EF0
....................             { 
....................                for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0EA8:  CLR     E5E
0EAA:  CLR     E60
0EAC:  MOV     E60,W4
0EAE:  CP      W4,#0
0EB0:  BRA     GTU,EEC
0EB2:  BRA     NC,EBC
0EB4:  MOV     E5E,W4
0EB6:  MOV     #FF,W3
0EB8:  CP      W3,W4
0EBA:  BRA     LEU,EEC
....................                { 
....................                    TXData = DMA_ADC_BUFFER[i] >> 4; 
0EBC:  MOV     #1,W4
0EBE:  CLR.B   9
0EC0:  MOV     E5E,W0
0EC2:  MOV     E60,W1
0EC4:  INC     W4,W4
0EC6:  DEC     W4,W4
0EC8:  BRA     Z,ED0
0ECA:  SL      W0,W0
0ECC:  RLC     W1,W1
0ECE:  BRA     EC6
0ED0:  MOV     #4000,W4
0ED2:  ADD     W0,W4,W0
0ED4:  MOV     [W0],W5
0ED6:  LSR     W5,#4,W0
0ED8:  MOV.B   W0L,E5C
0EDA:  MOV.B   W0L,E5C
....................                    printf("%c", TXData); // send every emelent of the array as a byte 
0EDC:  BTSC.B  233.1
0EDE:  BRA     EDC
0EE0:  MOV.B   E5C,W0L
0EE2:  MOV.B   W0L,234
0EE4:  INC     0E5E
0EE6:  BTSC.B  42.1
0EE8:  INC     0E60
0EEA:  BRA     EAC
....................                } 
....................                DMADoneFlag = 0; 
0EEC:  CLR.B   907
....................                HandshakeFlag = 0; 
0EEE:  CLR.B   DCA
....................             } 
....................              
....................             if (kbhit(SHARP)) 
0EF0:  BTSS.B  232.0
0EF2:  BRA     F28
0EF4:  PUSH    42
0EF6:  BCLR.B  81.7
0EF8:  SETM.B  42
0EFA:  BSET.B  81.7
....................             { 
....................                char RXData = fgetc(SHARP); 
0EFC:  CALL    230
0F00:  BCLR.B  81.7
0F02:  POP     42
0F04:  BSET.B  81.7
0F06:  MOV.B   W0L,E5D
....................                 
....................                if (RXData == '+') 
0F08:  MOV     E5C,W4
0F0A:  LSR     W4,#8,W4
0F0C:  XOR.B   #2B,W4L
0F0E:  BRA     NZ,F16
....................                { 
....................                   HandshakeFlag = 1; 
0F10:  MOV.B   #1,W0L
0F12:  MOV.B   W0L,DCA
....................                } 
0F14:  BRA     F24
....................                else if (RXData = '*') 
0F16:  MOV.B   #2A,W0L
0F18:  MOV.B   W0L,E5D
0F1A:  CP0.B   E5D
0F1C:  BRA     Z,F24
....................                { 
....................                   EnableInterrupts(); 
0F1E:  CALL    340
....................                   break; 
0F22:  BRA     F2A
....................                } 
....................                 
....................                RXData = '\n';  
0F24:  MOV.B   #A,W0L
0F26:  MOV.B   W0L,E5D
....................             } 
0F28:  BRA     E8E
....................          } 
....................          break; 
0F2A:  BRA     F2C
....................    
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0F2C:  CLR.B   E58
....................    UARTRXFlag = 0; 
0F2E:  CLR.B   DC9
0F30:  MOV     [--W15],W5
0F32:  RETURN  
.................... } 
....................  
.................... void DisableInterrupts(void) 
.................... { 
....................    disable_interrupts(INT_TIMER1); // disable timer 
*
0C6C:  BCLR.B  94.3
....................    disable_interrupts(INT_RDA2); 
0C6E:  BCLR.B  97.6
....................    disable_interrupts(GLOBAL);  
0C70:  BCLR.B  81.7
0C72:  MOV     #E0,W4
0C74:  MOV     W4,42
0C76:  BSET.B  81.7
0C78:  RETURN  
.................... } 
....................  
.................... void EnableInterrupts(void) 
.................... { 
....................    enable_interrupts(INT_RDA2); 
*
0340:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
0342:  BSET.B  94.3
....................    enable_interrupts(GLOBAL); 
0344:  BCLR.B  81.7
0346:  CLR     42
0348:  BSET.B  81.7
034A:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F7   PUT128 NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
