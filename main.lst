CCS PCD C Compiler, Version 5.008, 5967               06-Nov-22 12:36

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4016 bytes (9%)
                           Largest free fragment is 40016
               RAM used:   3532 (22%) at main() level
                           3569 (22%) worst case
               Stack used: 66 locations (50 in main + 16 for interrupts)
               Stack size: 128

*
0000:  GOTO    CF2
*
001A:  DATA    90,02,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    66,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
02BC:  MOV     W5,[W15++]
02BE:  MOV     #C,W5
02C0:  REPEAT  #3
02C2:  MOV     [W5++],[W15++]
02C4:  MUL.UU  W0,W2,W4
02C6:  BTSS    W3.F
02C8:  BRA     2CE
02CA:  MUL.SS  W0,W3,W6
02CC:  BRA     2D0
02CE:  MUL.UU  W0,W3,W6
02D0:  BCLR.B  42.0
02D2:  ADD     W6,W5,W5
02D4:  ADDC    W7,#0,W8
02D6:  BTSS    W1.F
02D8:  BRA     2DE
02DA:  MUL.SS  W1,W2,W6
02DC:  BRA     2E0
02DE:  MUL.UU  W1,W2,W6
02E0:  ADDC    W6,W5,W5
02E2:  ADDC    W7,W8,W8
02E4:  ADDC    #0,W9
02E6:  MUL.SS  W1,W3,W6
02E8:  ADDC    W6,W8,W8
02EA:  ADDC    W9,W7,W7
02EC:  MOV     W7,W3
02EE:  MOV     W8,W2
02F0:  MOV     W5,W1
02F2:  MOV     W4,W0
02F4:  MOV     #12,W5
02F6:  REPEAT  #3
02F8:  MOV     [--W15],[W5--]
02FA:  MOV     [--W15],W5
02FC:  RETURN  
02FE:  MOV     W5,[W15++]
0300:  MOV     #C,W5
0302:  REPEAT  #3
0304:  MOV     [W5++],[W15++]
0306:  MOV     W0,W4
0308:  MOV     W1,W5
030A:  MOV     W2,W6
030C:  MOV     W3,W7
030E:  CLR     W0
0310:  CLR     W1
0312:  CLR     W2
0314:  CLR     W3
0316:  BCLR    W8.0
0318:  BTSS    W7.F
031A:  BRA     326
031C:  BSET    W6.0
031E:  NEG     W4,W4
0320:  COM     W5,W5
0322:  COM     W6,W6
0324:  COM     W7,W7
0326:  XOR     W4,W5,W9
0328:  BRA     NZ,32E
032A:  XOR     W6,W7,W9
032C:  BRA     Z,356
032E:  MOV     #D6,W1
0330:  BTSC    W2.7
0332:  BRA     346
0334:  BCLR.B  42.0
0336:  RLC     W4,W4
0338:  RLC     W5,W5
033A:  RLC     W6,W6
033C:  RLC     W7,W7
033E:  RLC     W0,W0
0340:  RLC     W2,W2
0342:  DEC     W1,W1
0344:  BRA     NZ,330
0346:  SWAP    W1
0348:  BCLR.B  42.0
034A:  RRC     W1,W1
034C:  BCLR    W1.F
034E:  BCLR    W2.7
0350:  XOR.B   W2L,W1L,W1L
0352:  BTSC    W6.0
0354:  BSET    W1.F
0356:  MOV     #12,W5
0358:  REPEAT  #3
035A:  MOV     [--W15],[W5--]
035C:  MOV     [--W15],W5
035E:  RETURN  
0360:  MOV     W5,[W15++]
0362:  MOV     #C,W5
0364:  REPEAT  #4
0366:  MOV     [W5++],[W15++]
0368:  MOV     W0,W4
036A:  MOV     W1,W5
036C:  MOV     W3,W7
036E:  MOV     W2,W6
0370:  BCLR.B  42.0
0372:  BCLR.B  42.1
0374:  RLC     W1,W1
0376:  SWAP    W1
0378:  AND     #FF,W1
037A:  CP0     W1
037C:  BRA     Z,414
037E:  BCLR.B  42.0
0380:  BCLR.B  42.1
0382:  RLC     W3,W3
0384:  SWAP    W3
0386:  AND     #FF,W3
0388:  CP0     W3
038A:  BRA     Z,414
038C:  ZE      W0,W0
038E:  ADD.B   W3L,W1L,W0L
0390:  BRA     C,39A
0392:  SUB     #7F,W0
0394:  BRA     Z,414
0396:  BRA     NC,414
0398:  BRA     39E
039A:  ADD.B   #81,W0L
039C:  BRA     C,414
039E:  XOR     W5,W7,W10
03A0:  BCLR.B  42.0
03A2:  BCLR.B  42.1
03A4:  AND     #FF,W5
03A6:  BSET    W5.7
03A8:  BCLR.B  42.0
03AA:  AND     #FF,W7
03AC:  BSET    W7.7
03AE:  MUL.UU  W4,W6,W2
03B0:  MUL.UU  W5,W6,W8
03B2:  ADDC    W8,W3,W3
03B4:  MOV     W9,W1
03B6:  BTSC.B  42.0
03B8:  INC     W1,W1
03BA:  BCLR.B  42.0
03BC:  MUL.UU  W7,W4,W8
03BE:  ADDC    W8,W3,W3
03C0:  ADDC    W9,W1,W1
03C2:  MUL.UU  W5,W7,W8
03C4:  ADDC    W8,W1,W1
03C6:  INC     W0,W0
03C8:  CP0     W1
03CA:  BTSC.B  42.1
03CC:  BRA     3D0
03CE:  BRA     3D6
03D0:  CP0     W3
03D2:  BTSC.B  42.1
03D4:  BRA     3E0
03D6:  BTSC    W1.F
03D8:  BRA     3E0
03DA:  RLC     W3,W3
03DC:  RLC     W1,W1
03DE:  DEC     W0,W0
03E0:  MOV     W1,W2
03E2:  BCLR.B  42.0
03E4:  BTSS    W3.7
03E6:  BRA     3FA
03E8:  MOV     #FF00,W7
03EA:  AND     W3,W7,W3
03EC:  ADD     #100,W3
03EE:  ADDC    W2,#0,W2
03F0:  CP0     W2
03F2:  BRA     NZ,3FA
03F4:  CP0     W3
03F6:  BRA     NZ,3FA
03F8:  INC     W0,W0
03FA:  SWAP    W0
03FC:  BCLR.B  42.0
03FE:  BCLR.B  42.1
0400:  RRC     W0,W1
0402:  BTSC    W10.F
0404:  BSET    W1.F
0406:  BCLR    W2.F
0408:  SWAP    W2
040A:  XOR.B   W2L,W1L,W1L
040C:  SWAP    W3
040E:  MOV.B   W3L,W2L
0410:  MOV     W2,W0
0412:  BRA     41A
0414:  MOV     #0,W0
0416:  MOV     #0,W1
0418:  BRA     41A
041A:  MOV     #14,W5
041C:  REPEAT  #4
041E:  MOV     [--W15],[W5--]
0420:  MOV     [--W15],W5
0422:  RETURN  
0424:  MOV     W5,[W15++]
0426:  MOV     #C,W5
0428:  REPEAT  #3
042A:  MOV     [W5++],[W15++]
042C:  CLR     W9
042E:  MOV     #8000,W8
0430:  BTSC.B  43.0
0432:  XOR     W8,W3,W3
0434:  CP0     W0
0436:  BRA     NZ,43E
0438:  MOV     #7FFF,W10
043A:  AND     W1,W10,W10
043C:  BTSS.B  42.1
043E:  MOV     W1,W10
0440:  XOR     W3,W10,W11
0442:  MOV     W1,W6
0444:  MOV     W3,W7
0446:  MOV     W3,W12
0448:  BCLR.B  42.1
044A:  BCLR.B  42.0
044C:  RLC     W6,W6
044E:  SWAP    W6
0450:  AND     #FF,W6
0452:  CP0     W6
0454:  BRA     Z,598
0456:  BCLR.B  42.1
0458:  BCLR.B  42.0
045A:  RLC     W7,W7
045C:  SWAP    W7
045E:  AND     #FF,W7
0460:  CP0     W7
0462:  BRA     Z,5A2
0464:  BCLR.B  42.1
0466:  BCLR.B  42.0
0468:  CP      W7,W6
046A:  BRA     Z,5A4
046C:  BRA     N,5B4
046E:  BCLR    W9.0
0470:  BSET    W9.1
0472:  SUB     W7,W6,W8
0474:  MOV     W7,W6
0476:  AND     #FF,W1
0478:  BSET    W1.7
047A:  AND     #FF,W3
047C:  BSET    W3.7
047E:  MOV     #28,W7
0480:  CP      W7,W8
0482:  BRA     N,4A6
0484:  BCLR.B  42.1
0486:  BCLR.B  42.0
0488:  RRC     W1,W1
048A:  RRC     W0,W0
048C:  DEC     W8,W8
048E:  BRA     NZ,484
0490:  BRA     4AC
0492:  MOV     #28,W7
0494:  CP      W7,W8
0496:  BRA     N,4AA
0498:  BCLR.B  42.1
049A:  BCLR.B  42.0
049C:  RRC     W3,W3
049E:  RRC     W2,W2
04A0:  DEC     W8,W8
04A2:  BRA     NZ,498
04A4:  BRA     4C4
04A6:  MOV     W2,W0
04A8:  MOV     W3,W1
04AA:  BRA     532
04AC:  BTSS    W11.F
04AE:  BRA     4D2
04B0:  BTSC    W9.4
04B2:  MOV     W12,W11
04B4:  NEG     W0,W0
04B6:  BRA     Z,4BC
04B8:  COM.B   W1L,W1L
04BA:  BRA     4BE
04BC:  NEG     W1,W1
04BE:  BTSC    W9.4
04C0:  BRA     518
04C2:  BRA     4D2
04C4:  BTSS    W11.F
04C6:  BRA     4D2
04C8:  NEG     W2,W2
04CA:  BRA     Z,4D0
04CC:  COM.B   W3L,W3L
04CE:  BRA     4D2
04D0:  NEG     W3,W3
04D2:  AND     #FF,W5
04D4:  BCLR.B  42.1
04D6:  BCLR.B  42.0
04D8:  ADD     W0,W2,W0
04DA:  ADDC.B  W1L,W3L,W1L
04DC:  BTSC.B  42.0
04DE:  BSET    W9.3
04E0:  BTSC    W9.0
04E2:  BRA     4F6
04E4:  BTSC    W9.1
04E6:  BRA     4EA
04E8:  BRA     500
04EA:  BTSC    W11.F
04EC:  BRA     518
04EE:  BTSC    W9.3
04F0:  BRA     544
04F2:  BSET    W9.6
04F4:  BRA     532
04F6:  BTSC    W11.F
04F8:  BRA     518
04FA:  BTSC    W9.3
04FC:  BRA     544
04FE:  BRA     532
0500:  BCLR    W9.2
0502:  BTSC    W11.F
0504:  BRA     50E
0506:  MOV     W10,W11
0508:  BTSC    W9.3
050A:  BRA     544
050C:  BRA     57A
050E:  BSET    W9.4
0510:  XOR.B   #80,W1L
0512:  BTSC    W1.7
0514:  BRA     4B0
0516:  MOV     W10,W11
0518:  AND     #FF,W1
051A:  IOR      W0,  W1,W7
051C:  BRA     Z,532
051E:  BTSC    W1.7
0520:  BRA     532
0522:  BCLR.B  42.1
0524:  BCLR.B  42.0
0526:  RLC     W0,W0
0528:  RLC     W1,W1
052A:  DEC     W6,W6
052C:  BTSC.B  42.1
052E:  BRA     592
0530:  BRA     51E
0532:  BTSC    W9.0
0534:  MOV     W10,W11
0536:  BTSC    W9.1
0538:  MOV     W12,W11
053A:  BTSS    W9.5
053C:  BRA     572
053E:  BTSC    W10.F
0540:  BSET    W0.8
0542:  BRA     57A
0544:  BSET.B  42.0
0546:  RRC.B   W1L,W1L
0548:  RRC     W0,W0
054A:  BTSC.B  42.0
054C:  BSET    W9.5
054E:  INC     W6,W6
0550:  BRA     Z,592
0552:  BTSS    W9.5
0554:  BRA     566
0556:  INC     W0,W0
0558:  BRA     NZ,566
055A:  INC.B   W1L,W1L
055C:  BRA     NZ,566
055E:  RRC.B   W1L,W1L
0560:  RRC     W0,W0
0562:  INC     W6,W6
0564:  BRA     Z,592
0566:  BTSC    W9.0
0568:  MOV     W10,W11
056A:  BTSC    W9.1
056C:  MOV     W12,W11
056E:  BTSC.B  42.1
0570:  BRA     592
0572:  BTSC    W9.6
0574:  MOV     W10,W11
0576:  BTSC    W9.7
0578:  MOV     W12,W11
057A:  IOR      W0,  W1,W2
057C:  BRA     Z,5C4
057E:  BCLR    W1.7
0580:  SWAP    W6
0582:  BCLR.B  42.1
0584:  BCLR.B  42.0
0586:  RRC     W6,W6
0588:  XOR     W6,W1,W1
058A:  BSET    W1.F
058C:  BTSS    W11.F
058E:  BCLR    W1.F
0590:  BRA     5C4
0592:  MOV     #0,W0
0594:  MOV     #0,W1
0596:  BRA     5C4
0598:  BTSC    W10.F
059A:  XOR     W8,W3,W3
059C:  MOV     W2,W0
059E:  MOV     W3,W1
05A0:  BRA     5C4
05A2:  BRA     5C4
05A4:  AND     #FF,W3
05A6:  BSET    W3.7
05A8:  AND     #FF,W1
05AA:  BSET    W1.7
05AC:  BTSC    W11.F
05AE:  BCLR    W3.7
05B0:  BSET    W9.2
05B2:  BRA     4C4
05B4:  SUB     W6,W7,W8
05B6:  AND     #FF,W1
05B8:  BSET    W1.7
05BA:  AND     #FF,W3
05BC:  BSET    W3.7
05BE:  BCLR    W9.1
05C0:  BSET    W9.0
05C2:  BRA     492
05C4:  MOV     #12,W5
05C6:  REPEAT  #3
05C8:  MOV     [--W15],[W5--]
05CA:  MOV     [--W15],W5
05CC:  RETURN  
05CE:  MOV     W0,W2
05D0:  MOV     W1,W3
05D2:  MOV.B   W1L,W0L
05D4:  SWAP    W0
05D6:  BSET    W0.F
05D8:  RLC     W1,W1
05DA:  SWAP    W1
05DC:  ZE      W1,W1
05DE:  MOV     #8E,W4
05E0:  SUB.B   W4L,W1L,W1L
05E2:  BRA     Z,5F0
05E4:  CP0     W0
05E6:  BRA     Z,5F0
05E8:  BCLR.B  42.0
05EA:  RRC     W0,W0
05EC:  DEC     W1,W1
05EE:  BRA     NZ,5E4
05F0:  BTSS    W3.F
05F2:  BRA     5F8
05F4:  NEG     W0,W0
05F6:  BRA     5F8
05F8:  RETURN  
*
07C6:  MOV     W5,[W15++]
07C8:  MOV     W6,[W15++]
07CA:  MOV     W0,W4
07CC:  MOV     W1,W5
07CE:  CLR     W0
07D0:  CLR     W1
07D2:  BCLR    W6.0
07D4:  BTSS    W5.F
07D6:  BRA     7E4
07D8:  BSET    W6.0
07DA:  NEG     W4,W4
07DC:  BRA     Z,7E2
07DE:  COM     W5,W5
07E0:  BRA     7E4
07E2:  NEG     W5,W5
07E4:  IOR      W4,  W5,W3
07E6:  BRA     Z,80E
07E8:  CLR     W2
07EA:  MOV     #B6,W1
07EC:  BTSC    W2.7
07EE:  BRA     7FE
07F0:  BCLR.B  42.0
07F2:  RLC     W4,W4
07F4:  RLC     W5,W5
07F6:  RLC     W0,W0
07F8:  RLC     W2,W2
07FA:  DEC     W1,W1
07FC:  BRA     NZ,7EC
07FE:  SWAP    W1
0800:  BCLR.B  42.0
0802:  RRC     W1,W1
0804:  BCLR    W1.F
0806:  BCLR    W2.7
0808:  XOR.B   W2L,W1L,W1L
080A:  BTSC    W6.0
080C:  BSET    W1.F
080E:  MOV     [--W15],W6
0810:  MOV     [--W15],W5
0812:  RETURN  
0814:  MOV     W5,[W15++]
0816:  MOV     #C,W5
0818:  REPEAT  #4
081A:  MOV     [W5++],[W15++]
081C:  CLR     W9
081E:  XOR     W1,W3,W9
0820:  MOV     W1,W6
0822:  MOV     W0,W5
0824:  MOV     W3,W8
0826:  MOV     W2,W7
0828:  RLC     W1,W1
082A:  SWAP    W1
082C:  ZE      W1,W1
082E:  CP0     W1
0830:  BRA     Z,8CE
0832:  RLC     W3,W3
0834:  SWAP    W3
0836:  ZE      W3,W3
0838:  CP0     W3
083A:  BRA     Z,8CE
083C:  CLR     W0
083E:  SUB.B   W1L,W3L,W0L
0840:  BRA     NC,848
0842:  ADD.B   #7F,W0L
0844:  BRA     C,8CE
0846:  BRA     84E
0848:  SUB.B   #81,W0L
084A:  BRA     NC,8CE
084C:  BRA     Z,8CE
084E:  MOV     W5,W1
0850:  MOV     W6,W2
0852:  BSET    W2.7
0854:  AND     #FF,W2
0856:  AND     #FF,W8
0858:  BSET    W8.7
085A:  MOV     #19,W10
085C:  CLR     W3
085E:  CLR     W4
0860:  SUB     W1,W7,W1
0862:  SUBB    W2,W8,W2
0864:  BRA     N,86A
0866:  BRA     C,870
0868:  BRA     NZ,872
086A:  ADD     W1,W7,W1
086C:  ADDC    W2,W8,W2
086E:  BRA     872
0870:  BSET    W4.0
0872:  DEC     W10,W10
0874:  BRA     Z,884
0876:  BCLR.B  42.0
0878:  RLC     W1,W1
087A:  RLC     W2,W2
087C:  BCLR.B  42.0
087E:  RLC     W4,W4
0880:  RLC     W3,W3
0882:  BRA     860
0884:  CLR     W10
0886:  BTSC    W3.8
0888:  BRA     88C
088A:  BRA     898
088C:  BCLR.B  42.0
088E:  RRC     W3,W3
0890:  BCLR    W3.7
0892:  RRC     W4,W4
0894:  RLC     W10,W10
0896:  BRA     89C
0898:  DEC     W0,W0
089A:  BRA     Z,8CE
089C:  BTSC    W10.F
089E:  BRA     NC,8AA
08A0:  RLC     W1,W1
08A2:  RLC     W2,W2
08A4:  SUB     W1,W7,W1
08A6:  SUBB    W2,W8,W2
08A8:  BRA     NC,8BC
08AA:  INC     W4,W4
08AC:  BRA     NZ,8BC
08AE:  INC     W3,W3
08B0:  BRA     NZ,8BC
08B2:  INC     W0,W0
08B4:  BRA     Z,8CE
08B6:  BRA     8BC
08B8:  DEC     W0,W0
08BA:  BRA     Z,8CE
08BC:  SWAP    W0
08BE:  RRC     W0,W1
08C0:  BSET    W1.F
08C2:  BTSS    W9.F
08C4:  BCLR    W1.F
08C6:  BCLR    W3.7
08C8:  XOR.B   W3L,W1L,W1L
08CA:  MOV     W4,W0
08CC:  BRA     8D4
08CE:  MOV     #0,W0
08D0:  MOV     #0,W1
08D2:  BRA     8D4
08D4:  MOV     #14,W5
08D6:  REPEAT  #4
08D8:  MOV     [--W15],[W5--]
08DA:  MOV     [--W15],W5
08DC:  RETURN  
08DE:  MOV     W8,[W15++]
08E0:  MOV     #12,W8
08E2:  REPEAT  #4
08E4:  MOV     [W8++],[W15++]
08E6:  MOV     #0,W9
08E8:  BTSC.B  43.0
08EA:  MOV     #1,W9
08EC:  MOV     W9,[W15++]
08EE:  CLR     W8
08F0:  CLR     W9
08F2:  CLR     W10
08F4:  CLR     W11
08F6:  CLR     W12
08F8:  CLR     W13
08FA:  MOV     #E,W8
08FC:  MOV     #0,W9
08FE:  LNK     #10
0900:  MOV     W12,[W14+W8]
0902:  DEC2    W8,W8
0904:  BRA     NN,900
0906:  XOR     W4,W5,W8
0908:  BRA     NZ,90E
090A:  XOR     W6,W7,W8
090C:  BRA     Z,99E
090E:  CLR     W8
0910:  CLR     W13
0912:  MOV     W13,[W15++]
0914:  BTSS    W3.F
0916:  BRA     92C
0918:  MOV     [--W15],W13
091A:  BSET    W13.F
091C:  MOV     W13,[W15++]
091E:  COM     W3,W3
0920:  COM     W2,W2
0922:  COM     W1,W1
0924:  NEG     W0,W0
0926:  ADDC    W1,#0,W1
0928:  ADDC    W2,#0,W2
092A:  ADDC    W3,#0,W3
092C:  BTSS    W7.F
092E:  BRA     944
0930:  MOV     [--W15],W13
0932:  BTG     W13.F
0934:  MOV     W13,[W15++]
0936:  COM     W7,W7
0938:  COM     W6,W6
093A:  COM     W5,W5
093C:  NEG     W4,W4
093E:  ADDC    W5,#0,W5
0940:  ADDC    W6,#0,W6
0942:  ADDC    W7,#0,W7
0944:  MOV     #40,W13
0946:  BCLR.B  42.0
0948:  RLC     W0,W0
094A:  RLC     W1,W1
094C:  RLC     W2,W2
094E:  RLC     W3,W3
0950:  RLC     W8,W8
0952:  RLC     W9,W9
0954:  RLC     W10,W10
0956:  RLC     W11,W11
0958:  CP      W11,W7
095A:  BRA     NZ,966
095C:  CPB     W10,W6
095E:  BRA     NZ,966
0960:  CPB     W9,W5
0962:  BRA     NZ,966
0964:  CPB     W8,W4
0966:  BRA     NC,972
0968:  SUB     W8,W4,W8
096A:  SUBB    W9,W5,W9
096C:  SUBB    W10,W6,W10
096E:  SUBB    W11,W7,W11
0970:  BSET.B  42.0
0972:  MOV     W8,[W14]
0974:  MOV     W9,[W14+#2]
0976:  MOV     W10,[W14+#4]
0978:  MOV     W11,[W14+#6]
097A:  MOV     [W14+#8],W8
097C:  MOV     [W14+#A],W9
097E:  MOV     [W14+#C],W10
0980:  MOV     [W14+#E],W11
0982:  RLC     W8,W8
0984:  RLC     W9,W9
0986:  RLC     W10,W10
0988:  RLC     W11,W11
098A:  MOV     W8,[W14+#8]
098C:  MOV     W9,[W14+#A]
098E:  MOV     W10,[W14+#C]
0990:  MOV     W11,[W14+#E]
0992:  MOV     [W14],W8
0994:  MOV     [W14+#2],W9
0996:  MOV     [W14+#4],W10
0998:  MOV     [W14+#6],W11
099A:  DEC     W13,W13
099C:  BRA     NZ,946
099E:  MOV     [W14+#8],W0
09A0:  MOV     [W14+#A],W1
09A2:  MOV     [W14+#C],W2
09A4:  MOV     [W14+#E],W3
09A6:  MOV     [--W15],W13
09A8:  BTSS    W13.F
09AA:  BRA     9BA
09AC:  COM     W3,W3
09AE:  COM     W2,W2
09B0:  COM     W1,W1
09B2:  NEG     W0,W0
09B4:  ADDC    W1,#0,W1
09B6:  ADDC    W2,#0,W2
09B8:  ADDC    W3,#0,W3
09BA:  ULNK    
09BC:  BRA     9BE
09BE:  MOV     [--W15],W9
09C0:  CP0     W9
09C2:  BRA     Z,9CC
09C4:  MOV     W8,W0
09C6:  MOV     W9,W1
09C8:  MOV     W10,W2
09CA:  MOV     W11,W3
09CC:  MOV     #1A,W8
09CE:  REPEAT  #4
09D0:  MOV     [--W15],[W8--]
09D2:  MOV     [--W15],W8
09D4:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
0244:  MOV     W5,[W15++]
0246:  MOV     #4B00,W5
0248:  REPEAT  #19E
024A:  NOP     
024C:  DEC     W5,W5
024E:  BRA     NZ,256
0250:  CLR     800
0252:  MOV     #0,W0
0254:  BRA     262
0256:  BTSS.B  232.0
0258:  BRA     248
025A:  PUSH    232
025C:  POP     800
025E:  MOV     236,W0
0260:  BCLR.B  232.1
0262:  MOV     [--W15],W5
0264:  RETURN  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 255 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14    
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
.................... const unsigned int8 UART_TX_DMA_CHANNEL = 1; 
.................... const IndexType NumberOfDigitizationRequired = BUFFER_SIZE / COEF_LENGTH; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX = '\0'; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType UARTTXFlag = 0;       // flag to send data out 
.................... FlagType HandShakeFlag = 0;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... void CommHandler(char); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... volatile signed int16 fir_coef[COEF_LENGTH] = 
.................... { 
.................... 210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... -246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... 368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... 1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... 1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... 368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... -246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... 210 
.................... }; 
.................... //! 
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
....................  
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,907
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_RDA2 
.................... void UART2_ISR() 
*
0266:  PUSH    42
0268:  PUSH    36
026A:  PUSH    32
026C:  MOV     W0,[W15++]
026E:  MOV     #2,W0
0270:  REPEAT  #C
0272:  MOV     [W0++],[W15++]
.................... { 
....................    UARTRX = fgetc(SHARP); 
0274:  CALL    244
0278:  MOV.B   W0L,807
....................    UARTRXFlag = 1; 
027A:  MOV.B   #1,W0L
027C:  MOV.B   W0L,11C5
.................... } 
....................  
027E:  BCLR.B  87.6
0280:  MOV     #1A,W0
0282:  REPEAT  #C
0284:  MOV     [--W15],[W0--]
0286:  MOV     [--W15],W0
0288:  POP     32
028A:  POP     36
028C:  POP     42
028E:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
0290:  PUSH    42
0292:  PUSH    36
0294:  PUSH    32
0296:  MOV     W0,[W15++]
0298:  MOV     #2,W0
029A:  REPEAT  #C
029C:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN);  
029E:  BCLR.B  2C9.6
02A0:  BTG.B   2CD.6
....................    read_adc(); 
02A2:  BCLR.B  320.0
02A4:  BSET.B  320.1
02A6:  BTSS.B  320.0
02A8:  BRA     2A6
.................... //!   if(NormalizeFlag == 1) 
.................... //!   { 
.................... //!      read_adc(); 
.................... //!      NormalizeDataCounter++; 
.................... //!   } 
.................... //!   else 
.................... //!   { 
.................... //!      unsigned int16 ADCValue = 0; 
.................... //!       
.................... //!      if (TriggerFlag != 2) 
.................... //!      { 
.................... //!          ADCValue = QuickDigitize(read_adc()); 
.................... //!      } 
.................... //!       
.................... //!      if (DMAFlag == 0) 
.................... //!      { 
.................... //!         disable_interrupts(INT_DMA0); 
.................... //!         memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!         DMAFlag = 1; 
.................... //!      } 
.................... //!       
.................... //!      if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
.................... //!      { 
.................... //!         DMA_ADC_BUFFER[0] = ADCValue; 
.................... //!         TriggerFlag = 1; 
.................... //!      } 
.................... //!      else if(DMA_ADC_BUFFER[1] > ADCValue) 
.................... //!      { 
.................... //!         DMA_ADC_BUFFER[1] = ADCValue; 
.................... //!         TriggerFlag = 2; 
.................... //!      } 
.................... //!      else if(TriggerFlag == 2) 
.................... //!      { 
.................... //!         if(DMAFlag == 1) 
.................... //!         { 
.................... //!            //memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!            dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
.................... //!            enable_interrupts(INT_DMA0); 
.................... //!            DMAFlag = 2; 
.................... //!         } 
.................... //!          
.................... //!         read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
.................... //!      }   
.................... //!      else 
.................... //!      { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
.................... //!          
.................... //!         TriggerFlag = 0; 
.................... //!      } 
.................... //!   } 
.................... //! 
.................... //! if (CurrentIndex == 0) 
.................... //!   { 
.................... //!     CurrentIndex = COEF_LENGTH - 1; 
.................... //!   } 
.................... //!   else 
.................... //!   { 
.................... //!     CurrentIndex--; 
.................... //!   }  
02AA:  BCLR.B  84.3
02AC:  MOV     #1A,W0
02AE:  REPEAT  #C
02B0:  MOV     [--W15],[W0--]
02B2:  MOV     [--W15],W0
02B4:  POP     32
02B6:  POP     36
02B8:  POP     42
02BA:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0CF2:  MOV     #4444,W0
0CF4:  MOV     W0,A4
0CF6:  BSET.B  81.7
0CF8:  MOV     #46,W0
0CFA:  MOV.B   W0L,742
0CFC:  MOV     #57,W0
0CFE:  MOV.B   W0L,742
0D00:  BCLR.B  742.6
0D02:  MOV     #3F07,W0
0D04:  MOV     W0,6A6
0D06:  MOV     #5,W0
0D08:  MOV     W0,6C6
0D0A:  MOV     #46,W0
0D0C:  MOV.B   W0L,742
0D0E:  MOV     #57,W0
0D10:  MOV.B   W0L,742
0D12:  BSET.B  742.6
0D14:  MOV     #41,W4
0D16:  MOV     W4,744
0D18:  MOV     #32,W4
0D1A:  MOV     W4,746
0D1C:  CLR     800
0D1E:  MOV     #8000,W4
0D20:  MOV     W4,230
0D22:  MOV     #400,W4
0D24:  MOV     W4,232
0D26:  BSET.B  230.3
0D28:  MOV     #22,W4
0D2A:  MOV     W4,238
0D2C:  CLR     804
0D2E:  CLR     90A
0D30:  CLR     90C
0D32:  CLR     90E
0D34:  CLR     910
0D36:  CLR     912
0D38:  CLR     110C
0D3A:  CLR     110E
0D3C:  CLR     1110
0D3E:  CLR     1112
0D40:  CLR     1114
0D42:  CLR     1116
0D44:  CLR     1118
0D46:  CLR     111A
0D48:  CLR     11A0
0D4A:  CLR     11A2
0D4C:  CLR     11A4
0D4E:  CLR     11A6
0D50:  CLR.B   807
0D52:  CLR     11A8
0D54:  CLR     11AA
0D56:  CLR     11AC
0D58:  CLR     11AE
0D5A:  CLR     11B0
0D5C:  CLR     11B2
0D5E:  CLR     11B4
0D60:  CLR     11B6
0D62:  CLR     11B8
0D64:  CLR     11BA
0D66:  CLR     11BC
0D68:  CLR     11BE
0D6A:  CLR     11C0
0D6C:  CLR     11C2
0D6E:  CLR.B   907
0D70:  CLR.B   11C4
0D72:  CLR.B   11C5
0D74:  CLR.B   11C6
0D76:  CLR.B   11C7
0D78:  CLR.B   11C8
0D7A:  CLR.B   11C9
0D7C:  MOV     #41,W4
0D7E:  MOV     W4,744
0D80:  MOV     #32,W4
0D82:  MOV     W4,746
0D84:  DISI    #E
0D86:  MOV     #101,W0
0D88:  MOV     #743,W1
0D8A:  MOV     #78,W2
0D8C:  MOV     #9A,W3
0D8E:  MOV.B   W2L,[W1]
0D90:  MOV.B   W3L,[W1]
0D92:  MOV.B   W0L,743
0D94:  LSR     W0,#8,W0
0D96:  MOV     #742,W1
0D98:  MOV     #46,W2
0D9A:  MOV     #57,W3
0D9C:  MOV.B   W2L,[W1]
0D9E:  MOV.B   W3L,[W1]
0DA0:  MOV.B   W0L,[W1]
0DA2:  SETM    32C
0DA4:  MOV     #3F80,W15
0DA6:  MOV     #3FFF,W0
0DA8:  MOV     W0,20
0DAA:  NOP     
0DAC:  BRA     E28
0DAE:  DATA    80,02,08
0DB0:  DATA    02,00,00
0DB2:  DATA    80,80,11
0DB4:  DATA    CA,D2,00
0DB6:  DATA    59,FF,6A
0DB8:  DATA    FF,65,FF
0DBA:  DATA    55,FF,40
0DBC:  DATA    FF,2B,FF
0DBE:  DATA    19,FF,0D
0DC0:  DATA    FF,0A,FF
0DC2:  DATA    11,FF,26
0DC4:  DATA    FF,49,FF
0DC6:  DATA    7B,FF,BF
0DC8:  DATA    FF,13,00
0DCA:  DATA    78,00,ED
0DCC:  DATA    00,70,01
0DCE:  DATA    FF,01,98
0DD0:  DATA    02,37,03
0DD2:  DATA    D8,03,79
0DD4:  DATA    04,16,05
0DD6:  DATA    A9,05,30
0DD8:  DATA    06,A7,06
0DDA:  DATA    0A,07,57
0DDC:  DATA    07,8B,07
0DDE:  DATA    A6,07,A6
0DE0:  DATA    07,8B,07
0DE2:  DATA    57,07,0A
0DE4:  DATA    07,A7,06
0DE6:  DATA    30,06,A9
0DE8:  DATA    05,16,05
0DEA:  DATA    79,04,D8
0DEC:  DATA    03,37,03
0DEE:  DATA    98,02,FF
0DF0:  DATA    01,70,01
0DF2:  DATA    ED,00,78
0DF4:  DATA    00,13,00
0DF6:  DATA    BF,FF,7B
0DF8:  DATA    FF,49,FF
0DFA:  DATA    26,FF,11
0DFC:  DATA    FF,0A,FF
0DFE:  DATA    0D,FF,19
0E00:  DATA    FF,2B,FF
0E02:  DATA    40,FF,55
0E04:  DATA    FF,65,FF
0E06:  DATA    6A,FF,59
0E08:  DATA    FF,D2,00
0E0A:  DATA    00,00,00
0E0C:  INC     W2,W2
0E0E:  CP      W2,#1
0E10:  BRA     NZ,E1A
0E12:  TBLRDL  [W1],W3
0E14:  TBLRDH  [W1++],W4
0E16:  MOV.B   6,W0L
0E18:  RETURN  
0E1A:  CP      W2,#2
0E1C:  BRA     NZ,E22
0E1E:  MOV.B   7,W0L
0E20:  RETURN  
0E22:  MOV.B   8,W0L
0E24:  CLR     W2
0E26:  RETURN  
0E28:  MOV     #0,W6
0E2A:  MOV     #0,W0
0E2C:  MOV     W0,32
0E2E:  MOV     #DAE,W0
0E30:  MOV     W0,W1
0E32:  CLR     W2
0E34:  CALL    E0C
0E38:  MOV.B   W0L,B
0E3A:  CALL    E0C
0E3E:  MOV.B   W0L,A
0E40:  CP0     W5
0E42:  BRA     Z,E76
0E44:  BTSS    W5.F
0E46:  BRA     E56
0E48:  CALL    E0C
0E4C:  MOV.B   W0L,D
0E4E:  CALL    E0C
0E52:  MOV.B   W0L,C
0E54:  BCLR    W5.F
0E56:  BTSS    W5.E
0E58:  BRA     E6A
0E5A:  BCLR    W5.E
0E5C:  DEC     W5,W5
0E5E:  CALL    E0C
0E62:  MOV.B   W0L,W7L
0E64:  REPEAT  W5
0E66:  MOV.B   W7L,[W6++]
0E68:  BRA     E34
0E6A:  CALL    E0C
0E6E:  MOV.B   W0L,[W6++]
0E70:  DEC     W5,W5
0E72:  BRA     NZ,E6A
0E74:  BRA     E34
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE); 
0E76:  MOV     #4000,W1
0E78:  MOV     #0,W2
0E7A:  REPEAT  #FE
0E7C:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE); 
0E7E:  MOV     #41FE,W1
0E80:  MOV     #61,W2
0E82:  MOV.B   #61,W2L
0E84:  REPEAT  #FE
0E86:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0E88:  CLR.B   381
0E8A:  MOV.B   #D,W0L
0E8C:  MOV.B   W0L,382
0E8E:  MOV     #300,W4
0E90:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E92:  BCLR.B  381.7
0E94:  CLR.B   380
0E96:  MOV     #4000,W4
0E98:  MOV     W4,384
0E9A:  MOV     #FF,W4
0E9C:  MOV     W4,38A
0E9E:  BSET.B  381.7
....................     
.................... //!   setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
.................... //!   enable_interrupts(INT_DMA1); 
....................  
....................    enable_interrupts(INT_DMA0); 
0EA0:  BSET.B  94.4
....................  
.................... // setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0EA2:  MOV     #9F00,W4
0EA4:  MOV     W4,324
0EA6:  MOV     #84E0,W4
0EA8:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0EAA:  MOV     #FFFE,W4
0EAC:  MOV     W4,32C
0EAE:  CLR     322
....................     
....................    read_adc(); 
0EB0:  BCLR.B  320.0
0EB2:  BSET.B  320.1
0EB4:  BTSS.B  320.0
0EB6:  BRA     EB4
....................     
....................    TimerTicks = 53334; 
0EB8:  MOV     #D056,W4
0EBA:  MOV     W4,804
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0EBC:  CLR     104
0EBE:  PUSH    804
0EC0:  POP     102
0EC2:  MOV     #8000,W4
0EC4:  MOV     W4,104
....................    enable_interrupts(INT_RDA2); 
0EC6:  BSET.B  97.6
....................    enable_interrupts(INT_TIMER1); 
0EC8:  BSET.B  94.3
....................    enable_interrupts(INTR_GLOBAL); 
0ECA:  BCLR.B  81.7
0ECC:  CLR     42
0ECE:  BSET.B  81.7
....................     
....................    NormalizeFlag = 1; 
0ED0:  MOV.B   #1,W0L
0ED2:  MOV.B   W0L,11C4
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
0ED4:  CP0.B   907
0ED6:  BRA     NZ,EE2
0ED8:  MOV     11C0,W4
0EDA:  XOR     #FF,W4
0EDC:  BRA     NZ,FA0
0EDE:  CP0     11C2
0EE0:  BRA     NZ,FA0
....................       { 
....................          disable_interrupts(INT_DMA0); 
0EE2:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < BUFFER_SIZE; Index++) 
0EE4:  CLR     124A
0EE6:  CLR     124C
0EE8:  MOV     124C,W4
0EEA:  CP      W4,#0
0EEC:  BRA     GTU,F0C
0EEE:  BRA     NC,EF8
0EF0:  MOV     124A,W4
0EF2:  MOV     #FF,W3
0EF4:  CP      W3,W4
0EF6:  BRA     LEU,F0C
....................          { 
....................             AccumulateAnalogData(Index); 
0EF8:  PUSH    124A
0EFA:  POP     1254
0EFC:  PUSH    124C
0EFE:  POP     1256
0F00:  CALL    5FA
0F04:  INC     124A
0F06:  BTSC.B  42.1
0F08:  INC     124C
0F0A:  BRA     EE8
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
0F0C:  MOV     11C4,W4
0F0E:  CP.B    W4L,#1
0F10:  BRA     NZ,F18
....................          { 
....................             NormalizeData(); 
0F12:  CALL    9D6
....................          } 
0F16:  BRA     F18
....................          else 
....................          { 
....................           
....................          } 
....................              
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
.................... //!         Todo:: DMA THE ANALOG DATA ARRAY ALSO  
....................          if (HandShakeFlag == 1) 
0F18:  MOV     11C6,W4
0F1A:  LSR     W4,#8,W4
0F1C:  CP.B    W4L,#1
0F1E:  BRA     NZ,F92
....................          { 
....................             for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0F20:  CLR     124E
0F22:  CLR     1250
0F24:  MOV     1250,W4
0F26:  CP      W4,#0
0F28:  BRA     GTU,F4E
0F2A:  BRA     NC,F34
0F2C:  MOV     124E,W4
0F2E:  MOV     #FF,W3
0F30:  CP      W3,W4
0F32:  BRA     LEU,F4E
....................             { 
....................                 printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
0F34:  MOV     #808,W4
0F36:  MOV     124E,W3
0F38:  ADD     W3,W4,W0
0F3A:  MOV.B   [W0],W5L
0F3C:  BTSC.B  233.1
0F3E:  BRA     F3C
0F40:  PUSH    234
0F42:  MOV.B   W5L,[W15-#2]
0F44:  POP     234
0F46:  INC     124E
0F48:  BTSC.B  42.1
0F4A:  INC     1250
0F4C:  BRA     F24
....................             } 
....................     
....................             for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
0F4E:  CLR     124E
0F50:  CLR     1250
0F52:  MOV     1250,W4
0F54:  CP      W4,#0
0F56:  BRA     GTU,F92
0F58:  BRA     NC,F62
0F5A:  MOV     124E,W4
0F5C:  MOV     #FF,W3
0F5E:  CP      W3,W4
0F60:  BRA     LEU,F92
....................             { 
....................                 printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
0F62:  MOV     #2,W4
0F64:  CLR.B   9
0F66:  MOV     124E,W0
0F68:  MOV     1250,W1
0F6A:  INC     W4,W4
0F6C:  DEC     W4,W4
0F6E:  BRA     Z,F76
0F70:  SL      W0,W0
0F72:  RLC     W1,W1
0F74:  BRA     F6C
0F76:  MOV     #914,W4
0F78:  ADD     W0,W4,W0
0F7A:  MOV     #A,W4
0F7C:  MOV     [W0++],[W4++]
0F7E:  MOV     [W0++],[W4++]
0F80:  BTSC.B  233.1
0F82:  BRA     F80
0F84:  PUSH    234
0F86:  MOV.B   W5L,[W15-#2]
0F88:  POP     234
0F8A:  INC     124E
0F8C:  BTSC.B  42.1
0F8E:  INC     1250
0F90:  BRA     F52
....................             } 
....................          } 
....................          HandShakeFlag = 0;    
0F92:  CLR.B   11C7
....................          CurrentIndex = 0; 
0F94:  CLR     11B4
0F96:  CLR     11B6
....................          enable_interrupts(INT_DMA0); 
0F98:  BSET.B  94.4
....................          DMADoneFlag = 0; 
0F9A:  CLR.B   907
....................          DMAFlag = 0; 
0F9C:  CLR.B   11C9
....................          TriggerFlag = 0; 
0F9E:  CLR.B   11C8
....................       }   
....................        
....................       if (UARTRXFlag) 
0FA0:  CP0.B   11C5
0FA2:  BRA     Z,FAC
....................       { 
....................          CommHandler(UARTRX); 
0FA4:  MOV.B   807,W0L
0FA6:  MOV.B   W0L,1254
0FA8:  CALL    BFA
....................       }   
0FAC:  BRA     ED4
....................    } 
.................... } 
....................  
0FAE:  PWRSAV  #0
.................... void AccumulateAnalogData(IndexType DMAADCIndex) 
*
05FA:  MOV     W5,[W15++]
05FC:  MOV     W6,[W15++]
.................... { 
....................    InputSamples[CurrentIndex] = DMA_ADC_BUFFER[DMAADCIndex]; 
05FE:  MOV     #1,W4
0600:  CLR.B   9
0602:  MOV     11B4,W0
0604:  MOV     11B6,W1
0606:  INC     W4,W4
0608:  DEC     W4,W4
060A:  BRA     Z,612
060C:  SL      W0,W0
060E:  RLC     W1,W1
0610:  BRA     608
0612:  MOV     #111C,W4
0614:  ADD     W0,W4,W5
0616:  MOV     #1,W4
0618:  CLR.B   9
061A:  MOV     1254,W0
061C:  MOV     1256,W1
061E:  INC     W4,W4
0620:  DEC     W4,W4
0622:  BRA     Z,62A
0624:  SL      W0,W0
0626:  RLC     W1,W1
0628:  BRA     620
062A:  MOV     #4000,W4
062C:  ADD     W0,W4,W0
062E:  MOV     [W0],[W5]
....................    InputIndex = CurrentIndex;  
0630:  PUSH    11B4
0632:  POP     11B0
0634:  PUSH    11B6
0636:  POP     11B2
....................    Accumulator = 0; 
0638:  CLR     910
063A:  CLR     912
....................    CoefficentIndex = 0; 
063C:  CLR     11AC
063E:  CLR     11AE
....................     
....................    while (CoefficentIndex < COEF_LENGTH - 1) 
0640:  MOV     11AE,W4
0642:  CP      W4,#0
0644:  BRA     GTU,6C8
0646:  BRA     NC,650
0648:  MOV     11AC,W4
064A:  MOV     #3F,W3
064C:  CP      W3,W4
064E:  BRA     LEU,6C8
....................    { 
....................       Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
0650:  MOV     #1,W4
0652:  CLR.B   9
0654:  MOV     11B0,W0
0656:  MOV     11B2,W1
0658:  INC     W4,W4
065A:  DEC     W4,W4
065C:  BRA     Z,664
065E:  SL      W0,W0
0660:  RLC     W1,W1
0662:  BRA     65A
0664:  MOV     #111C,W4
0666:  ADD     W0,W4,W0
0668:  MOV     W0,W4
066A:  MOV     [W4],W0
066C:  MOV     W0,W5
066E:  CLR     W6
0670:  BTSC    W5.F
0672:  SETM    W6
0674:  MOV     #1,W4
0676:  CLR.B   9
0678:  MOV     11AC,W0
067A:  MOV     11AE,W1
067C:  INC     W4,W4
067E:  DEC     W4,W4
0680:  BRA     Z,688
0682:  SL      W0,W0
0684:  RLC     W1,W1
0686:  BRA     67E
0688:  MOV     #11CA,W4
068A:  ADD     W0,W4,W0
068C:  MOV     W0,W4
068E:  MOV     [W4],W0
0690:  CLR     W1
0692:  BTSC    W0.F
0694:  SETM    W1
0696:  MOV     W0,W2
0698:  MOV     W1,W3
069A:  MOV     W5,W0
069C:  MOV     W6,W1
069E:  CALL    2BC
06A2:  ADD     910
06A4:  MOV     W1,W0
06A6:  ADDC    912,W0
06A8:  MOV     W0,912
....................         // condition for the circular buffer 
....................       if (InputIndex == COEF_LENGTH - 1) 
06AA:  MOV     11B0,W4
06AC:  XOR     #3F,W4
06AE:  BRA     NZ,6BA
06B0:  CP0     11B2
06B2:  BRA     NZ,6BA
....................       { 
....................          InputIndex = 0; 
06B4:  CLR     11B0
06B6:  CLR     11B2
....................       } 
06B8:  BRA     6C0
....................       else 
....................       { 
....................          InputIndex++; 
06BA:  INC     11B0
06BC:  BTSC.B  42.1
06BE:  INC     11B2
....................       } 
....................        
....................       CoefficentIndex++; 
06C0:  INC     11AC
06C2:  BTSC.B  42.1
06C4:  INC     11AE
06C6:  BRA     640
....................    } 
....................     
....................    AnalogData[DMAADCIndex] =  InputSamples[CurrentIndex] >> 4; 
06C8:  MOV     #808,W4
06CA:  MOV     1254,W3
06CC:  ADD     W3,W4,W5
06CE:  MOV     #1,W4
06D0:  CLR.B   9
06D2:  MOV     11B4,W0
06D4:  MOV     11B6,W1
06D6:  INC     W4,W4
06D8:  DEC     W4,W4
06DA:  BRA     Z,6E2
06DC:  SL      W0,W0
06DE:  RLC     W1,W1
06E0:  BRA     6D8
06E2:  MOV     #111C,W4
06E4:  ADD     W0,W4,W0
06E6:  MOV     [W0],W6
06E8:  LSR     W6,#4,W0
06EA:  MOV.B   W0L,[W5]
06EC:  MOV.B   W0L,[W5]
....................     
....................    if (NormalizeFlag == 1) 
06EE:  MOV     11C4,W4
06F0:  CP.B    W4L,#1
06F2:  BRA     NZ,714
....................    { 
....................       DigitizedData[DMAADCIndex] = Accumulator; 
06F4:  MOV     #2,W4
06F6:  CLR.B   9
06F8:  MOV     1254,W0
06FA:  MOV     1256,W1
06FC:  INC     W4,W4
06FE:  DEC     W4,W4
0700:  BRA     Z,708
0702:  SL      W0,W0
0704:  RLC     W1,W1
0706:  BRA     6FE
0708:  MOV     #914,W4
070A:  ADD     W0,W4,W5
070C:  MOV     #910,W4
070E:  MOV     [W4++],[W5++]
0710:  MOV     [W4++],[W5++]
....................    } 
0712:  BRA     7AA
....................    else 
....................    { 
....................       float StepOne = Accumulator - AverageAnalogValue; 
....................       float StepTwo = StepOne * AverageMultiplier; 
....................       float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
0714:  MOV     910,W0
0716:  MOV     912,W1
0718:  CLR     W3
071A:  BTSC    W1.F
071C:  SETM    W3
071E:  MOV     W3,W2
0720:  MOV     1114,W4
0722:  SUB     W0,W4,W0
0724:  MOV     1116,W4
0726:  SUBB    W1,W4,W1
0728:  MOV     1118,W4
072A:  SUBB    W2,W4,W2
072C:  MOV     111A,W4
072E:  SUBB    W3,W4,W3
0730:  CALL    2FE
0734:  MOV     W0,1258
0736:  MOV     W1,125A
0738:  MOV     1258,W0
073A:  MOV     125A,W1
073C:  MOV     11A4,W2
073E:  MOV     11A6,W3
0740:  CALL    360
0744:  MOV     W0,125C
0746:  MOV     W1,125E
0748:  BCLR.B  43.0
074A:  MOV     125C,W0
074C:  MOV     125E,W1
074E:  MOV     #0,W2
0750:  MOV     #42FE,W3
0752:  CALL    424
0756:  MOV     W0,1260
0758:  MOV     W1,1262
....................       //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................       //ConversionValue = (unsigned int8)OutputValue; 
....................       ConversionValue = (unsigned int8)StepThree; 
075A:  MOV     1260,W0
075C:  MOV     1262,W1
075E:  CALL    5CE
0762:  MOV.B   W0L,806
....................       DebugAccumulator[DMAADCIndex] = Accumulator; 
0764:  MOV     #2,W4
0766:  CLR.B   9
0768:  MOV     1254,W0
076A:  MOV     1256,W1
076C:  INC     W4,W4
076E:  DEC     W4,W4
0770:  BRA     Z,778
0772:  SL      W0,W0
0774:  RLC     W1,W1
0776:  BRA     76E
0778:  MOV     #D10,W4
077A:  ADD     W0,W4,W5
077C:  MOV     #910,W4
077E:  MOV     [W4++],[W5++]
0780:  MOV     [W4++],[W5++]
....................       DigitizedData[DMAADCIndex] = ConversionValue; 
0782:  MOV     #2,W4
0784:  CLR.B   9
0786:  MOV     1254,W0
0788:  MOV     1256,W1
078A:  INC     W4,W4
078C:  DEC     W4,W4
078E:  BRA     Z,796
0790:  SL      W0,W0
0792:  RLC     W1,W1
0794:  BRA     78C
0796:  MOV     #914,W4
0798:  ADD     W0,W4,W5
079A:  MOV     806,W0
079C:  MOV.B   W0L,[W5+#0]
079E:  MOV.B   #0,W0L
07A0:  MOV.B   W0L,[W5+#1]
07A2:  MOV.B   #0,W0L
07A4:  MOV.B   W0L,[W5+#2]
07A6:  MOV.B   #0,W0L
07A8:  MOV.B   W0L,[W5+#3]
....................    } 
....................     
....................     if (CurrentIndex == 0) 
07AA:  CP0     11B4
07AC:  BRA     NZ,7BA
07AE:  CP0     11B6
07B0:  BRA     NZ,7BA
....................    { 
....................      CurrentIndex = COEF_LENGTH - 1; 
07B2:  MOV     #3F,W4
07B4:  MOV     W4,11B4
07B6:  CLR     11B6
....................    } 
07B8:  BRA     7C0
....................    else 
....................    { 
....................      CurrentIndex--; 
07BA:  DEC     11B4
07BC:  BTSS.B  42.0
07BE:  DEC     11B6
....................    }  
07C0:  MOV     [--W15],W6
07C2:  MOV     [--W15],W5
07C4:  RETURN  
.................... } 
....................  
.................... void NormalizeData(void) 
*
09D6:  MOV     W5,[W15++]
09D8:  MOV     W6,[W15++]
09DA:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
09DC:  MOV     11BE,W4
09DE:  CP      W4,#0
09E0:  BRA     GTU,B80
09E2:  BRA     NC,9EC
09E4:  MOV     11BC,W4
09E6:  MOV     #BB8,W3
09E8:  CP      W3,W4
09EA:  BRA     LEU,B80
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
09EC:  PUSH    A14
09EE:  POP     110C
09F0:  PUSH    A16
09F2:  POP     110E
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
09F4:  PUSH    A14
09F6:  POP     1110
09F8:  PUSH    A16
09FA:  POP     1112
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
09FC:  PUSH    4080
09FE:  POP     90A
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A00:  MOV     #41,W4
0A02:  MOV     W4,1254
0A04:  CLR     1256
0A06:  MOV     1256,W4
0A08:  CP      W4,#0
0A0A:  BRA     GTU,B30
0A0C:  BRA     NC,A16
0A0E:  MOV     1254,W4
0A10:  MOV     #FF,W3
0A12:  CP      W3,W4
0A14:  BRA     LEU,B30
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0A16:  MOV     #2,W4
0A18:  CLR.B   9
0A1A:  MOV     1254,W0
0A1C:  MOV     1256,W1
0A1E:  INC     W4,W4
0A20:  DEC     W4,W4
0A22:  BRA     Z,A2A
0A24:  SL      W0,W0
0A26:  RLC     W1,W1
0A28:  BRA     A20
0A2A:  MOV     #914,W4
0A2C:  ADD     W0,W4,W0
0A2E:  MOV     W0,W4
0A30:  MOV     #0,W3
0A32:  MOV     [W4++],[W3++]
0A34:  MOV     [W4++],[W3++]
0A36:  MOV     1112,W4
0A38:  CP      W4,W1
0A3A:  BRA     LT,A62
0A3C:  BRA     GT,A44
0A3E:  MOV     1110,W4
0A40:  CP      W4,W0
0A42:  BRA     LEU,A62
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0A44:  MOV     #2,W4
0A46:  CLR.B   9
0A48:  MOV     1254,W0
0A4A:  MOV     1256,W1
0A4C:  INC     W4,W4
0A4E:  DEC     W4,W4
0A50:  BRA     Z,A58
0A52:  SL      W0,W0
0A54:  RLC     W1,W1
0A56:  BRA     A4E
0A58:  MOV     #914,W4
0A5A:  ADD     W0,W4,W0
0A5C:  MOV     #1110,W4
0A5E:  MOV     [W0++],[W4++]
0A60:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0A62:  MOV     #2,W4
0A64:  CLR.B   9
0A66:  MOV     1254,W0
0A68:  MOV     1256,W1
0A6A:  INC     W4,W4
0A6C:  DEC     W4,W4
0A6E:  BRA     Z,A76
0A70:  SL      W0,W0
0A72:  RLC     W1,W1
0A74:  BRA     A6C
0A76:  MOV     #914,W4
0A78:  ADD     W0,W4,W0
0A7A:  MOV     W0,W4
0A7C:  MOV     #0,W3
0A7E:  MOV     [W4++],[W3++]
0A80:  MOV     [W4++],[W3++]
0A82:  MOV     110E,W4
0A84:  CP      W4,W1
0A86:  BRA     GT,AAE
0A88:  BRA     LT,A90
0A8A:  MOV     110C,W4
0A8C:  CP      W4,W0
0A8E:  BRA     C,AAE
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0A90:  MOV     #2,W4
0A92:  CLR.B   9
0A94:  MOV     1254,W0
0A96:  MOV     1256,W1
0A98:  INC     W4,W4
0A9A:  DEC     W4,W4
0A9C:  BRA     Z,AA4
0A9E:  SL      W0,W0
0AA0:  RLC     W1,W1
0AA2:  BRA     A9A
0AA4:  MOV     #914,W4
0AA6:  ADD     W0,W4,W0
0AA8:  MOV     #110C,W4
0AAA:  MOV     [W0++],[W4++]
0AAC:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0AAE:  MOV     #1,W4
0AB0:  CLR.B   9
0AB2:  MOV     1254,W0
0AB4:  MOV     1256,W1
0AB6:  INC     W4,W4
0AB8:  DEC     W4,W4
0ABA:  BRA     Z,AC2
0ABC:  SL      W0,W0
0ABE:  RLC     W1,W1
0AC0:  BRA     AB8
0AC2:  MOV     #4000,W4
0AC4:  ADD     W0,W4,W0
0AC6:  MOV     W0,W4
0AC8:  MOV     [W4],W0
0ACA:  MOV     90A,W4
0ACC:  CP      W4,W0
0ACE:  BRA     LEU,AEC
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0AD0:  MOV     #1,W4
0AD2:  CLR.B   9
0AD4:  MOV     1254,W0
0AD6:  MOV     1256,W1
0AD8:  INC     W4,W4
0ADA:  DEC     W4,W4
0ADC:  BRA     Z,AE4
0ADE:  SL      W0,W0
0AE0:  RLC     W1,W1
0AE2:  BRA     ADA
0AE4:  MOV     #4000,W4
0AE6:  ADD     W0,W4,W0
0AE8:  MOV     [W0],[W15++]
0AEA:  POP     90A
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0AEC:  MOV     #2,W4
0AEE:  CLR.B   9
0AF0:  MOV     1254,W0
0AF2:  MOV     1256,W1
0AF4:  INC     W4,W4
0AF6:  DEC     W4,W4
0AF8:  BRA     Z,B00
0AFA:  SL      W0,W0
0AFC:  RLC     W1,W1
0AFE:  BRA     AF6
0B00:  MOV     #914,W4
0B02:  ADD     W0,W4,W0
0B04:  MOV     W0,W4
0B06:  MOV     #0,W3
0B08:  MOV     [W4++],[W3++]
0B0A:  MOV     [W4++],[W3++]
0B0C:  CLR     W3
0B0E:  BTSC    W1.F
0B10:  SETM    W3
0B12:  MOV     W3,W2
0B14:  ADD     1114
0B16:  MOV     W1,W0
0B18:  ADDC    1116,W0
0B1A:  MOV     W0,1116
0B1C:  MOV     1118,W4
0B1E:  ADDC    W2,W4,W0
0B20:  MOV     W0,1118
0B22:  MOV     111A,W4
0B24:  ADDC    W3,W4,W0
0B26:  MOV     W0,111A
0B28:  INC     1254
0B2A:  BTSC.B  42.1
0B2C:  INC     1256
0B2E:  BRA     A06
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0B30:  MOV     110C,W4
0B32:  MOV     1110,W3
0B34:  SUB     W4,W3,W0
0B36:  MOV     110E,W4
0B38:  MOV     1112,W3
0B3A:  SUBB    W4,W3,W1
0B3C:  CALL    7C6
0B40:  MOV     W0,11A0
0B42:  MOV     W1,11A2
....................       AverageMultiplier = (255.0/ AverageDivider); 
0B44:  MOV     #0,W0
0B46:  MOV     #437F,W1
0B48:  MOV     11A0,W2
0B4A:  MOV     11A2,W3
0B4C:  CALL    814
0B50:  MOV     W0,11A4
0B52:  MOV     W1,11A6
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0B54:  BCLR.B  43.0
0B56:  MOV     1114,W0
0B58:  MOV     1116,W1
0B5A:  MOV     1118,W2
0B5C:  MOV     111A,W3
0B5E:  MOV     #BF,W4
0B60:  MOV     #0,W5
0B62:  MOV     #0,W6
0B64:  MOV     #0,W7
0B66:  CALL    8DE
0B6A:  MOV     W0,1114
0B6C:  MOV     W1,1116
0B6E:  MOV     W2,1118
0B70:  MOV     W3,111A
....................        
....................       TriggerValue = InitialTriggerValue; 
0B72:  PUSH    90A
0B74:  POP     90C
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0B76:  MOV     #914,W1
0B78:  MOV     #0,W2
0B7A:  REPEAT  #1FD
0B7C:  CLR.B   [W1++]
....................    }   
0B7E:  BRA     BE8
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0B80:  PUSH    4080
0B82:  POP     90A
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0B84:  MOV     #41,W4
0B86:  MOV     W4,1258
0B88:  CLR     125A
0B8A:  MOV     125A,W4
0B8C:  CP      W4,#0
0B8E:  BRA     GTU,BE0
0B90:  BRA     NC,B9A
0B92:  MOV     1258,W4
0B94:  MOV     #FF,W3
0B96:  CP      W3,W4
0B98:  BRA     LEU,BE0
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0B9A:  MOV     #1,W4
0B9C:  CLR.B   9
0B9E:  MOV     1258,W0
0BA0:  MOV     125A,W1
0BA2:  INC     W4,W4
0BA4:  DEC     W4,W4
0BA6:  BRA     Z,BAE
0BA8:  SL      W0,W0
0BAA:  RLC     W1,W1
0BAC:  BRA     BA4
0BAE:  MOV     #4000,W4
0BB0:  ADD     W0,W4,W0
0BB2:  MOV     W0,W4
0BB4:  MOV     [W4],W0
0BB6:  MOV     90A,W4
0BB8:  CP      W4,W0
0BBA:  BRA     LEU,BD8
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0BBC:  MOV     #1,W4
0BBE:  CLR.B   9
0BC0:  MOV     1258,W0
0BC2:  MOV     125A,W1
0BC4:  INC     W4,W4
0BC6:  DEC     W4,W4
0BC8:  BRA     Z,BD0
0BCA:  SL      W0,W0
0BCC:  RLC     W1,W1
0BCE:  BRA     BC6
0BD0:  MOV     #4000,W4
0BD2:  ADD     W0,W4,W0
0BD4:  MOV     [W0],[W15++]
0BD6:  POP     90A
....................         }              
0BD8:  INC     1258
0BDA:  BTSC.B  42.1
0BDC:  INC     125A
0BDE:  BRA     B8A
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0BE0:  PUSH    90A
0BE2:  POP     90C
....................       ErrorCounter = 0;  
0BE4:  CLR     11BC
0BE6:  CLR     11BE
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0BE8:  CLR     11C0
0BEA:  CLR     11C2
....................    NormalizeFlag = 0; 
0BEC:  CLR.B   11C4
....................    CurrentIndex = 0; 
0BEE:  CLR     11B4
0BF0:  CLR     11B6
0BF2:  MOV     [--W15],W7
0BF4:  MOV     [--W15],W6
0BF6:  MOV     [--W15],W5
0BF8:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
.................... { 
....................     IndexType InputIndex = CurrentIndex; 
....................     IndexType CoefficentIndex = 0; 
....................     unsigned int Accumulator = 0; 
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
....................          { 
....................             InputIndex = 0; 
....................          } 
....................          else 
....................          { 
....................             InputIndex++; 
....................          } 
....................          CoefficentIndex++; 
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
....................        
....................     return ConversionValue;   
.................... } 
....................  
.................... void CommHandler(char UARTRX) 
0BFA:  MOV     W5,[W15++]
.................... { 
....................    switch (UARTRX) 
0BFC:  MOV.B   1254,W0L
0BFE:  CLR.B   1
0C00:  XOR     #2B,W0
0C02:  BRA     Z,C12
0C04:  XOR     #1,W0
0C06:  BRA     Z,C18
0C08:  XOR     #6E,W0
0C0A:  BRA     Z,C1C
0C0C:  XOR     #8,W0
0C0E:  BRA     Z,C2E
0C10:  BRA     CEA
....................    { 
....................       case '+': 
....................          HandShakeFlag = 1; 
0C12:  MOV.B   #1,W0L
0C14:  MOV.B   W0L,11C7
....................          break; 
0C16:  BRA     CEA
....................           
....................       case '*': 
....................          disable_interrupts(INT_TIMER1); 
0C18:  BCLR.B  94.3
....................          break; 
0C1A:  BRA     CEA
....................           
....................       case 'D': 
....................          enable_interrupts(INT_TIMER1);    
0C1C:  BSET.B  94.3
....................          setup_timer1(TMR_INTERNAL , TimerTicks); 
0C1E:  CLR     104
0C20:  PUSH    804
0C22:  POP     102
0C24:  MOV     #8000,W4
0C26:  MOV     W4,104
....................          HandshakeFlag = 1;   
0C28:  MOV.B   #1,W0L
0C2A:  MOV.B   W0L,11C7
....................          break;   
0C2C:  BRA     CEA
....................           
....................       case 'L': 
....................          disable_interrupts(INT_TIMER1); 
0C2E:  BCLR.B  94.3
....................          disable_interrupts(INT_RDA2); 
0C30:  BCLR.B  97.6
....................          disable_interrupts(GLOBAL);  
0C32:  BCLR.B  81.7
0C34:  MOV     #E0,W4
0C36:  MOV     W4,42
0C38:  BSET.B  81.7
....................           
....................          while (CSharpCoefficentRecieved != COEF_LENGTH) 
0C3A:  MOV     11A8,W4
0C3C:  XOR     #40,W4
0C3E:  BRA     NZ,C44
0C40:  CP0     11AA
0C42:  BRA     Z,CB0
....................          { 
....................             if (kbhit(SHARP)) 
0C44:  BTSS.B  232.0
0C46:  BRA     CAE
0C48:  PUSH    42
0C4A:  BCLR.B  81.7
0C4C:  SETM.B  42
0C4E:  BSET.B  81.7
....................             { 
....................                char CoefficentByte = fgetc(SHARP); 
0C50:  CALL    244
0C54:  BCLR.B  81.7
0C56:  POP     42
0C58:  BSET.B  81.7
0C5A:  MOV.B   W0L,1255
....................                 
....................                if (CoefficentByte == 'L') 
0C5C:  MOV     1254,W4
0C5E:  LSR     W4,#8,W4
0C60:  XOR.B   #4C,W4L
0C62:  BRA     NZ,C66
....................                { 
....................                   ; // Do nothing 
....................                }               
0C64:  BRA     CAE
....................                else if (NumberCSharpByteRecieved == 0) 
0C66:  CP0     11B8
0C68:  BRA     NZ,C7A
0C6A:  CP0     11BA
0C6C:  BRA     NZ,C7A
....................                { 
....................                   CSharpCoefficent[0] = CoefficentByte;  
0C6E:  MOV.B   1255,W0L
0C70:  MOV.B   W0L,908
....................                   NumberCSharpByteRecieved = 1; 
0C72:  MOV     #1,W4
0C74:  MOV     W4,11B8
0C76:  CLR     11BA
....................                }            
0C78:  BRA     CAE
....................                else 
....................                { 
....................                   CSharpCoefficent[1] = CoefficentByte; 
0C7A:  MOV.B   1255,W0L
0C7C:  MOV.B   W0L,909
....................                   NumberCSharpByteRecieved = 0; 
0C7E:  CLR     11B8
0C80:  CLR     11BA
....................                   ByteConversionResult = (unsigned int16)(CSharpCoefficent[1] << 8) | CSharpCoefficent[0]; 
0C82:  CLR.B   W6
0C84:  CLR.B   W5
0C86:  MOV     W5,W0
0C88:  IOR     908,W0
0C8A:  MOV     W0,90E
....................                   fir_coef[CSharpCoefficentRecieved] =  ByteConversionResult; 
0C8C:  MOV     #1,W4
0C8E:  CLR.B   9
0C90:  MOV     11A8,W0
0C92:  MOV     11AA,W1
0C94:  INC     W4,W4
0C96:  DEC     W4,W4
0C98:  BRA     Z,CA0
0C9A:  SL      W0,W0
0C9C:  RLC     W1,W1
0C9E:  BRA     C96
0CA0:  MOV     #11CA,W4
0CA2:  ADD     W0,W4,W5
0CA4:  MOV     90E,W4
0CA6:  MOV     W4,[W5+#0]
....................                   CSharpCoefficentRecieved++; 
0CA8:  INC     11A8
0CAA:  BTSC.B  42.1
0CAC:  INC     11AA
....................                } 
....................             } 
0CAE:  BRA     C3A
....................          } 
....................           
....................          switch (fir_coef[0]) 
0CB0:  MOV     11CA,W0
0CB2:  XOR     #D2,W0
0CB4:  BRA     Z,CC0
0CB6:  XOR     #FA,W0
0CB8:  BRA     Z,CC6
0CBA:  XOR     #149,W0
0CBC:  BRA     Z,CCC
0CBE:  BRA     CD2
....................          { 
....................          case 210: 
....................             TimerTicks = 53334; 
0CC0:  MOV     #D056,W4
0CC2:  MOV     W4,804
....................             break; 
0CC4:  BRA     CD6
....................          case 40: 
....................             TimerTicks = 53334; 
0CC6:  MOV     #D056,W4
0CC8:  MOV     W4,804
....................             break; 
0CCA:  BRA     CD6
.................... //!                  case -12: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
.................... //!                  case -9: 
.................... //!                     TimerTicks = 8000; 
.................... //!                     break; 
....................          case 353: 
....................             TimerTicks = 8000; 
0CCC:  MOV     #1F40,W4
0CCE:  MOV     W4,804
....................             break; 
0CD0:  BRA     CD6
....................          default:  
....................             TimerTicks = 8000; 
0CD2:  MOV     #1F40,W4
0CD4:  MOV     W4,804
....................          } 
....................           
....................          CSharpCoefficentRecieved = 0; 
0CD6:  CLR     11A8
0CD8:  CLR     11AA
....................          HandshakeFlag = 1; 
0CDA:  MOV.B   #1,W0L
0CDC:  MOV.B   W0L,11C7
....................          enable_interrupts(INT_RDA2); 
0CDE:  BSET.B  97.6
....................          enable_interrupts(INT_TIMER1); 
0CE0:  BSET.B  94.3
....................          enable_interrupts(GLOBAL); 
0CE2:  BCLR.B  81.7
0CE4:  CLR     42
0CE6:  BSET.B  81.7
....................          break; 
0CE8:  BRA     CEA
....................           
....................       default : 
....................          ; // Do nothing  
....................        
....................    } 
....................     
....................    UARTRX = '\0'; 
0CEA:  CLR.B   1254
....................    UARTRXFlag = 0; 
0CEC:  CLR.B   11C5
0CEE:  MOV     [--W15],W5
0CF0:  RETURN  
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F7   PUT128 NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
