CCS PCD C Compiler, Version 5.008, 5967               31-Oct-22 20:16

               Filename:   C:\Users\Moff - it\Desktop\Education\Fall 2022\ECE 522\Final Project\main.lst

               ROM used:   4018 bytes (9%)
                           Largest free fragment is 40014
               RAM used:   3720 (23%) at main() level
                           3768 (23%) worst case
               Stack used: 66 locations (50 in main + 16 for interrupts)
               Stack size: 30

*
0000:  GOTO    C8A
*
001A:  DATA    44,02,00
001C:  DATA    00,02,00
*
0030:  DATA    24,02,00
*
0050:  DATA    92,02,00
.................... #include "main.h" 
.................... #ifndef MAIN_H 
.................... #define MAIN_H 
....................  
.................... #include <33FJ64MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ64MC802 device //////////////// 
.................... #device DSPIC33FJ64MC802 
*
02BC:  MOV     W5,[W15++]
02BE:  MOV     #C,W5
02C0:  REPEAT  #3
02C2:  MOV     [W5++],[W15++]
02C4:  MUL.UU  W0,W2,W4
02C6:  BTSS    W3.F
02C8:  BRA     2CE
02CA:  MUL.SS  W0,W3,W6
02CC:  BRA     2D0
02CE:  MUL.UU  W0,W3,W6
02D0:  BCLR.B  42.0
02D2:  ADD     W6,W5,W5
02D4:  ADDC    W7,#0,W8
02D6:  BTSS    W1.F
02D8:  BRA     2DE
02DA:  MUL.SS  W1,W2,W6
02DC:  BRA     2E0
02DE:  MUL.UU  W1,W2,W6
02E0:  ADDC    W6,W5,W5
02E2:  ADDC    W7,W8,W8
02E4:  ADDC    #0,W9
02E6:  MUL.SS  W1,W3,W6
02E8:  ADDC    W6,W8,W8
02EA:  ADDC    W9,W7,W7
02EC:  MOV     W7,W3
02EE:  MOV     W8,W2
02F0:  MOV     W5,W1
02F2:  MOV     W4,W0
02F4:  MOV     #12,W5
02F6:  REPEAT  #3
02F8:  MOV     [--W15],[W5--]
02FA:  MOV     [--W15],W5
02FC:  RETURN  
02FE:  MOV     W5,[W15++]
0300:  MOV     #C,W5
0302:  REPEAT  #3
0304:  MOV     [W5++],[W15++]
0306:  MOV     W0,W4
0308:  MOV     W1,W5
030A:  MOV     W2,W6
030C:  MOV     W3,W7
030E:  CLR     W0
0310:  CLR     W1
0312:  CLR     W2
0314:  CLR     W3
0316:  BCLR    W8.0
0318:  BTSS    W7.F
031A:  BRA     326
031C:  BSET    W6.0
031E:  NEG     W4,W4
0320:  COM     W5,W5
0322:  COM     W6,W6
0324:  COM     W7,W7
0326:  XOR     W4,W5,W9
0328:  BRA     NZ,32E
032A:  XOR     W6,W7,W9
032C:  BRA     Z,356
032E:  MOV     #D6,W1
0330:  BTSC    W2.7
0332:  BRA     346
0334:  BCLR.B  42.0
0336:  RLC     W4,W4
0338:  RLC     W5,W5
033A:  RLC     W6,W6
033C:  RLC     W7,W7
033E:  RLC     W0,W0
0340:  RLC     W2,W2
0342:  DEC     W1,W1
0344:  BRA     NZ,330
0346:  SWAP    W1
0348:  BCLR.B  42.0
034A:  RRC     W1,W1
034C:  BCLR    W1.F
034E:  BCLR    W2.7
0350:  XOR.B   W2L,W1L,W1L
0352:  BTSC    W6.0
0354:  BSET    W1.F
0356:  MOV     #12,W5
0358:  REPEAT  #3
035A:  MOV     [--W15],[W5--]
035C:  MOV     [--W15],W5
035E:  RETURN  
0360:  MOV     W5,[W15++]
0362:  MOV     #C,W5
0364:  REPEAT  #4
0366:  MOV     [W5++],[W15++]
0368:  MOV     W0,W4
036A:  MOV     W1,W5
036C:  MOV     W3,W7
036E:  MOV     W2,W6
0370:  BCLR.B  42.0
0372:  BCLR.B  42.1
0374:  RLC     W1,W1
0376:  SWAP    W1
0378:  AND     #FF,W1
037A:  CP0     W1
037C:  BRA     Z,414
037E:  BCLR.B  42.0
0380:  BCLR.B  42.1
0382:  RLC     W3,W3
0384:  SWAP    W3
0386:  AND     #FF,W3
0388:  CP0     W3
038A:  BRA     Z,414
038C:  ZE      W0,W0
038E:  ADD.B   W3L,W1L,W0L
0390:  BRA     C,39A
0392:  SUB     #7F,W0
0394:  BRA     Z,414
0396:  BRA     NC,414
0398:  BRA     39E
039A:  ADD.B   #81,W0L
039C:  BRA     C,414
039E:  XOR     W5,W7,W10
03A0:  BCLR.B  42.0
03A2:  BCLR.B  42.1
03A4:  AND     #FF,W5
03A6:  BSET    W5.7
03A8:  BCLR.B  42.0
03AA:  AND     #FF,W7
03AC:  BSET    W7.7
03AE:  MUL.UU  W4,W6,W2
03B0:  MUL.UU  W5,W6,W8
03B2:  ADDC    W8,W3,W3
03B4:  MOV     W9,W1
03B6:  BTSC.B  42.0
03B8:  INC     W1,W1
03BA:  BCLR.B  42.0
03BC:  MUL.UU  W7,W4,W8
03BE:  ADDC    W8,W3,W3
03C0:  ADDC    W9,W1,W1
03C2:  MUL.UU  W5,W7,W8
03C4:  ADDC    W8,W1,W1
03C6:  INC     W0,W0
03C8:  CP0     W1
03CA:  BTSC.B  42.1
03CC:  BRA     3D0
03CE:  BRA     3D6
03D0:  CP0     W3
03D2:  BTSC.B  42.1
03D4:  BRA     3E0
03D6:  BTSC    W1.F
03D8:  BRA     3E0
03DA:  RLC     W3,W3
03DC:  RLC     W1,W1
03DE:  DEC     W0,W0
03E0:  MOV     W1,W2
03E2:  BCLR.B  42.0
03E4:  BTSS    W3.7
03E6:  BRA     3FA
03E8:  MOV     #FF00,W7
03EA:  AND     W3,W7,W3
03EC:  ADD     #100,W3
03EE:  ADDC    W2,#0,W2
03F0:  CP0     W2
03F2:  BRA     NZ,3FA
03F4:  CP0     W3
03F6:  BRA     NZ,3FA
03F8:  INC     W0,W0
03FA:  SWAP    W0
03FC:  BCLR.B  42.0
03FE:  BCLR.B  42.1
0400:  RRC     W0,W1
0402:  BTSC    W10.F
0404:  BSET    W1.F
0406:  BCLR    W2.F
0408:  SWAP    W2
040A:  XOR.B   W2L,W1L,W1L
040C:  SWAP    W3
040E:  MOV.B   W3L,W2L
0410:  MOV     W2,W0
0412:  BRA     41A
0414:  MOV     #0,W0
0416:  MOV     #0,W1
0418:  BRA     41A
041A:  MOV     #14,W5
041C:  REPEAT  #4
041E:  MOV     [--W15],[W5--]
0420:  MOV     [--W15],W5
0422:  RETURN  
0424:  MOV     W5,[W15++]
0426:  MOV     #C,W5
0428:  REPEAT  #3
042A:  MOV     [W5++],[W15++]
042C:  CLR     W9
042E:  MOV     #8000,W8
0430:  BTSC.B  43.0
0432:  XOR     W8,W3,W3
0434:  CP0     W0
0436:  BRA     NZ,43E
0438:  MOV     #7FFF,W10
043A:  AND     W1,W10,W10
043C:  BTSS.B  42.1
043E:  MOV     W1,W10
0440:  XOR     W3,W10,W11
0442:  MOV     W1,W6
0444:  MOV     W3,W7
0446:  MOV     W3,W12
0448:  BCLR.B  42.1
044A:  BCLR.B  42.0
044C:  RLC     W6,W6
044E:  SWAP    W6
0450:  AND     #FF,W6
0452:  CP0     W6
0454:  BRA     Z,598
0456:  BCLR.B  42.1
0458:  BCLR.B  42.0
045A:  RLC     W7,W7
045C:  SWAP    W7
045E:  AND     #FF,W7
0460:  CP0     W7
0462:  BRA     Z,5A2
0464:  BCLR.B  42.1
0466:  BCLR.B  42.0
0468:  CP      W7,W6
046A:  BRA     Z,5A4
046C:  BRA     N,5B4
046E:  BCLR    W9.0
0470:  BSET    W9.1
0472:  SUB     W7,W6,W8
0474:  MOV     W7,W6
0476:  AND     #FF,W1
0478:  BSET    W1.7
047A:  AND     #FF,W3
047C:  BSET    W3.7
047E:  MOV     #28,W7
0480:  CP      W7,W8
0482:  BRA     N,4A6
0484:  BCLR.B  42.1
0486:  BCLR.B  42.0
0488:  RRC     W1,W1
048A:  RRC     W0,W0
048C:  DEC     W8,W8
048E:  BRA     NZ,484
0490:  BRA     4AC
0492:  MOV     #28,W7
0494:  CP      W7,W8
0496:  BRA     N,4AA
0498:  BCLR.B  42.1
049A:  BCLR.B  42.0
049C:  RRC     W3,W3
049E:  RRC     W2,W2
04A0:  DEC     W8,W8
04A2:  BRA     NZ,498
04A4:  BRA     4C4
04A6:  MOV     W2,W0
04A8:  MOV     W3,W1
04AA:  BRA     532
04AC:  BTSS    W11.F
04AE:  BRA     4D2
04B0:  BTSC    W9.4
04B2:  MOV     W12,W11
04B4:  NEG     W0,W0
04B6:  BRA     Z,4BC
04B8:  COM.B   W1L,W1L
04BA:  BRA     4BE
04BC:  NEG     W1,W1
04BE:  BTSC    W9.4
04C0:  BRA     518
04C2:  BRA     4D2
04C4:  BTSS    W11.F
04C6:  BRA     4D2
04C8:  NEG     W2,W2
04CA:  BRA     Z,4D0
04CC:  COM.B   W3L,W3L
04CE:  BRA     4D2
04D0:  NEG     W3,W3
04D2:  AND     #FF,W5
04D4:  BCLR.B  42.1
04D6:  BCLR.B  42.0
04D8:  ADD     W0,W2,W0
04DA:  ADDC.B  W1L,W3L,W1L
04DC:  BTSC.B  42.0
04DE:  BSET    W9.3
04E0:  BTSC    W9.0
04E2:  BRA     4F6
04E4:  BTSC    W9.1
04E6:  BRA     4EA
04E8:  BRA     500
04EA:  BTSC    W11.F
04EC:  BRA     518
04EE:  BTSC    W9.3
04F0:  BRA     544
04F2:  BSET    W9.6
04F4:  BRA     532
04F6:  BTSC    W11.F
04F8:  BRA     518
04FA:  BTSC    W9.3
04FC:  BRA     544
04FE:  BRA     532
0500:  BCLR    W9.2
0502:  BTSC    W11.F
0504:  BRA     50E
0506:  MOV     W10,W11
0508:  BTSC    W9.3
050A:  BRA     544
050C:  BRA     57A
050E:  BSET    W9.4
0510:  XOR.B   #80,W1L
0512:  BTSC    W1.7
0514:  BRA     4B0
0516:  MOV     W10,W11
0518:  AND     #FF,W1
051A:  IOR      W0,  W1,W7
051C:  BRA     Z,532
051E:  BTSC    W1.7
0520:  BRA     532
0522:  BCLR.B  42.1
0524:  BCLR.B  42.0
0526:  RLC     W0,W0
0528:  RLC     W1,W1
052A:  DEC     W6,W6
052C:  BTSC.B  42.1
052E:  BRA     592
0530:  BRA     51E
0532:  BTSC    W9.0
0534:  MOV     W10,W11
0536:  BTSC    W9.1
0538:  MOV     W12,W11
053A:  BTSS    W9.5
053C:  BRA     572
053E:  BTSC    W10.F
0540:  BSET    W0.8
0542:  BRA     57A
0544:  BSET.B  42.0
0546:  RRC.B   W1L,W1L
0548:  RRC     W0,W0
054A:  BTSC.B  42.0
054C:  BSET    W9.5
054E:  INC     W6,W6
0550:  BRA     Z,592
0552:  BTSS    W9.5
0554:  BRA     566
0556:  INC     W0,W0
0558:  BRA     NZ,566
055A:  INC.B   W1L,W1L
055C:  BRA     NZ,566
055E:  RRC.B   W1L,W1L
0560:  RRC     W0,W0
0562:  INC     W6,W6
0564:  BRA     Z,592
0566:  BTSC    W9.0
0568:  MOV     W10,W11
056A:  BTSC    W9.1
056C:  MOV     W12,W11
056E:  BTSC.B  42.1
0570:  BRA     592
0572:  BTSC    W9.6
0574:  MOV     W10,W11
0576:  BTSC    W9.7
0578:  MOV     W12,W11
057A:  IOR      W0,  W1,W2
057C:  BRA     Z,5C4
057E:  BCLR    W1.7
0580:  SWAP    W6
0582:  BCLR.B  42.1
0584:  BCLR.B  42.0
0586:  RRC     W6,W6
0588:  XOR     W6,W1,W1
058A:  BSET    W1.F
058C:  BTSS    W11.F
058E:  BCLR    W1.F
0590:  BRA     5C4
0592:  MOV     #0,W0
0594:  MOV     #0,W1
0596:  BRA     5C4
0598:  BTSC    W10.F
059A:  XOR     W8,W3,W3
059C:  MOV     W2,W0
059E:  MOV     W3,W1
05A0:  BRA     5C4
05A2:  BRA     5C4
05A4:  AND     #FF,W3
05A6:  BSET    W3.7
05A8:  AND     #FF,W1
05AA:  BSET    W1.7
05AC:  BTSC    W11.F
05AE:  BCLR    W3.7
05B0:  BSET    W9.2
05B2:  BRA     4C4
05B4:  SUB     W6,W7,W8
05B6:  AND     #FF,W1
05B8:  BSET    W1.7
05BA:  AND     #FF,W3
05BC:  BSET    W3.7
05BE:  BCLR    W9.1
05C0:  BSET    W9.0
05C2:  BRA     492
05C4:  MOV     #12,W5
05C6:  REPEAT  #3
05C8:  MOV     [--W15],[W5--]
05CA:  MOV     [--W15],W5
05CC:  RETURN  
05CE:  MOV     W0,W2
05D0:  MOV     W1,W3
05D2:  MOV.B   W1L,W0L
05D4:  SWAP    W0
05D6:  BSET    W0.F
05D8:  RLC     W1,W1
05DA:  SWAP    W1
05DC:  ZE      W1,W1
05DE:  MOV     #8E,W4
05E0:  SUB.B   W4L,W1L,W1L
05E2:  BRA     Z,5F0
05E4:  CP0     W0
05E6:  BRA     Z,5F0
05E8:  BCLR.B  42.0
05EA:  RRC     W0,W0
05EC:  DEC     W1,W1
05EE:  BRA     NZ,5E4
05F0:  BTSS    W3.F
05F2:  BRA     5F8
05F4:  NEG     W0,W0
05F6:  BRA     5F8
05F8:  RETURN  
*
0856:  MOV     W5,[W15++]
0858:  MOV     W6,[W15++]
085A:  MOV     W0,W4
085C:  MOV     W1,W5
085E:  CLR     W0
0860:  CLR     W1
0862:  BCLR    W6.0
0864:  BTSS    W5.F
0866:  BRA     874
0868:  BSET    W6.0
086A:  NEG     W4,W4
086C:  BRA     Z,872
086E:  COM     W5,W5
0870:  BRA     874
0872:  NEG     W5,W5
0874:  IOR      W4,  W5,W3
0876:  BRA     Z,89E
0878:  CLR     W2
087A:  MOV     #B6,W1
087C:  BTSC    W2.7
087E:  BRA     88E
0880:  BCLR.B  42.0
0882:  RLC     W4,W4
0884:  RLC     W5,W5
0886:  RLC     W0,W0
0888:  RLC     W2,W2
088A:  DEC     W1,W1
088C:  BRA     NZ,87C
088E:  SWAP    W1
0890:  BCLR.B  42.0
0892:  RRC     W1,W1
0894:  BCLR    W1.F
0896:  BCLR    W2.7
0898:  XOR.B   W2L,W1L,W1L
089A:  BTSC    W6.0
089C:  BSET    W1.F
089E:  MOV     [--W15],W6
08A0:  MOV     [--W15],W5
08A2:  RETURN  
08A4:  MOV     W5,[W15++]
08A6:  MOV     #C,W5
08A8:  REPEAT  #4
08AA:  MOV     [W5++],[W15++]
08AC:  CLR     W9
08AE:  XOR     W1,W3,W9
08B0:  MOV     W1,W6
08B2:  MOV     W0,W5
08B4:  MOV     W3,W8
08B6:  MOV     W2,W7
08B8:  RLC     W1,W1
08BA:  SWAP    W1
08BC:  ZE      W1,W1
08BE:  CP0     W1
08C0:  BRA     Z,95E
08C2:  RLC     W3,W3
08C4:  SWAP    W3
08C6:  ZE      W3,W3
08C8:  CP0     W3
08CA:  BRA     Z,95E
08CC:  CLR     W0
08CE:  SUB.B   W1L,W3L,W0L
08D0:  BRA     NC,8D8
08D2:  ADD.B   #7F,W0L
08D4:  BRA     C,95E
08D6:  BRA     8DE
08D8:  SUB.B   #81,W0L
08DA:  BRA     NC,95E
08DC:  BRA     Z,95E
08DE:  MOV     W5,W1
08E0:  MOV     W6,W2
08E2:  BSET    W2.7
08E4:  AND     #FF,W2
08E6:  AND     #FF,W8
08E8:  BSET    W8.7
08EA:  MOV     #19,W10
08EC:  CLR     W3
08EE:  CLR     W4
08F0:  SUB     W1,W7,W1
08F2:  SUBB    W2,W8,W2
08F4:  BRA     N,8FA
08F6:  BRA     C,900
08F8:  BRA     NZ,902
08FA:  ADD     W1,W7,W1
08FC:  ADDC    W2,W8,W2
08FE:  BRA     902
0900:  BSET    W4.0
0902:  DEC     W10,W10
0904:  BRA     Z,914
0906:  BCLR.B  42.0
0908:  RLC     W1,W1
090A:  RLC     W2,W2
090C:  BCLR.B  42.0
090E:  RLC     W4,W4
0910:  RLC     W3,W3
0912:  BRA     8F0
0914:  CLR     W10
0916:  BTSC    W3.8
0918:  BRA     91C
091A:  BRA     928
091C:  BCLR.B  42.0
091E:  RRC     W3,W3
0920:  BCLR    W3.7
0922:  RRC     W4,W4
0924:  RLC     W10,W10
0926:  BRA     92C
0928:  DEC     W0,W0
092A:  BRA     Z,95E
092C:  BTSC    W10.F
092E:  BRA     NC,93A
0930:  RLC     W1,W1
0932:  RLC     W2,W2
0934:  SUB     W1,W7,W1
0936:  SUBB    W2,W8,W2
0938:  BRA     NC,94C
093A:  INC     W4,W4
093C:  BRA     NZ,94C
093E:  INC     W3,W3
0940:  BRA     NZ,94C
0942:  INC     W0,W0
0944:  BRA     Z,95E
0946:  BRA     94C
0948:  DEC     W0,W0
094A:  BRA     Z,95E
094C:  SWAP    W0
094E:  RRC     W0,W1
0950:  BSET    W1.F
0952:  BTSS    W9.F
0954:  BCLR    W1.F
0956:  BCLR    W3.7
0958:  XOR.B   W3L,W1L,W1L
095A:  MOV     W4,W0
095C:  BRA     964
095E:  MOV     #0,W0
0960:  MOV     #0,W1
0962:  BRA     964
0964:  MOV     #14,W5
0966:  REPEAT  #4
0968:  MOV     [--W15],[W5--]
096A:  MOV     [--W15],W5
096C:  RETURN  
096E:  MOV     W8,[W15++]
0970:  MOV     #12,W8
0972:  REPEAT  #4
0974:  MOV     [W8++],[W15++]
0976:  MOV     #0,W9
0978:  BTSC.B  43.0
097A:  MOV     #1,W9
097C:  MOV     W9,[W15++]
097E:  CLR     W8
0980:  CLR     W9
0982:  CLR     W10
0984:  CLR     W11
0986:  CLR     W12
0988:  CLR     W13
098A:  MOV     #E,W8
098C:  MOV     #0,W9
098E:  LNK     #10
0990:  MOV     W12,[W14+W8]
0992:  DEC2    W8,W8
0994:  BRA     NN,990
0996:  XOR     W4,W5,W8
0998:  BRA     NZ,99E
099A:  XOR     W6,W7,W8
099C:  BRA     Z,A2E
099E:  CLR     W8
09A0:  CLR     W13
09A2:  MOV     W13,[W15++]
09A4:  BTSS    W3.F
09A6:  BRA     9BC
09A8:  MOV     [--W15],W13
09AA:  BSET    W13.F
09AC:  MOV     W13,[W15++]
09AE:  COM     W3,W3
09B0:  COM     W2,W2
09B2:  COM     W1,W1
09B4:  NEG     W0,W0
09B6:  ADDC    W1,#0,W1
09B8:  ADDC    W2,#0,W2
09BA:  ADDC    W3,#0,W3
09BC:  BTSS    W7.F
09BE:  BRA     9D4
09C0:  MOV     [--W15],W13
09C2:  BTG     W13.F
09C4:  MOV     W13,[W15++]
09C6:  COM     W7,W7
09C8:  COM     W6,W6
09CA:  COM     W5,W5
09CC:  NEG     W4,W4
09CE:  ADDC    W5,#0,W5
09D0:  ADDC    W6,#0,W6
09D2:  ADDC    W7,#0,W7
09D4:  MOV     #40,W13
09D6:  BCLR.B  42.0
09D8:  RLC     W0,W0
09DA:  RLC     W1,W1
09DC:  RLC     W2,W2
09DE:  RLC     W3,W3
09E0:  RLC     W8,W8
09E2:  RLC     W9,W9
09E4:  RLC     W10,W10
09E6:  RLC     W11,W11
09E8:  CP      W11,W7
09EA:  BRA     NZ,9F6
09EC:  CPB     W10,W6
09EE:  BRA     NZ,9F6
09F0:  CPB     W9,W5
09F2:  BRA     NZ,9F6
09F4:  CPB     W8,W4
09F6:  BRA     NC,A02
09F8:  SUB     W8,W4,W8
09FA:  SUBB    W9,W5,W9
09FC:  SUBB    W10,W6,W10
09FE:  SUBB    W11,W7,W11
0A00:  BSET.B  42.0
0A02:  MOV     W8,[W14]
0A04:  MOV     W9,[W14+#2]
0A06:  MOV     W10,[W14+#4]
0A08:  MOV     W11,[W14+#6]
0A0A:  MOV     [W14+#8],W8
0A0C:  MOV     [W14+#A],W9
0A0E:  MOV     [W14+#C],W10
0A10:  MOV     [W14+#E],W11
0A12:  RLC     W8,W8
0A14:  RLC     W9,W9
0A16:  RLC     W10,W10
0A18:  RLC     W11,W11
0A1A:  MOV     W8,[W14+#8]
0A1C:  MOV     W9,[W14+#A]
0A1E:  MOV     W10,[W14+#C]
0A20:  MOV     W11,[W14+#E]
0A22:  MOV     [W14],W8
0A24:  MOV     [W14+#2],W9
0A26:  MOV     [W14+#4],W10
0A28:  MOV     [W14+#6],W11
0A2A:  DEC     W13,W13
0A2C:  BRA     NZ,9D6
0A2E:  MOV     [W14+#8],W0
0A30:  MOV     [W14+#A],W1
0A32:  MOV     [W14+#C],W2
0A34:  MOV     [W14+#E],W3
0A36:  MOV     [--W15],W13
0A38:  BTSS    W13.F
0A3A:  BRA     A4A
0A3C:  COM     W3,W3
0A3E:  COM     W2,W2
0A40:  COM     W1,W1
0A42:  NEG     W0,W0
0A44:  ADDC    W1,#0,W1
0A46:  ADDC    W2,#0,W2
0A48:  ADDC    W3,#0,W3
0A4A:  ULNK    
0A4C:  BRA     A4E
0A4E:  MOV     [--W15],W9
0A50:  CP0     W9
0A52:  BRA     Z,A5C
0A54:  MOV     W8,W0
0A56:  MOV     W9,W1
0A58:  MOV     W10,W2
0A5A:  MOV     W11,W3
0A5C:  MOV     #1A,W8
0A5E:  REPEAT  #4
0A60:  MOV     [--W15],[W8--]
0A62:  MOV     [--W15],W8
0A64:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(internal=32MHz) 
.................... //#use delay(internal=40MHz) 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES FRC_PLL 
....................  
.................... #pin_select U2TX=PIN_B6 
.................... #pin_select U2RX=PIN_B7 
.................... #USE RS232(UART2, BAUD = 115200, PARITY = N, BITS = 8, STOP = 1, TIMEOUT = 500,  stream = SHARP)) // RECEIVE_BUFFER=255, TRANSMIT_BUFFER=255, TXISR, 
*
0270:  MOV     W5,[W15++]
0272:  MOV     #4B00,W5
0274:  REPEAT  #19E
0276:  NOP     
0278:  DEC     W5,W5
027A:  BRA     NZ,282
027C:  CLR     85A
027E:  MOV     #0,W0
0280:  BRA     28E
0282:  BTSS.B  232.0
0284:  BRA     274
0286:  PUSH    232
0288:  POP     85A
028A:  MOV     236,W0
028C:  BCLR.B  232.1
028E:  MOV     [--W15],W5
0290:  RETURN  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define BUFFER_SIZE 256 
.................... #define COEF_LENGTH 64 
.................... #define LOADER_PAGES 50 
.................... #define ADC_MAX_DATA_VALUE 255 
.................... #define LED_PIN PIN_B14    
....................  
.................... typedef unsigned int32 IndexType; 
.................... typedef unsigned int8 FlagType; 
....................  
.................... const unsigned int8 ADC_DMA_CHANNEL = 0; 
.................... const unsigned int8 UART_TX_DMA_CHANNEL = 1; 
.................... const IndexType NumberOfDigitizationRequired = BUFFER_SIZE / COEF_LENGTH; 
....................  
.................... unsigned int16 TimerTicks = 0; 
....................  
.................... unsigned int8 ConversionValue; // normalized value 
.................... unsigned int8 AnalogData[BUFFER_SIZE]; // input array 
....................  
.................... unsigned int8 CSharpCoefficent[2];          // array to hold byte data of coefficents 
....................  
.................... unsigned int16 InitialTriggerValue = 0; // used for initail trigger value 
.................... unsigned int16 TriggerValue = 0; // used for initail trigger value 
....................  
.................... signed int16 ByteConversionResult = 0;     // result of byte convertion 
....................  
.................... signed int32 Accumulator = 0; // accumulator of the output value in the difference equation calculation 
.................... signed int32 DigitizedData[BUFFER_SIZE];   // output array 
.................... signed int32 DebugAccumulator[BUFFER_SIZE];   // output array 
.................... signed int32 MaxAnalogValue = 0; // use for normalization 
.................... signed int32 MinAnalogValue = 0; // use for normalization 
....................  
.................... signed int64 AverageAnalogValue = 0; // use for normalization 
....................  
.................... signed int16  InputSamples[COEF_LENGTH]; // array used as a circular buffer for the input samples 
....................  
.................... float OutputValue;          // holds the current output value 
.................... float AverageDivider = 0; // use for normalization 
.................... float AverageMultiplier = 0;    // use for normalization 
....................  
.................... char UARTRX; // data in 
....................  
.................... IndexType CSharpCoefficentRecieved = 0;    // counter of coefficents recieved from c# 
.................... IndexType CoefficentIndex = 0;            // used as the index for the filter coefficients array in the difference equation calculation 
.................... IndexType InputIndex= 0;           // used as the index for the input samples array in the difference equation calculation 
.................... IndexType CurrentIndex = 0;          // keeps track of the current position of the circular buffer 
.................... IndexType NumberCSharpByteRecieved = 0; // counter to track which byte is being recieved 
.................... IndexType ErrorCounter = 0; // error detection 
.................... IndexType NormalizeDataCounter = 0; 
....................  
.................... FlagType DMADoneFlag = 0; 
.................... FlagType NormalizeFlag = 0; 
.................... FlagType UARTRXFlag = 0;   // serial flag 
.................... FlagType UARTTXFlag = 0;       // flag to send data out 
.................... FlagType HandShakeFlag = 1;    // handshake 
.................... FlagType TriggerFlag = 0; 
.................... FlagType DMAFlag = 0; 
....................  
.................... void AccumulateAnalogData(IndexType); 
.................... void NormalizeData(); 
.................... unsigned int8 QuickDigitize(unsigned int16); 
.................... signed int16 fir_coef[COEF_LENGTH] = 
.................... {   
.................... 210,   -167,   -150,   -155,   -171,   -192,   -213,   -231,   -243, // 10 HZ LPF FS 300HZ freq = 53334 Fin 
.................... -246,   -239,   -218,   -183,   -133,    -65,     19,    120,    237, 
.................... 368,    511,    664,    823,    984,   1145,   1302,   1449,   1584, 
.................... 1703,   1802,   1879,   1931,   1958,   1958,   1931,   1879,   1802, 
.................... 1703,   1584,   1449,   1302,   1145,    984,    823,    664,    511, 
.................... 368,    237,    120,     19,    -65,   -133,   -183,   -218,   -239, 
.................... -246,   -243,   -231,   -213,   -192,   -171,   -155,   -150,   -167, 
.................... 210 
.................... }; 
....................  
.................... #endif // MAIN_H 
....................  
....................  
....................  
....................  
....................  
.................... #use delay(clock = 32MHZ, internal = 8MHZ) 
.................... #BANK_DMA 
.................... unsigned int16 DMA_ADC_BUFFER[BUFFER_SIZE]; 
.................... #BANK_DMA 
.................... char DMA_UART_TX_BUFFER[BUFFER_SIZE]; 
.................... //Todo:: Two DMA Buffers for real time data sampling 
....................  
....................  
.................... #INT_DMA0 
.................... void  DMA_0_ISR(void)  
*
0200:  PUSH    42
0202:  PUSH    36
0204:  PUSH    32
0206:  MOV     W0,[W15++]
0208:  MOV     #2,W0
020A:  REPEAT  #C
020C:  MOV     [W0++],[W15++]
.................... { 
....................    DMADoneFlag = 1; 
020E:  MOV.B   #1,W0L
0210:  MOV.B   W0L,12D6
.................... } 
....................  
0212:  BCLR.B  84.4
0214:  MOV     #1A,W0
0216:  REPEAT  #C
0218:  MOV     [--W15],[W0--]
021A:  MOV     [--W15],W0
021C:  POP     32
021E:  POP     36
0220:  POP     42
0222:  RETFIE  
.................... #INT_DMA1 
.................... void DMA_1_ISR(void) 
0224:  PUSH    42
0226:  PUSH    36
0228:  PUSH    32
022A:  MOV     W0,[W15++]
022C:  MOV     #2,W0
022E:  REPEAT  #C
0230:  MOV     [W0++],[W15++]
.................... { 
.................... } 
....................  
0232:  BCLR.B  85.6
0234:  MOV     #1A,W0
0236:  REPEAT  #C
0238:  MOV     [--W15],[W0--]
023A:  MOV     [--W15],W0
023C:  POP     32
023E:  POP     36
0240:  POP     42
0242:  RETFIE  
.................... #INT_TIMER1 
.................... void Timer_ISR() 
0244:  PUSH    42
0246:  PUSH    36
0248:  PUSH    32
024A:  MOV     W0,[W15++]
024C:  MOV     #2,W0
024E:  REPEAT  #C
0250:  MOV     [W0++],[W15++]
.................... { 
....................    output_toggle(LED_PIN);  
0252:  BCLR.B  2C9.6
0254:  BTG.B   2CD.6
....................    read_adc(); 
0256:  BCLR.B  320.0
0258:  BSET.B  320.1
025A:  BTSS.B  320.0
025C:  BRA     25A
.................... //!   if(NormalizeFlag == 1) 
.................... //!   { 
.................... //!      read_adc(); 
.................... //!      NormalizeDataCounter++; 
.................... //!   } 
.................... //!   else 
.................... //!   { 
.................... //!      unsigned int16 ADCValue = 0; 
.................... //!       
.................... //!      if (TriggerFlag != 2) 
.................... //!      { 
.................... //!          ADCValue = QuickDigitize(read_adc()); 
.................... //!      } 
.................... //!       
.................... //!      if (DMAFlag == 0) 
.................... //!      { 
.................... //!         disable_interrupts(INT_DMA0); 
.................... //!         memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!         DMAFlag = 1; 
.................... //!      } 
.................... //!       
.................... //!      if((ADCValue == TriggerValue) && (TriggerFlag == 0)) 
.................... //!      { 
.................... //!         DMA_ADC_BUFFER[0] = ADCValue; 
.................... //!         TriggerFlag = 1; 
.................... //!      } 
.................... //!      else if(DMA_ADC_BUFFER[1] > ADCValue) 
.................... //!      { 
.................... //!         DMA_ADC_BUFFER[1] = ADCValue; 
.................... //!         TriggerFlag = 2; 
.................... //!      } 
.................... //!      else if(TriggerFlag == 2) 
.................... //!      { 
.................... //!         if(DMAFlag == 1) 
.................... //!         { 
.................... //!            //memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
.................... //!            dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
.................... //!            enable_interrupts(INT_DMA0); 
.................... //!            DMAFlag = 2; 
.................... //!         } 
.................... //!          
.................... //!         read_adc();//Fill DMA_ADC_BUFFER FROM POSITION 2 -> END OF BUFFER 
.................... //!      }   
.................... //!      else 
.................... //!      { 
.................... //!         ErrorCounter++; 
.................... //!          
.................... //!         if (ErrorCounter > 3000) 
.................... //!         { 
.................... //!            NormalizeFlag = 1; 
.................... //!         } 
.................... //!          
.................... //!         TriggerFlag = 0; 
.................... //!      } 
.................... //!   } 
....................     
.................... } 
....................  
025E:  BCLR.B  84.3
0260:  MOV     #1A,W0
0262:  REPEAT  #C
0264:  MOV     [--W15],[W0--]
0266:  MOV     [--W15],W0
0268:  POP     32
026A:  POP     36
026C:  POP     42
026E:  RETFIE  
.................... #INT_RDA2      // interrupt handler for the uart RS232 communication 
.................... void ISR_UART2() 
*
0292:  PUSH    42
0294:  PUSH    36
0296:  PUSH    32
0298:  MOV     W0,[W15++]
029A:  MOV     #2,W0
029C:  REPEAT  #C
029E:  MOV     [W0++],[W15++]
.................... { 
....................     UARTRX = fgetc(SHARP); // recieve data 
02A0:  CALL    270
02A4:  MOV.B   W0L,911
....................     UARTRXFlag = 1;         // serial flag turned high 
02A6:  MOV.B   #1,W0L
02A8:  MOV.B   W0L,12D8
02AA:  BCLR.B  87.6
02AC:  MOV     #1A,W0
02AE:  REPEAT  #C
02B0:  MOV     [--W15],[W0--]
02B2:  MOV     [--W15],W0
02B4:  POP     32
02B6:  POP     36
02B8:  POP     42
02BA:  RETFIE  
.................... } 
....................  
.................... void main() 
*
0C8A:  MOV     #4444,W0
0C8C:  MOV     W0,A4
0C8E:  BSET.B  81.7
0C90:  MOV     #46,W0
0C92:  MOV.B   W0L,742
0C94:  MOV     #57,W0
0C96:  MOV.B   W0L,742
0C98:  BCLR.B  742.6
0C9A:  MOV     #3F07,W0
0C9C:  MOV     W0,6A6
0C9E:  MOV     #5,W0
0CA0:  MOV     W0,6C6
0CA2:  MOV     #46,W0
0CA4:  MOV.B   W0L,742
0CA6:  MOV     #57,W0
0CA8:  MOV.B   W0L,742
0CAA:  BSET.B  742.6
0CAC:  MOV     #41,W4
0CAE:  MOV     W4,744
0CB0:  MOV     #32,W4
0CB2:  MOV     W4,746
0CB4:  CLR     85A
0CB6:  MOV     #8000,W4
0CB8:  MOV     W4,230
0CBA:  MOV     #400,W4
0CBC:  MOV     W4,232
0CBE:  BSET.B  230.3
0CC0:  MOV     #22,W4
0CC2:  MOV     W4,238
0CC4:  CLR     90E
0CC6:  CLR     A14
0CC8:  CLR     A16
0CCA:  CLR     A18
0CCC:  CLR     A1A
0CCE:  CLR     A1C
0CD0:  CLR     121E
0CD2:  CLR     1220
0CD4:  CLR     1222
0CD6:  CLR     1224
0CD8:  CLR     1226
0CDA:  CLR     1228
0CDC:  CLR     122A
0CDE:  CLR     122C
0CE0:  CLR     12B2
0CE2:  CLR     12B4
0CE4:  CLR     12B6
0CE6:  CLR     12B8
0CE8:  CLR     12BA
0CEA:  CLR     12BC
0CEC:  CLR     12BE
0CEE:  CLR     12C0
0CF0:  CLR     12C2
0CF2:  CLR     12C4
0CF4:  CLR     12C6
0CF6:  CLR     12C8
0CF8:  CLR     12CA
0CFA:  CLR     12CC
0CFC:  CLR     12CE
0CFE:  CLR     12D0
0D00:  CLR     12D2
0D02:  CLR     12D4
0D04:  CLR.B   12D6
0D06:  CLR.B   12D7
0D08:  CLR.B   12D8
0D0A:  CLR.B   12D9
0D0C:  MOV.B   #1,W0L
0D0E:  MOV.B   W0L,12DA
0D10:  CLR.B   12DB
0D12:  CLR.B   12DC
0D14:  MOV     #41,W4
0D16:  MOV     W4,744
0D18:  MOV     #32,W4
0D1A:  MOV     W4,746
0D1C:  DISI    #E
0D1E:  MOV     #101,W0
0D20:  MOV     #743,W1
0D22:  MOV     #78,W2
0D24:  MOV     #9A,W3
0D26:  MOV.B   W2L,[W1]
0D28:  MOV.B   W3L,[W1]
0D2A:  MOV.B   W0L,743
0D2C:  LSR     W0,#8,W0
0D2E:  MOV     #742,W1
0D30:  MOV     #46,W2
0D32:  MOV     #57,W3
0D34:  MOV.B   W2L,[W1]
0D36:  MOV.B   W3L,[W1]
0D38:  MOV.B   W0L,[W1]
0D3A:  SETM    32C
0D3C:  MOV     #3F80,W15
0D3E:  MOV     #3FFF,W0
0D40:  MOV     W0,20
0D42:  NOP     
0D44:  BRA     E34
0D46:  DATA    C0,06,08
0D48:  DATA    5C,00,00
0D4A:  DATA    4B,F0,3F
0D4C:  DATA    5C,0A,58
0D4E:  DATA    F6,3B,8F
0D50:  DATA    00,C0,3C
0D52:  DATA    8B,28,AC
0D54:  DATA    3C,BE,F6
0D56:  DATA    3F,D2,D5
0D58:  DATA    44,16,8C
0D5A:  DATA    15,D7,BF
0D5C:  DATA    69,00,5A
0D5E:  DATA    2E,1B,87
0D60:  DATA    99,3F,9A
0D62:  DATA    5F,AD,4B
0D64:  DATA    91,E4,01
0D66:  DATA    C0,5D,11
0D68:  DATA    2F,92,E4
0D6A:  DATA    81,FB,3F
0D6C:  DATA    38,DA,91
0D6E:  DATA    80,9D,C5
0D70:  DATA    E0,BF,6F
0D72:  DATA    12,C0,B4
0D74:  DATA    C3,09,AB
0D76:  DATA    3F,6B,C1
0D78:  DATA    03,4E,C1
0D7A:  DATA    B5,45,BF
0D7C:  DATA    F7,40,05
0D7E:  DATA    FF,00,5C
0D80:  DATA    EF,3F,F3
0D82:  DATA    A3,E2,F7
0D84:  DATA    D7,FF,01
0D86:  DATA    40,C0,B4
0D88:  DATA    FF,05,3C
0D8A:  DATA    58,FC,3F
0D8C:  DATA    3B,D3,C0
0D8E:  DATA    B5,BA,8C
0D90:  DATA    E2,3F,39
0D92:  DATA    D3,C7,3D
0D94:  DATA    41,79,B2
0D96:  DATA    3F,87,0D
0D98:  DATA    3C,50,D0
0D9A:  DATA    AF,62,3F
0D9C:  DATA    30,4B,8D
0D9E:  DATA    A2,82,AA
0DA0:  DATA    04,40,09
0DA2:  DATA    A0,40,4A
0DA4:  DATA    05,76,03
0DA6:  DATA    40,EC,9E
0DA8:  DATA    37,88,A6
0DAA:  DATA    44,F0,3F
0DAC:  DATA    8F,12,8D
0DAE:  DATA    29,9A,5B
0DB0:  DATA    C7,3F,0E
0DB2:  DATA    E0,80,7C
0DB4:  DATA    A1,D8,86
0DB6:  DATA    3F,29,4B
0DB8:  DATA    FB,95,C2
0DBA:  DATA    37,1A,3F
0DBC:  DATA    00,00,80
0DBE:  DATA    80,12,DE
0DC0:  DATA    D2,00,59
0DC2:  DATA    FF,6A,FF
0DC4:  DATA    65,FF,55
0DC6:  DATA    FF,40,FF
0DC8:  DATA    2B,FF,19
0DCA:  DATA    FF,0D,FF
0DCC:  DATA    0A,FF,11
0DCE:  DATA    FF,26,FF
0DD0:  DATA    49,FF,7B
0DD2:  DATA    FF,BF,FF
0DD4:  DATA    13,00,78
0DD6:  DATA    00,ED,00
0DD8:  DATA    70,01,FF
0DDA:  DATA    01,98,02
0DDC:  DATA    37,03,D8
0DDE:  DATA    03,79,04
0DE0:  DATA    16,05,A9
0DE2:  DATA    05,30,06
0DE4:  DATA    A7,06,0A
0DE6:  DATA    07,57,07
0DE8:  DATA    8B,07,A6
0DEA:  DATA    07,A6,07
0DEC:  DATA    8B,07,57
0DEE:  DATA    07,0A,07
0DF0:  DATA    A7,06,30
0DF2:  DATA    06,A9,05
0DF4:  DATA    16,05,79
0DF6:  DATA    04,D8,03
0DF8:  DATA    37,03,98
0DFA:  DATA    02,FF,01
0DFC:  DATA    70,01,ED
0DFE:  DATA    00,78,00
0E00:  DATA    13,00,BF
0E02:  DATA    FF,7B,FF
0E04:  DATA    49,FF,26
0E06:  DATA    FF,11,FF
0E08:  DATA    0A,FF,0D
0E0A:  DATA    FF,19,FF
0E0C:  DATA    2B,FF,40
0E0E:  DATA    FF,55,FF
0E10:  DATA    65,FF,6A
0E12:  DATA    FF,59,FF
0E14:  DATA    D2,00,00
0E16:  DATA    00,00,00
0E18:  INC     W2,W2
0E1A:  CP      W2,#1
0E1C:  BRA     NZ,E26
0E1E:  TBLRDL  [W1],W3
0E20:  TBLRDH  [W1++],W4
0E22:  MOV.B   6,W0L
0E24:  RETURN  
0E26:  CP      W2,#2
0E28:  BRA     NZ,E2E
0E2A:  MOV.B   7,W0L
0E2C:  RETURN  
0E2E:  MOV.B   8,W0L
0E30:  CLR     W2
0E32:  RETURN  
0E34:  MOV     #0,W6
0E36:  MOV     #0,W0
0E38:  MOV     W0,32
0E3A:  MOV     #D46,W0
0E3C:  MOV     W0,W1
0E3E:  CLR     W2
0E40:  CALL    E18
0E44:  MOV.B   W0L,B
0E46:  CALL    E18
0E4A:  MOV.B   W0L,A
0E4C:  CP0     W5
0E4E:  BRA     Z,E82
0E50:  BTSS    W5.F
0E52:  BRA     E62
0E54:  CALL    E18
0E58:  MOV.B   W0L,D
0E5A:  CALL    E18
0E5E:  MOV.B   W0L,C
0E60:  BCLR    W5.F
0E62:  BTSS    W5.E
0E64:  BRA     E76
0E66:  BCLR    W5.E
0E68:  DEC     W5,W5
0E6A:  CALL    E18
0E6E:  MOV.B   W0L,W7L
0E70:  REPEAT  W5
0E72:  MOV.B   W7L,[W6++]
0E74:  BRA     E40
0E76:  CALL    E18
0E7A:  MOV.B   W0L,[W6++]
0E7C:  DEC     W5,W5
0E7E:  BRA     NZ,E76
0E80:  BRA     E40
.................... {    
....................    memset(DMA_ADC_BUFFER, 0, BUFFER_SIZE * 2); 
0E82:  MOV     #4000,W1
0E84:  MOV     #0,W2
0E86:  REPEAT  #1FF
0E88:  CLR.B   [W1++]
....................    memset(DMA_UART_TX_BUFFER, 'a', BUFFER_SIZE * 2); 
0E8A:  MOV     #4200,W1
0E8C:  MOV     #61,W2
0E8E:  MOV.B   #61,W2L
0E90:  REPEAT  #1FF
0E92:  MOV.B   W2L,[W1++]
....................     
....................    setup_dma(ADC_DMA_CHANNEL, DMA_IN_ADC1, DMA_WORD); 
0E94:  CLR.B   381
0E96:  MOV.B   #D,W0L
0E98:  MOV.B   W0L,382
0E9A:  MOV     #300,W4
0E9C:  MOV     W4,388
....................    dma_start(ADC_DMA_CHANNEL, DMA_CONTINOUS, &DMA_ADC_BUFFER[0], BUFFER_SIZE); 
0E9E:  BCLR.B  381.7
0EA0:  CLR.B   380
0EA2:  MOV     #4000,W4
0EA4:  MOV     W4,384
0EA6:  MOV     #100,W4
0EA8:  MOV     W4,38A
0EAA:  BSET.B  381.7
....................     
....................    setup_dma(UART_TX_DMA_CHANNEL, DMA_OUT_UART2, DMA_BYTE); 
0EAC:  MOV.B   #60,W0L
0EAE:  MOV.B   W0L,38D
0EB0:  MOV.B   #1F,W0L
0EB2:  MOV.B   W0L,38E
0EB4:  MOV     #234,W4
0EB6:  MOV     W4,394
....................  
....................    enable_interrupts(INT_DMA0); 
0EB8:  BSET.B  94.4
....................    enable_interrupts(INT_DMA1); 
0EBA:  BSET.B  95.6
....................     
.................... //!   setup_adc_ports(sAN0, VSS_VDD); 
.................... //!   setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................    setup_adc(ADC_CLOCK_DIV_2 | ADC_TAD_MUL_4); 
0EBC:  MOV     #401,W4
0EBE:  MOV     W4,324
0EC0:  MOV     #84E0,W4
0EC2:  MOV     W4,320
....................    setup_adc_ports(sAN0 | VSS_VDD); 
0EC4:  MOV     #FFFE,W4
0EC6:  MOV     W4,32C
0EC8:  CLR     322
....................     
....................    read_adc(); 
0ECA:  BCLR.B  320.0
0ECC:  BSET.B  320.1
0ECE:  BTSS.B  320.0
0ED0:  BRA     ECE
....................     
....................    TimerTicks = 53334; 
0ED2:  MOV     #D056,W4
0ED4:  MOV     W4,90E
....................     
....................    setup_timer1(TMR_INTERNAL , TimerTicks); 
0ED6:  CLR     104
0ED8:  PUSH    90E
0EDA:  POP     102
0EDC:  MOV     #8000,W4
0EDE:  MOV     W4,104
....................    enable_interrupts(INT_TIMER1); 
0EE0:  BSET.B  94.3
....................    enable_interrupts(INTR_GLOBAL); 
0EE2:  BCLR.B  81.7
0EE4:  CLR     42
0EE6:  BSET.B  81.7
....................     
....................    NormalizeFlag = 1; 
0EE8:  MOV.B   #1,W0L
0EEA:  MOV.B   W0L,12D7
....................  
....................    while(TRUE) 
....................    { 
....................        
....................       if((DMADoneFlag) || (NormalizeDataCounter == BUFFER_SIZE)) 
0EEC:  CP0.B   12D6
0EEE:  BRA     NZ,EFA
0EF0:  MOV     12D2,W4
0EF2:  XOR     #100,W4
0EF4:  BRA     NZ,FAE
0EF6:  CP0     12D4
0EF8:  BRA     NZ,FAE
....................       { 
....................          disable_interrupts(INT_DMA0); 
0EFA:  BCLR.B  94.4
....................          for (IndexType Index = 0; Index < NumberOfDigitizationRequired; Index++) 
0EFC:  CLR     135E
0EFE:  CLR     1360
0F00:  MOV     1360,W4
0F02:  CP      W4,#0
0F04:  BRA     GTU,F22
0F06:  BRA     NC,F0E
0F08:  MOV     135E,W4
0F0A:  CP      W4,#4
0F0C:  BRA     C,F22
....................          { 
....................             AccumulateAnalogData(Index); 
0F0E:  PUSH    135E
0F10:  POP     1368
0F12:  PUSH    1360
0F14:  POP     136A
0F16:  CALL    5FA
0F1A:  INC     135E
0F1C:  BTSC.B  42.1
0F1E:  INC     1360
0F20:  BRA     F00
....................          } 
....................           
....................          if (NormalizeFlag == 1) 
0F22:  MOV     12D6,W4
0F24:  LSR     W4,#8,W4
0F26:  CP.B    W4L,#1
0F28:  BRA     NZ,F30
....................          { 
....................             NormalizeData(); 
0F2A:  CALL    A66
....................          } 
0F2E:  BRA     F30
....................          else 
....................          { 
....................           
....................          } 
....................           
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DMA_ADC_BUFFER[0], BUFFER_SIZE);     
....................          //dma_start(UART_TX_DMA_CHANNEL, DMA_ONE_SHOT | DMA_FORCE_NOW, &DigitizedData[0], BUFFER_SIZE);  
....................          //DMA THE ANALOG DATA ARRAY ALSO  
....................           
....................          for (IndexType i = 0; i < BUFFER_SIZE; i++) // send input array data 
0F30:  CLR     1362
0F32:  CLR     1364
0F34:  MOV     1364,W4
0F36:  CP      W4,#0
0F38:  BRA     GTU,F5E
0F3A:  BRA     NC,F44
0F3C:  MOV     1362,W4
0F3E:  MOV     #100,W3
0F40:  CP      W3,W4
0F42:  BRA     LEU,F5E
....................          { 
....................              printf("%c", AnalogData[i]); // send every emelent of the array as a byte 
0F44:  MOV     #912,W4
0F46:  MOV     1362,W3
0F48:  ADD     W3,W4,W0
0F4A:  MOV.B   [W0],W5L
0F4C:  BTSC.B  233.1
0F4E:  BRA     F4C
0F50:  PUSH    234
0F52:  MOV.B   W5L,[W15-#2]
0F54:  POP     234
0F56:  INC     1362
0F58:  BTSC.B  42.1
0F5A:  INC     1364
0F5C:  BRA     F34
....................          } 
....................  
....................          for (i = 0; i < BUFFER_SIZE; i++) // send digitized data 
0F5E:  CLR     1362
0F60:  CLR     1364
0F62:  MOV     1364,W4
0F64:  CP      W4,#0
0F66:  BRA     GTU,FA2
0F68:  BRA     NC,F72
0F6A:  MOV     1362,W4
0F6C:  MOV     #100,W3
0F6E:  CP      W3,W4
0F70:  BRA     LEU,FA2
....................          { 
....................              printf("%c", DigitizedData[i]); // send every emelent of the array as a byte 
0F72:  MOV     #2,W4
0F74:  CLR.B   9
0F76:  MOV     1362,W0
0F78:  MOV     1364,W1
0F7A:  INC     W4,W4
0F7C:  DEC     W4,W4
0F7E:  BRA     Z,F86
0F80:  SL      W0,W0
0F82:  RLC     W1,W1
0F84:  BRA     F7C
0F86:  MOV     #A1E,W4
0F88:  ADD     W0,W4,W0
0F8A:  MOV     #A,W4
0F8C:  MOV     [W0++],[W4++]
0F8E:  MOV     [W0++],[W4++]
0F90:  BTSC.B  233.1
0F92:  BRA     F90
0F94:  PUSH    234
0F96:  MOV.B   W5L,[W15-#2]
0F98:  POP     234
0F9A:  INC     1362
0F9C:  BTSC.B  42.1
0F9E:  INC     1364
0FA0:  BRA     F62
....................          } 
....................              
....................          CurrentIndex = 0; 
0FA2:  CLR     12C6
0FA4:  CLR     12C8
....................          enable_interrupts(INT_DMA0); 
0FA6:  BSET.B  94.4
....................          DMADoneFlag = 0; 
0FA8:  CLR.B   12D6
....................          DMAFlag = 0; 
0FAA:  CLR.B   12DC
....................          TriggerFlag = 0; 
0FAC:  CLR.B   12DB
....................       }       
0FAE:  BRA     EEC
....................    } 
.................... } 
....................  
0FB0:  BRA     FB0
.................... void AccumulateAnalogData(IndexType NumberOfDigitizationRequired) 
*
05FA:  MOV     W5,[W15++]
05FC:  MOV     W6,[W15++]
05FE:  MOV     W7,[W15++]
0600:  MOV     W8,[W15++]
0602:  MOV     #6,W4
0604:  CLR.B   9
0606:  PUSH    1368
0608:  POP     136C
060A:  PUSH    136A
060C:  POP     136E
060E:  INC     W4,W4
0610:  DEC     W4,W4
0612:  BRA     Z,61A
0614:  SL      136C
0616:  RLC     136E
0618:  BRA     610
.................... { 
....................    IndexType DMAADCIndex = (NumberOfDigitizationRequired * COEF_LENGTH); 
....................    IndexType Index; 
....................    memset(InputSamples, 0, COEF_LENGTH * 2); 
061A:  MOV     #122E,W1
061C:  MOV     #0,W2
061E:  REPEAT  #7F
0620:  CLR.B   [W1++]
....................     
....................    for (Index = 0; Index < COEF_LENGTH; Index++) //Todo:: Replace with MemCpy()  
0622:  CLR     1370
0624:  CLR     1372
0626:  MOV     1372,W4
0628:  CP      W4,#0
062A:  BRA     GTU,67A
062C:  BRA     NC,636
062E:  MOV     1370,W4
0630:  MOV     #40,W3
0632:  CP      W3,W4
0634:  BRA     LEU,67A
....................    { 
....................       InputSamples[Index] = DMA_ADC_BUFFER[DMAADCIndex++]; // >> 4; 
0636:  MOV     #1,W4
0638:  CLR.B   9
063A:  MOV     1370,W0
063C:  MOV     1372,W1
063E:  INC     W4,W4
0640:  DEC     W4,W4
0642:  BRA     Z,64A
0644:  SL      W0,W0
0646:  RLC     W1,W1
0648:  BRA     640
064A:  MOV     #122E,W4
064C:  ADD     W0,W4,W5
064E:  MOV     136E,W1
0650:  MOV     136C,W0
0652:  INC     136C
0654:  BTSC.B  42.1
0656:  INC     136E
0658:  MOV.D   W0,W6
065A:  MOV     #1,W4
065C:  CLR.B   9
065E:  MOV.D   W6,W0
0660:  INC     W4,W4
0662:  DEC     W4,W4
0664:  BRA     Z,66C
0666:  SL      W0,W0
0668:  RLC     W1,W1
066A:  BRA     662
066C:  MOV     #4000,W4
066E:  ADD     W0,W4,W0
0670:  MOV     [W0],[W5]
0672:  INC     1370
0674:  BTSC.B  42.1
0676:  INC     1372
0678:  BRA     626
....................    } 
....................     
....................    DMAADCIndex = (NumberOfDigitizationRequired * COEF_LENGTH);   
067A:  MOV     #6,W4
067C:  CLR.B   9
067E:  PUSH    1368
0680:  POP     136C
0682:  PUSH    136A
0684:  POP     136E
0686:  INC     W4,W4
0688:  DEC     W4,W4
068A:  BRA     Z,692
068C:  SL      136C
068E:  RLC     136E
0690:  BRA     688
....................     
....................    for (Index = 0; Index < COEF_LENGTH; Index++) 
0692:  CLR     1370
0694:  CLR     1372
0696:  MOV     1372,W4
0698:  CP      W4,#0
069A:  BRA     GTU,84C
069C:  BRA     NC,6A6
069E:  MOV     1370,W4
06A0:  MOV     #40,W3
06A2:  CP      W3,W4
06A4:  BRA     LEU,84C
....................    { 
....................       InputIndex = CurrentIndex;  
06A6:  PUSH    12C6
06A8:  POP     12C2
06AA:  PUSH    12C8
06AC:  POP     12C4
....................       Accumulator = 0; 
06AE:  CLR     A1A
06B0:  CLR     A1C
....................       CoefficentIndex = 0; 
06B2:  CLR     12BE
06B4:  CLR     12C0
....................        
....................       while (CoefficentIndex < COEF_LENGTH - 1) 
06B6:  MOV     12C0,W4
06B8:  CP      W4,#0
06BA:  BRA     GTU,73E
06BC:  BRA     NC,6C6
06BE:  MOV     12BE,W4
06C0:  MOV     #3F,W3
06C2:  CP      W3,W4
06C4:  BRA     LEU,73E
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
06C6:  MOV     #1,W4
06C8:  CLR.B   9
06CA:  MOV     12C2,W0
06CC:  MOV     12C4,W1
06CE:  INC     W4,W4
06D0:  DEC     W4,W4
06D2:  BRA     Z,6DA
06D4:  SL      W0,W0
06D6:  RLC     W1,W1
06D8:  BRA     6D0
06DA:  MOV     #122E,W4
06DC:  ADD     W0,W4,W0
06DE:  MOV     W0,W4
06E0:  MOV     [W4],W0
06E2:  MOV     W0,W5
06E4:  CLR     W6
06E6:  BTSC    W5.F
06E8:  SETM    W6
06EA:  MOV     #1,W4
06EC:  CLR.B   9
06EE:  MOV     12BE,W0
06F0:  MOV     12C0,W1
06F2:  INC     W4,W4
06F4:  DEC     W4,W4
06F6:  BRA     Z,6FE
06F8:  SL      W0,W0
06FA:  RLC     W1,W1
06FC:  BRA     6F4
06FE:  MOV     #12DE,W4
0700:  ADD     W0,W4,W0
0702:  MOV     W0,W4
0704:  MOV     [W4],W0
0706:  CLR     W1
0708:  BTSC    W0.F
070A:  SETM    W1
070C:  MOV     W0,W2
070E:  MOV     W1,W3
0710:  MOV     W5,W0
0712:  MOV     W6,W1
0714:  CALL    2BC
0718:  ADD     A1A
071A:  MOV     W1,W0
071C:  ADDC    A1C,W0
071E:  MOV     W0,A1C
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
0720:  MOV     12C2,W4
0722:  XOR     #3F,W4
0724:  BRA     NZ,730
0726:  CP0     12C4
0728:  BRA     NZ,730
....................          { 
....................             InputIndex = 0; 
072A:  CLR     12C2
072C:  CLR     12C4
....................          } 
072E:  BRA     736
....................          else 
....................          { 
....................             InputIndex++; 
0730:  INC     12C2
0732:  BTSC.B  42.1
0734:  INC     12C4
....................          } 
....................          CoefficentIndex++; 
0736:  INC     12BE
0738:  BTSC.B  42.1
073A:  INC     12C0
073C:  BRA     6B6
....................       } 
....................        
....................       AnalogData[DMAADCIndex++] = InputSamples[Index] >> 4; 
073E:  MOV     136E,W1
0740:  MOV     136C,W0
0742:  INC     136C
0744:  BTSC.B  42.1
0746:  INC     136E
0748:  MOV     W0,W5
074A:  MOV     W1,W6
074C:  MOV     #912,W4
074E:  ADD     W5,W4,W7
0750:  MOV     #1,W4
0752:  CLR.B   9
0754:  MOV     1370,W0
0756:  MOV     1372,W1
0758:  INC     W4,W4
075A:  DEC     W4,W4
075C:  BRA     Z,764
075E:  SL      W0,W0
0760:  RLC     W1,W1
0762:  BRA     75A
0764:  MOV     #122E,W4
0766:  ADD     W0,W4,W0
0768:  MOV     [W0],W8
076A:  LSR     W8,#4,W0
076C:  MOV.B   W0L,[W7]
076E:  MOV.B   W0L,[W7]
....................        
....................       if (NormalizeFlag == 1) 
0770:  MOV     12D6,W4
0772:  LSR     W4,#8,W4
0774:  CP.B    W4L,#1
0776:  BRA     NZ,798
....................       { 
....................          DigitizedData[DMAADCIndex] = Accumulator; 
0778:  MOV     #2,W4
077A:  CLR.B   9
077C:  MOV     136C,W0
077E:  MOV     136E,W1
0780:  INC     W4,W4
0782:  DEC     W4,W4
0784:  BRA     Z,78C
0786:  SL      W0,W0
0788:  RLC     W1,W1
078A:  BRA     782
078C:  MOV     #A1E,W4
078E:  ADD     W0,W4,W5
0790:  MOV     #A1A,W4
0792:  MOV     [W4++],[W5++]
0794:  MOV     [W4++],[W5++]
....................       } 
0796:  BRA     82E
....................       else 
....................       { 
....................          float StepOne = Accumulator - AverageAnalogValue; 
....................          float StepTwo = StepOne * AverageMultiplier; 
....................          float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
0798:  MOV     A1A,W0
079A:  MOV     A1C,W1
079C:  CLR     W3
079E:  BTSC    W1.F
07A0:  SETM    W3
07A2:  MOV     W3,W2
07A4:  MOV     1226,W4
07A6:  SUB     W0,W4,W0
07A8:  MOV     1228,W4
07AA:  SUBB    W1,W4,W1
07AC:  MOV     122A,W4
07AE:  SUBB    W2,W4,W2
07B0:  MOV     122C,W4
07B2:  SUBB    W3,W4,W3
07B4:  CALL    2FE
07B8:  MOV     W0,1374
07BA:  MOV     W1,1376
07BC:  MOV     1374,W0
07BE:  MOV     1376,W1
07C0:  MOV     12B6,W2
07C2:  MOV     12B8,W3
07C4:  CALL    360
07C8:  MOV     W0,1378
07CA:  MOV     W1,137A
07CC:  BCLR.B  43.0
07CE:  MOV     1378,W0
07D0:  MOV     137A,W1
07D2:  MOV     #0,W2
07D4:  MOV     #42FE,W3
07D6:  CALL    424
07DA:  MOV     W0,137C
07DC:  MOV     W1,137E
....................          //OutputValue = (Accumulator - AverageAnalogValue) * AverageMultiplier + (ADC_MAX_DATA_VALUE / 2); 
....................          //ConversionValue = (unsigned int8)OutputValue; 
....................          ConversionValue = (unsigned int8)StepThree; 
07DE:  MOV     137C,W0
07E0:  MOV     137E,W1
07E2:  CALL    5CE
07E6:  MOV.B   W0L,910
....................          DebugAccumulator[DMAADCIndex] = Accumulator; 
07E8:  MOV     #2,W4
07EA:  CLR.B   9
07EC:  MOV     136C,W0
07EE:  MOV     136E,W1
07F0:  INC     W4,W4
07F2:  DEC     W4,W4
07F4:  BRA     Z,7FC
07F6:  SL      W0,W0
07F8:  RLC     W1,W1
07FA:  BRA     7F2
07FC:  MOV     #E1E,W4
07FE:  ADD     W0,W4,W5
0800:  MOV     #A1A,W4
0802:  MOV     [W4++],[W5++]
0804:  MOV     [W4++],[W5++]
....................          DigitizedData[DMAADCIndex] = ConversionValue; 
0806:  MOV     #2,W4
0808:  CLR.B   9
080A:  MOV     136C,W0
080C:  MOV     136E,W1
080E:  INC     W4,W4
0810:  DEC     W4,W4
0812:  BRA     Z,81A
0814:  SL      W0,W0
0816:  RLC     W1,W1
0818:  BRA     810
081A:  MOV     #A1E,W4
081C:  ADD     W0,W4,W5
081E:  MOV     910,W0
0820:  MOV.B   W0L,[W5+#0]
0822:  MOV.B   #0,W0L
0824:  MOV.B   W0L,[W5+#1]
0826:  MOV.B   #0,W0L
0828:  MOV.B   W0L,[W5+#2]
082A:  MOV.B   #0,W0L
082C:  MOV.B   W0L,[W5+#3]
....................       } 
....................        
....................       if (CurrentIndex == 0) 
082E:  CP0     12C6
0830:  BRA     NZ,83E
0832:  CP0     12C8
0834:  BRA     NZ,83E
....................       { 
....................         CurrentIndex = COEF_LENGTH - 1; 
0836:  MOV     #3F,W4
0838:  MOV     W4,12C6
083A:  CLR     12C8
....................       } 
083C:  BRA     844
....................       else 
....................       { 
....................         CurrentIndex--; 
083E:  DEC     12C6
0840:  BTSS.B  42.0
0842:  DEC     12C8
....................       } 
0844:  INC     1370
0846:  BTSC.B  42.1
0848:  INC     1372
084A:  BRA     696
....................    } 
084C:  MOV     [--W15],W8
084E:  MOV     [--W15],W7
0850:  MOV     [--W15],W6
0852:  MOV     [--W15],W5
0854:  RETURN  
....................    
.................... } 
....................  
.................... void NormalizeData(void) 
*
0A66:  MOV     W5,[W15++]
0A68:  MOV     W6,[W15++]
0A6A:  MOV     W7,[W15++]
.................... { 
....................    if (ErrorCounter < 3000) 
0A6C:  MOV     12D0,W4
0A6E:  CP      W4,#0
0A70:  BRA     GTU,C10
0A72:  BRA     NC,A7C
0A74:  MOV     12CE,W4
0A76:  MOV     #BB8,W3
0A78:  CP      W3,W4
0A7A:  BRA     LEU,C10
....................    { 
....................       MaxAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A7C:  PUSH    B1E
0A7E:  POP     121E
0A80:  PUSH    B20
0A82:  POP     1220
....................       MinAnalogValue = DigitizedData[COEF_LENGTH]; //Todo::Remove Gloab Vairables Where Possbile  
0A84:  PUSH    B1E
0A86:  POP     1222
0A88:  PUSH    B20
0A8A:  POP     1224
....................       InitialTriggerValue = DMA_ADC_BUFFER[COEF_LENGTH]; 
0A8C:  PUSH    4080
0A8E:  POP     A14
....................        
....................       for (IndexType Index = COEF_LENGTH + 1 ; Index < BUFFER_SIZE; Index++) 
0A90:  MOV     #41,W4
0A92:  MOV     W4,1368
0A94:  CLR     136A
0A96:  MOV     136A,W4
0A98:  CP      W4,#0
0A9A:  BRA     GTU,BC0
0A9C:  BRA     NC,AA6
0A9E:  MOV     1368,W4
0AA0:  MOV     #100,W3
0AA2:  CP      W3,W4
0AA4:  BRA     LEU,BC0
....................       { 
....................          if (MinAnalogValue > DigitizedData[Index]) 
0AA6:  MOV     #2,W4
0AA8:  CLR.B   9
0AAA:  MOV     1368,W0
0AAC:  MOV     136A,W1
0AAE:  INC     W4,W4
0AB0:  DEC     W4,W4
0AB2:  BRA     Z,ABA
0AB4:  SL      W0,W0
0AB6:  RLC     W1,W1
0AB8:  BRA     AB0
0ABA:  MOV     #A1E,W4
0ABC:  ADD     W0,W4,W0
0ABE:  MOV     W0,W4
0AC0:  MOV     #0,W3
0AC2:  MOV     [W4++],[W3++]
0AC4:  MOV     [W4++],[W3++]
0AC6:  MOV     1224,W4
0AC8:  CP      W4,W1
0ACA:  BRA     LT,AF2
0ACC:  BRA     GT,AD4
0ACE:  MOV     1222,W4
0AD0:  CP      W4,W0
0AD2:  BRA     LEU,AF2
....................          { 
....................             MinAnalogValue = DigitizedData[Index]; 
0AD4:  MOV     #2,W4
0AD6:  CLR.B   9
0AD8:  MOV     1368,W0
0ADA:  MOV     136A,W1
0ADC:  INC     W4,W4
0ADE:  DEC     W4,W4
0AE0:  BRA     Z,AE8
0AE2:  SL      W0,W0
0AE4:  RLC     W1,W1
0AE6:  BRA     ADE
0AE8:  MOV     #A1E,W4
0AEA:  ADD     W0,W4,W0
0AEC:  MOV     #1222,W4
0AEE:  MOV     [W0++],[W4++]
0AF0:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (MaxAnalogValue < DigitizedData[Index]) 
0AF2:  MOV     #2,W4
0AF4:  CLR.B   9
0AF6:  MOV     1368,W0
0AF8:  MOV     136A,W1
0AFA:  INC     W4,W4
0AFC:  DEC     W4,W4
0AFE:  BRA     Z,B06
0B00:  SL      W0,W0
0B02:  RLC     W1,W1
0B04:  BRA     AFC
0B06:  MOV     #A1E,W4
0B08:  ADD     W0,W4,W0
0B0A:  MOV     W0,W4
0B0C:  MOV     #0,W3
0B0E:  MOV     [W4++],[W3++]
0B10:  MOV     [W4++],[W3++]
0B12:  MOV     1220,W4
0B14:  CP      W4,W1
0B16:  BRA     GT,B3E
0B18:  BRA     LT,B20
0B1A:  MOV     121E,W4
0B1C:  CP      W4,W0
0B1E:  BRA     C,B3E
....................          { 
....................             MaxAnalogValue = DigitizedData[Index]; 
0B20:  MOV     #2,W4
0B22:  CLR.B   9
0B24:  MOV     1368,W0
0B26:  MOV     136A,W1
0B28:  INC     W4,W4
0B2A:  DEC     W4,W4
0B2C:  BRA     Z,B34
0B2E:  SL      W0,W0
0B30:  RLC     W1,W1
0B32:  BRA     B2A
0B34:  MOV     #A1E,W4
0B36:  ADD     W0,W4,W0
0B38:  MOV     #121E,W4
0B3A:  MOV     [W0++],[W4++]
0B3C:  MOV     [W0++],[W4++]
....................          } 
....................           
....................          if (InitialTriggerValue > DMA_ADC_BUFFER[Index]) 
0B3E:  MOV     #1,W4
0B40:  CLR.B   9
0B42:  MOV     1368,W0
0B44:  MOV     136A,W1
0B46:  INC     W4,W4
0B48:  DEC     W4,W4
0B4A:  BRA     Z,B52
0B4C:  SL      W0,W0
0B4E:  RLC     W1,W1
0B50:  BRA     B48
0B52:  MOV     #4000,W4
0B54:  ADD     W0,W4,W0
0B56:  MOV     W0,W4
0B58:  MOV     [W4],W0
0B5A:  MOV     A14,W4
0B5C:  CP      W4,W0
0B5E:  BRA     LEU,B7C
....................          { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[Index]; 
0B60:  MOV     #1,W4
0B62:  CLR.B   9
0B64:  MOV     1368,W0
0B66:  MOV     136A,W1
0B68:  INC     W4,W4
0B6A:  DEC     W4,W4
0B6C:  BRA     Z,B74
0B6E:  SL      W0,W0
0B70:  RLC     W1,W1
0B72:  BRA     B6A
0B74:  MOV     #4000,W4
0B76:  ADD     W0,W4,W0
0B78:  MOV     [W0],[W15++]
0B7A:  POP     A14
....................          } 
....................           
....................          AverageAnalogValue = AverageAnalogValue + DigitizedData[Index]; 
0B7C:  MOV     #2,W4
0B7E:  CLR.B   9
0B80:  MOV     1368,W0
0B82:  MOV     136A,W1
0B84:  INC     W4,W4
0B86:  DEC     W4,W4
0B88:  BRA     Z,B90
0B8A:  SL      W0,W0
0B8C:  RLC     W1,W1
0B8E:  BRA     B86
0B90:  MOV     #A1E,W4
0B92:  ADD     W0,W4,W0
0B94:  MOV     W0,W4
0B96:  MOV     #0,W3
0B98:  MOV     [W4++],[W3++]
0B9A:  MOV     [W4++],[W3++]
0B9C:  CLR     W3
0B9E:  BTSC    W1.F
0BA0:  SETM    W3
0BA2:  MOV     W3,W2
0BA4:  ADD     1226
0BA6:  MOV     W1,W0
0BA8:  ADDC    1228,W0
0BAA:  MOV     W0,1228
0BAC:  MOV     122A,W4
0BAE:  ADDC    W2,W4,W0
0BB0:  MOV     W0,122A
0BB2:  MOV     122C,W4
0BB4:  ADDC    W3,W4,W0
0BB6:  MOV     W0,122C
0BB8:  INC     1368
0BBA:  BTSC.B  42.1
0BBC:  INC     136A
0BBE:  BRA     A96
....................       } 
....................        
....................       AverageDivider = MaxAnalogValue - MinAnalogValue; 
0BC0:  MOV     121E,W4
0BC2:  MOV     1222,W3
0BC4:  SUB     W4,W3,W0
0BC6:  MOV     1220,W4
0BC8:  MOV     1224,W3
0BCA:  SUBB    W4,W3,W1
0BCC:  CALL    856
0BD0:  MOV     W0,12B2
0BD2:  MOV     W1,12B4
....................       AverageMultiplier = ((float)ADC_MAX_DATA_VALUE / AverageDivider); 
0BD4:  MOV     #0,W0
0BD6:  MOV     #437F,W1
0BD8:  MOV     12B2,W2
0BDA:  MOV     12B4,W3
0BDC:  CALL    8A4
0BE0:  MOV     W0,12B6
0BE2:  MOV     W1,12B8
....................       AverageAnalogValue = AverageAnalogValue / (BUFFER_SIZE - COEF_LENGTH); 
0BE4:  BCLR.B  43.0
0BE6:  MOV     1226,W0
0BE8:  MOV     1228,W1
0BEA:  MOV     122A,W2
0BEC:  MOV     122C,W3
0BEE:  MOV     #C0,W4
0BF0:  MOV     #0,W5
0BF2:  MOV     #0,W6
0BF4:  MOV     #0,W7
0BF6:  CALL    96E
0BFA:  MOV     W0,1226
0BFC:  MOV     W1,1228
0BFE:  MOV     W2,122A
0C00:  MOV     W3,122C
....................        
....................       TriggerValue = InitialTriggerValue; 
0C02:  PUSH    A14
0C04:  POP     A16
....................                 
....................       memset(DigitizedData, 0, BUFFER_SIZE * 2);           
0C06:  MOV     #A1E,W1
0C08:  MOV     #0,W2
0C0A:  REPEAT  #1FF
0C0C:  CLR.B   [W1++]
....................    }   
0C0E:  BRA     C78
....................    else  
....................    { 
....................       InitialTriggerValue = DMA_ADC_BUFFER[64]; 
0C10:  PUSH    4080
0C12:  POP     A14
....................       for (IndexType i = 65; i < BUFFER_SIZE; i++) 
0C14:  MOV     #41,W4
0C16:  MOV     W4,136C
0C18:  CLR     136E
0C1A:  MOV     136E,W4
0C1C:  CP      W4,#0
0C1E:  BRA     GTU,C70
0C20:  BRA     NC,C2A
0C22:  MOV     136C,W4
0C24:  MOV     #100,W3
0C26:  CP      W3,W4
0C28:  BRA     LEU,C70
....................       { 
....................         if (InitialTriggerValue > DMA_ADC_BUFFER[i]) 
0C2A:  MOV     #1,W4
0C2C:  CLR.B   9
0C2E:  MOV     136C,W0
0C30:  MOV     136E,W1
0C32:  INC     W4,W4
0C34:  DEC     W4,W4
0C36:  BRA     Z,C3E
0C38:  SL      W0,W0
0C3A:  RLC     W1,W1
0C3C:  BRA     C34
0C3E:  MOV     #4000,W4
0C40:  ADD     W0,W4,W0
0C42:  MOV     W0,W4
0C44:  MOV     [W4],W0
0C46:  MOV     A14,W4
0C48:  CP      W4,W0
0C4A:  BRA     LEU,C68
....................         { 
....................             InitialTriggerValue = DMA_ADC_BUFFER[i]; 
0C4C:  MOV     #1,W4
0C4E:  CLR.B   9
0C50:  MOV     136C,W0
0C52:  MOV     136E,W1
0C54:  INC     W4,W4
0C56:  DEC     W4,W4
0C58:  BRA     Z,C60
0C5A:  SL      W0,W0
0C5C:  RLC     W1,W1
0C5E:  BRA     C56
0C60:  MOV     #4000,W4
0C62:  ADD     W0,W4,W0
0C64:  MOV     [W0],[W15++]
0C66:  POP     A14
....................         }              
0C68:  INC     136C
0C6A:  BTSC.B  42.1
0C6C:  INC     136E
0C6E:  BRA     C1A
....................       } 
....................        
....................       TriggerValue = InitialTriggerValue; 
0C70:  PUSH    A14
0C72:  POP     A16
....................       ErrorCounter = 0;  
0C74:  CLR     12CE
0C76:  CLR     12D0
....................    } 
....................     
....................    NormalizeDataCounter = 0; 
0C78:  CLR     12D2
0C7A:  CLR     12D4
....................    NormalizeFlag = 0; 
0C7C:  CLR.B   12D7
....................    CurrentIndex = 0; 
0C7E:  CLR     12C6
0C80:  CLR     12C8
0C82:  MOV     [--W15],W7
0C84:  MOV     [--W15],W6
0C86:  MOV     [--W15],W5
0C88:  RETURN  
.................... } 
....................  
.................... unsigned int8 QuickDigitize(unsigned int16 ADCValue) 
.................... { 
....................     IndexType InputIndex = CurrentIndex; 
....................     IndexType CoefficentIndex = 0; 
....................     unsigned int Accumulator = 0; 
....................     while (CoefficentIndex < COEF_LENGTH - 1) 
....................       { 
....................          Accumulator += (signed int32)InputSamples[InputIndex] * (signed int32)fir_coef[CoefficentIndex]; 
....................            // condition for the circular buffer 
....................          if (InputIndex == COEF_LENGTH - 1) 
....................          { 
....................             InputIndex = 0; 
....................          } 
....................          else 
....................          { 
....................             InputIndex++; 
....................          } 
....................          CoefficentIndex++; 
....................       } 
....................        
....................     float StepOne = Accumulator - AverageAnalogValue; 
....................     float StepTwo = StepOne * AverageMultiplier; 
....................     float StepThree = StepTwo + (ADC_MAX_DATA_VALUE / 2); 
....................     unsigned int8 ConversionValue = (unsigned int8)StepThree; 
....................        
....................     return ConversionValue;   
.................... } 

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0081   FRC_PLL IESO
          H: FF00  
   Word  5L: 0027   NOPR NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 00F0   NOPUT NOALTI2C1 LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: FF00  
   Word  8L: 0043   ICSP1 NOJTAG DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
